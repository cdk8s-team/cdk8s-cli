// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`importing helm chart helm:https://charts.bitnami.com/bitnami/mysql@9.10.10 with python lanugage 1`] = `
Object {
  "author": Object {
    "name": "generated@generated.com",
    "roles": Array [
      "author",
    ],
  },
  "dependencies": "__omitted__",
  "dependencyClosure": Object {
    "cdk8s": Object {
      "targets": Object {
        "dotnet": Object {
          "namespace": "Org.Cdk8s",
          "packageId": "Org.Cdk8s",
        },
        "go": Object {
          "moduleName": "github.com/cdk8s-team/cdk8s-core-go",
        },
        "java": Object {
          "maven": Object {
            "artifactId": "cdk8s",
            "groupId": "org.cdk8s",
          },
          "package": "org.cdk8s",
        },
        "js": Object {
          "npm": "cdk8s",
        },
        "python": Object {
          "distName": "cdk8s",
          "module": "cdk8s",
        },
      },
    },
    "constructs": Object {
      "targets": Object {
        "dotnet": Object {
          "namespace": "Constructs",
          "packageId": "Constructs",
        },
        "go": Object {
          "moduleName": "github.com/aws/constructs-go",
        },
        "java": Object {
          "maven": Object {
            "artifactId": "constructs",
            "groupId": "software.constructs",
          },
          "package": "software.constructs",
        },
        "js": Object {
          "npm": "constructs",
        },
        "python": Object {
          "distName": "constructs",
          "module": "constructs",
        },
      },
    },
  },
  "description": "mysql",
  "fingerprint": "<fingerprint>",
  "homepage": "http://generated",
  "jsiiVersion": "__omitted__",
  "license": "UNLICENSED",
  "metadata": Object {
    "jsii": Object {
      "pacmak": Object {
        "hasDefaultInterfaces": true,
      },
    },
  },
  "name": "mysql",
  "repository": Object {
    "type": "git",
    "url": "http://generated",
  },
  "schema": "jsii/0.10.0",
  "targets": Object {
    "js": Object {
      "npm": "mysql",
    },
    "python": Object {
      "distName": "generated",
      "module": "mysql",
    },
  },
  "types": Object {
    "mysql.Mysql": Object {
      "assembly": "mysql",
      "base": "constructs.Construct",
      "fqn": "mysql.Mysql",
      "initializer": Object {
        "locationInModule": Object {
          "filename": "mysql.ts",
          "line": 14,
        },
        "parameters": Array [
          Object {
            "name": "scope",
            "type": Object {
              "fqn": "constructs.Construct",
            },
          },
          Object {
            "name": "id",
            "type": Object {
              "primitive": "string",
            },
          },
          Object {
            "name": "props",
            "optional": true,
            "type": Object {
              "fqn": "mysql.MysqlProps",
            },
          },
        ],
      },
      "kind": "class",
      "locationInModule": Object {
        "filename": "mysql.ts",
        "line": 13,
      },
      "name": "Mysql",
      "symbolId": "mysql:Mysql",
    },
    "mysql.MysqlArchitecture": Object {
      "assembly": "mysql",
      "docs": Object {
        "custom": Object {
          "schema": "MysqlArchitecture",
        },
        "summary": "Allowed values: \`standalone\` or \`replication\`.",
      },
      "fqn": "mysql.MysqlArchitecture",
      "kind": "enum",
      "locationInModule": Object {
        "filename": "mysql.ts",
        "line": 113,
      },
      "members": Array [
        Object {
          "docs": Object {
            "summary": "standalone.",
          },
          "name": "STANDALONE",
        },
        Object {
          "docs": Object {
            "summary": "replication.",
          },
          "name": "REPLICATION",
        },
      ],
      "name": "MysqlArchitecture",
      "symbolId": "mysql:MysqlArchitecture",
    },
    "mysql.MysqlAuth": Object {
      "assembly": "mysql",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "MysqlAuth",
        },
      },
      "fqn": "mysql.MysqlAuth",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "mysql.ts",
        "line": 123,
      },
      "name": "MysqlAuth",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlAuth#password",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 145,
          },
          "name": "password",
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlAuth#username",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 140,
          },
          "name": "username",
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlAuth#additionalValues",
            },
            "summary": "Values that are not available in values.schema.json will not be code generated. You can add such values to this property.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 167,
          },
          "name": "additionalValues",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "any",
              },
              "kind": "map",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlAuth#createDatabase",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 160,
          },
          "name": "createDatabase",
          "optional": true,
          "type": Object {
            "primitive": "boolean",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlAuth#database",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 135,
          },
          "name": "database",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlAuth#replicationPassword",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 155,
          },
          "name": "replicationPassword",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlAuth#replicationUser",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 150,
          },
          "name": "replicationUser",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlAuth#rootPassword",
            },
            "default": "a random 10-character alphanumeric string if not set",
            "summary": "Defaults to a random 10-character alphanumeric string if not set.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 130,
          },
          "name": "rootPassword",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
      ],
      "symbolId": "mysql:MysqlAuth",
    },
    "mysql.MysqlPrimary": Object {
      "assembly": "mysql",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "MysqlPrimary",
        },
      },
      "fqn": "mysql.MysqlPrimary",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "mysql.ts",
        "line": 174,
      },
      "name": "MysqlPrimary",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlPrimary#additionalValues",
            },
            "summary": "Values that are not available in values.schema.json will not be code generated. You can add such values to this property.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 195,
          },
          "name": "additionalValues",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "any",
              },
              "kind": "map",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlPrimary#containerSecurityContext",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 183,
          },
          "name": "containerSecurityContext",
          "optional": true,
          "type": Object {
            "fqn": "mysql.MysqlPrimaryContainerSecurityContext",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlPrimary#persistence",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 188,
          },
          "name": "persistence",
          "optional": true,
          "type": Object {
            "fqn": "mysql.MysqlPrimaryPersistence",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlPrimary#podSecurityContext",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 178,
          },
          "name": "podSecurityContext",
          "optional": true,
          "type": Object {
            "fqn": "mysql.MysqlPrimaryPodSecurityContext",
          },
        },
      ],
      "symbolId": "mysql:MysqlPrimary",
    },
    "mysql.MysqlPrimaryContainerSecurityContext": Object {
      "assembly": "mysql",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "MysqlPrimaryContainerSecurityContext",
        },
      },
      "fqn": "mysql.MysqlPrimaryContainerSecurityContext",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "mysql.ts",
        "line": 253,
      },
      "name": "MysqlPrimaryContainerSecurityContext",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlPrimaryContainerSecurityContext#additionalValues",
            },
            "summary": "Values that are not available in values.schema.json will not be code generated. You can add such values to this property.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 269,
          },
          "name": "additionalValues",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "any",
              },
              "kind": "map",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlPrimaryContainerSecurityContext#enabled",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 257,
          },
          "name": "enabled",
          "optional": true,
          "type": Object {
            "primitive": "boolean",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlPrimaryContainerSecurityContext#runAsUser",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 262,
          },
          "name": "runAsUser",
          "optional": true,
          "type": Object {
            "primitive": "number",
          },
        },
      ],
      "symbolId": "mysql:MysqlPrimaryContainerSecurityContext",
    },
    "mysql.MysqlPrimaryPersistence": Object {
      "assembly": "mysql",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "MysqlPrimaryPersistence",
        },
      },
      "fqn": "mysql.MysqlPrimaryPersistence",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "mysql.ts",
        "line": 276,
      },
      "name": "MysqlPrimaryPersistence",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlPrimaryPersistence#additionalValues",
            },
            "summary": "Values that are not available in values.schema.json will not be code generated. You can add such values to this property.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 292,
          },
          "name": "additionalValues",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "any",
              },
              "kind": "map",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlPrimaryPersistence#enabled",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 280,
          },
          "name": "enabled",
          "optional": true,
          "type": Object {
            "primitive": "boolean",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlPrimaryPersistence#size",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 285,
          },
          "name": "size",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
      ],
      "symbolId": "mysql:MysqlPrimaryPersistence",
    },
    "mysql.MysqlPrimaryPodSecurityContext": Object {
      "assembly": "mysql",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "MysqlPrimaryPodSecurityContext",
        },
      },
      "fqn": "mysql.MysqlPrimaryPodSecurityContext",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "mysql.ts",
        "line": 230,
      },
      "name": "MysqlPrimaryPodSecurityContext",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlPrimaryPodSecurityContext#additionalValues",
            },
            "summary": "Values that are not available in values.schema.json will not be code generated. You can add such values to this property.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 246,
          },
          "name": "additionalValues",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "any",
              },
              "kind": "map",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlPrimaryPodSecurityContext#enabled",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 234,
          },
          "name": "enabled",
          "optional": true,
          "type": Object {
            "primitive": "boolean",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlPrimaryPodSecurityContext#fsGroup",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 239,
          },
          "name": "fsGroup",
          "optional": true,
          "type": Object {
            "primitive": "number",
          },
        },
      ],
      "symbolId": "mysql:MysqlPrimaryPodSecurityContext",
    },
    "mysql.MysqlProps": Object {
      "assembly": "mysql",
      "datatype": true,
      "fqn": "mysql.MysqlProps",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "mysql.ts",
        "line": 5,
      },
      "name": "MysqlProps",
      "properties": Array [
        Object {
          "abstract": true,
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 8,
          },
          "name": "helmExecutable",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 9,
          },
          "name": "helmFlags",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "string",
              },
              "kind": "array",
            },
          },
        },
        Object {
          "abstract": true,
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 6,
          },
          "name": "namespace",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 7,
          },
          "name": "releaseName",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 10,
          },
          "name": "values",
          "optional": true,
          "type": Object {
            "fqn": "mysql.MysqlValues",
          },
        },
      ],
      "symbolId": "mysql:MysqlProps",
    },
    "mysql.MysqlSecondary": Object {
      "assembly": "mysql",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "MysqlSecondary",
        },
      },
      "fqn": "mysql.MysqlSecondary",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "mysql.ts",
        "line": 202,
      },
      "name": "MysqlSecondary",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlSecondary#additionalValues",
            },
            "summary": "Values that are not available in values.schema.json will not be code generated. You can add such values to this property.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 223,
          },
          "name": "additionalValues",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "any",
              },
              "kind": "map",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlSecondary#containerSecurityContext",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 211,
          },
          "name": "containerSecurityContext",
          "optional": true,
          "type": Object {
            "fqn": "mysql.MysqlSecondaryContainerSecurityContext",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlSecondary#persistence",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 216,
          },
          "name": "persistence",
          "optional": true,
          "type": Object {
            "fqn": "mysql.MysqlSecondaryPersistence",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlSecondary#podSecurityContext",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 206,
          },
          "name": "podSecurityContext",
          "optional": true,
          "type": Object {
            "fqn": "mysql.MysqlSecondaryPodSecurityContext",
          },
        },
      ],
      "symbolId": "mysql:MysqlSecondary",
    },
    "mysql.MysqlSecondaryContainerSecurityContext": Object {
      "assembly": "mysql",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "MysqlSecondaryContainerSecurityContext",
        },
      },
      "fqn": "mysql.MysqlSecondaryContainerSecurityContext",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "mysql.ts",
        "line": 322,
      },
      "name": "MysqlSecondaryContainerSecurityContext",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlSecondaryContainerSecurityContext#additionalValues",
            },
            "summary": "Values that are not available in values.schema.json will not be code generated. You can add such values to this property.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 338,
          },
          "name": "additionalValues",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "any",
              },
              "kind": "map",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlSecondaryContainerSecurityContext#enabled",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 326,
          },
          "name": "enabled",
          "optional": true,
          "type": Object {
            "primitive": "boolean",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlSecondaryContainerSecurityContext#runAsUser",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 331,
          },
          "name": "runAsUser",
          "optional": true,
          "type": Object {
            "primitive": "number",
          },
        },
      ],
      "symbolId": "mysql:MysqlSecondaryContainerSecurityContext",
    },
    "mysql.MysqlSecondaryPersistence": Object {
      "assembly": "mysql",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "MysqlSecondaryPersistence",
        },
      },
      "fqn": "mysql.MysqlSecondaryPersistence",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "mysql.ts",
        "line": 345,
      },
      "name": "MysqlSecondaryPersistence",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlSecondaryPersistence#additionalValues",
            },
            "summary": "Values that are not available in values.schema.json will not be code generated. You can add such values to this property.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 361,
          },
          "name": "additionalValues",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "any",
              },
              "kind": "map",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlSecondaryPersistence#enabled",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 349,
          },
          "name": "enabled",
          "optional": true,
          "type": Object {
            "primitive": "boolean",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlSecondaryPersistence#size",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 354,
          },
          "name": "size",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
      ],
      "symbolId": "mysql:MysqlSecondaryPersistence",
    },
    "mysql.MysqlSecondaryPodSecurityContext": Object {
      "assembly": "mysql",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "MysqlSecondaryPodSecurityContext",
        },
      },
      "fqn": "mysql.MysqlSecondaryPodSecurityContext",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "mysql.ts",
        "line": 299,
      },
      "name": "MysqlSecondaryPodSecurityContext",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlSecondaryPodSecurityContext#additionalValues",
            },
            "summary": "Values that are not available in values.schema.json will not be code generated. You can add such values to this property.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 315,
          },
          "name": "additionalValues",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "any",
              },
              "kind": "map",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlSecondaryPodSecurityContext#enabled",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 303,
          },
          "name": "enabled",
          "optional": true,
          "type": Object {
            "primitive": "boolean",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlSecondaryPodSecurityContext#fsGroup",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 308,
          },
          "name": "fsGroup",
          "optional": true,
          "type": Object {
            "primitive": "number",
          },
        },
      ],
      "symbolId": "mysql:MysqlSecondaryPodSecurityContext",
    },
    "mysql.MysqlValues": Object {
      "assembly": "mysql",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "mysql",
        },
      },
      "fqn": "mysql.MysqlValues",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "mysql.ts",
        "line": 66,
      },
      "name": "MysqlValues",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "mysql#additionalValues",
            },
            "summary": "Values that are not available in values.schema.json will not be code generated. You can add such values to this property.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 104,
          },
          "name": "additionalValues",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "any",
              },
              "kind": "map",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "mysql#architecture",
            },
            "summary": "Allowed values: \`standalone\` or \`replication\`.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 72,
          },
          "name": "architecture",
          "optional": true,
          "type": Object {
            "fqn": "mysql.MysqlArchitecture",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "mysql#auth",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 77,
          },
          "name": "auth",
          "optional": true,
          "type": Object {
            "fqn": "mysql.MysqlAuth",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "mysql#common",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 92,
          },
          "name": "common",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "any",
              },
              "kind": "map",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "mysql#global",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 97,
          },
          "name": "global",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "any",
              },
              "kind": "map",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "mysql#primary",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 82,
          },
          "name": "primary",
          "optional": true,
          "type": Object {
            "fqn": "mysql.MysqlPrimary",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "mysql#secondary",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 87,
          },
          "name": "secondary",
          "optional": true,
          "type": Object {
            "fqn": "mysql.MysqlSecondary",
          },
        },
      ],
      "symbolId": "mysql:MysqlValues",
    },
  },
  "version": "0.0.0",
}
`;

exports[`importing helm chart helm:https://charts.bitnami.com/bitnami/mysql@9.10.10 with python lanugage 2`] = `
Object {
  "mysql/__init__.py": "from pkgutil import extend_path
__path__ = extend_path(__path__, __name__)

import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

import typeguard
from importlib.metadata import version as _metadata_package_version
TYPEGUARD_MAJOR_VERSION = int(_metadata_package_version('typeguard').split('.')[0])

def check_type(argname: str, value: object, expected_type: typing.Any) -> typing.Any:
    if TYPEGUARD_MAJOR_VERSION <= 2:
        return typeguard.check_type(argname=argname, value=value, expected_type=expected_type) # type:ignore
    else:
        if isinstance(value, jsii._reference_map.InterfaceDynamicProxy): # pyright: ignore [reportAttributeAccessIssue]
           pass
        else:
            if TYPEGUARD_MAJOR_VERSION == 3:
                typeguard.config.collection_check_strategy = typeguard.CollectionCheckStrategy.ALL_ITEMS # type:ignore
                typeguard.check_type(value=value, expected_type=expected_type) # type:ignore
            else:
                typeguard.check_type(value=value, expected_type=expected_type, collection_check_strategy=typeguard.CollectionCheckStrategy.ALL_ITEMS) # type:ignore

from ._jsii import *

import constructs as _constructs_77d1e7e8


class Mysql(
    _constructs_77d1e7e8.Construct,
    metaclass=jsii.JSIIMeta,
    jsii_type=\\"mysql.Mysql\\",
):
    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        helm_executable: typing.Optional[builtins.str] = None,
        helm_flags: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace: typing.Optional[builtins.str] = None,
        release_name: typing.Optional[builtins.str] = None,
        values: typing.Optional[typing.Union[\\"MysqlValues\\", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param helm_executable: -
        :param helm_flags: -
        :param namespace: -
        :param release_name: -
        :param values: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__95a811b01af67eee2d8e2ae24fcefa9fa2ac995a1f9685f3e921af5330ef82ff)
            check_type(argname=\\"argument scope\\", value=scope, expected_type=type_hints[\\"scope\\"])
            check_type(argname=\\"argument id\\", value=id, expected_type=type_hints[\\"id\\"])
        props = MysqlProps(
            helm_executable=helm_executable,
            helm_flags=helm_flags,
            namespace=namespace,
            release_name=release_name,
            values=values,
        )

        jsii.create(self.__class__, self, [scope, id, props])


@jsii.enum(jsii_type=\\"mysql.MysqlArchitecture\\")
class MysqlArchitecture(enum.Enum):
    '''Allowed values: \`\`standalone\`\` or \`\`replication\`\`.

    :schema: MysqlArchitecture
    '''

    STANDALONE = \\"STANDALONE\\"
    '''standalone.'''
    REPLICATION = \\"REPLICATION\\"
    '''replication.'''


@jsii.data_type(
    jsii_type=\\"mysql.MysqlAuth\\",
    jsii_struct_bases=[],
    name_mapping={
        \\"password\\": \\"password\\",
        \\"username\\": \\"username\\",
        \\"additional_values\\": \\"additionalValues\\",
        \\"create_database\\": \\"createDatabase\\",
        \\"database\\": \\"database\\",
        \\"replication_password\\": \\"replicationPassword\\",
        \\"replication_user\\": \\"replicationUser\\",
        \\"root_password\\": \\"rootPassword\\",
    },
)
class MysqlAuth:
    def __init__(
        self,
        *,
        password: builtins.str,
        username: builtins.str,
        additional_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        create_database: typing.Optional[builtins.bool] = None,
        database: typing.Optional[builtins.str] = None,
        replication_password: typing.Optional[builtins.str] = None,
        replication_user: typing.Optional[builtins.str] = None,
        root_password: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param password: 
        :param username: 
        :param additional_values: Values that are not available in values.schema.json will not be code generated. You can add such values to this property.
        :param create_database: 
        :param database: 
        :param replication_password: 
        :param replication_user: 
        :param root_password: Defaults to a random 10-character alphanumeric string if not set. Default: a random 10-character alphanumeric string if not set

        :schema: MysqlAuth
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ee06bc5fa81868398bad26c41946af017c8765bcca5abe66e5d88d360a20e315)
            check_type(argname=\\"argument password\\", value=password, expected_type=type_hints[\\"password\\"])
            check_type(argname=\\"argument username\\", value=username, expected_type=type_hints[\\"username\\"])
            check_type(argname=\\"argument additional_values\\", value=additional_values, expected_type=type_hints[\\"additional_values\\"])
            check_type(argname=\\"argument create_database\\", value=create_database, expected_type=type_hints[\\"create_database\\"])
            check_type(argname=\\"argument database\\", value=database, expected_type=type_hints[\\"database\\"])
            check_type(argname=\\"argument replication_password\\", value=replication_password, expected_type=type_hints[\\"replication_password\\"])
            check_type(argname=\\"argument replication_user\\", value=replication_user, expected_type=type_hints[\\"replication_user\\"])
            check_type(argname=\\"argument root_password\\", value=root_password, expected_type=type_hints[\\"root_password\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            \\"password\\": password,
            \\"username\\": username,
        }
        if additional_values is not None:
            self._values[\\"additional_values\\"] = additional_values
        if create_database is not None:
            self._values[\\"create_database\\"] = create_database
        if database is not None:
            self._values[\\"database\\"] = database
        if replication_password is not None:
            self._values[\\"replication_password\\"] = replication_password
        if replication_user is not None:
            self._values[\\"replication_user\\"] = replication_user
        if root_password is not None:
            self._values[\\"root_password\\"] = root_password

    @builtins.property
    def password(self) -> builtins.str:
        '''
        :schema: MysqlAuth#password
        '''
        result = self._values.get(\\"password\\")
        assert result is not None, \\"Required property 'password' is missing\\"
        return typing.cast(builtins.str, result)

    @builtins.property
    def username(self) -> builtins.str:
        '''
        :schema: MysqlAuth#username
        '''
        result = self._values.get(\\"username\\")
        assert result is not None, \\"Required property 'username' is missing\\"
        return typing.cast(builtins.str, result)

    @builtins.property
    def additional_values(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''Values that are not available in values.schema.json will not be code generated. You can add such values to this property.

        :schema: MysqlAuth#additionalValues
        '''
        result = self._values.get(\\"additional_values\\")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def create_database(self) -> typing.Optional[builtins.bool]:
        '''
        :schema: MysqlAuth#createDatabase
        '''
        result = self._values.get(\\"create_database\\")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def database(self) -> typing.Optional[builtins.str]:
        '''
        :schema: MysqlAuth#database
        '''
        result = self._values.get(\\"database\\")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def replication_password(self) -> typing.Optional[builtins.str]:
        '''
        :schema: MysqlAuth#replicationPassword
        '''
        result = self._values.get(\\"replication_password\\")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def replication_user(self) -> typing.Optional[builtins.str]:
        '''
        :schema: MysqlAuth#replicationUser
        '''
        result = self._values.get(\\"replication_user\\")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def root_password(self) -> typing.Optional[builtins.str]:
        '''Defaults to a random 10-character alphanumeric string if not set.

        :default: a random 10-character alphanumeric string if not set

        :schema: MysqlAuth#rootPassword
        '''
        result = self._values.get(\\"root_password\\")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"MysqlAuth(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type=\\"mysql.MysqlPrimary\\",
    jsii_struct_bases=[],
    name_mapping={
        \\"additional_values\\": \\"additionalValues\\",
        \\"container_security_context\\": \\"containerSecurityContext\\",
        \\"persistence\\": \\"persistence\\",
        \\"pod_security_context\\": \\"podSecurityContext\\",
    },
)
class MysqlPrimary:
    def __init__(
        self,
        *,
        additional_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        container_security_context: typing.Optional[typing.Union[\\"MysqlPrimaryContainerSecurityContext\\", typing.Dict[builtins.str, typing.Any]]] = None,
        persistence: typing.Optional[typing.Union[\\"MysqlPrimaryPersistence\\", typing.Dict[builtins.str, typing.Any]]] = None,
        pod_security_context: typing.Optional[typing.Union[\\"MysqlPrimaryPodSecurityContext\\", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param additional_values: Values that are not available in values.schema.json will not be code generated. You can add such values to this property.
        :param container_security_context: 
        :param persistence: 
        :param pod_security_context: 

        :schema: MysqlPrimary
        '''
        if isinstance(container_security_context, dict):
            container_security_context = MysqlPrimaryContainerSecurityContext(**container_security_context)
        if isinstance(persistence, dict):
            persistence = MysqlPrimaryPersistence(**persistence)
        if isinstance(pod_security_context, dict):
            pod_security_context = MysqlPrimaryPodSecurityContext(**pod_security_context)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5f80f16db85307f6e2dc2fd18749079a45e96857945ee617d44938b1e1fa49dd)
            check_type(argname=\\"argument additional_values\\", value=additional_values, expected_type=type_hints[\\"additional_values\\"])
            check_type(argname=\\"argument container_security_context\\", value=container_security_context, expected_type=type_hints[\\"container_security_context\\"])
            check_type(argname=\\"argument persistence\\", value=persistence, expected_type=type_hints[\\"persistence\\"])
            check_type(argname=\\"argument pod_security_context\\", value=pod_security_context, expected_type=type_hints[\\"pod_security_context\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if additional_values is not None:
            self._values[\\"additional_values\\"] = additional_values
        if container_security_context is not None:
            self._values[\\"container_security_context\\"] = container_security_context
        if persistence is not None:
            self._values[\\"persistence\\"] = persistence
        if pod_security_context is not None:
            self._values[\\"pod_security_context\\"] = pod_security_context

    @builtins.property
    def additional_values(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''Values that are not available in values.schema.json will not be code generated. You can add such values to this property.

        :schema: MysqlPrimary#additionalValues
        '''
        result = self._values.get(\\"additional_values\\")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def container_security_context(
        self,
    ) -> typing.Optional[\\"MysqlPrimaryContainerSecurityContext\\"]:
        '''
        :schema: MysqlPrimary#containerSecurityContext
        '''
        result = self._values.get(\\"container_security_context\\")
        return typing.cast(typing.Optional[\\"MysqlPrimaryContainerSecurityContext\\"], result)

    @builtins.property
    def persistence(self) -> typing.Optional[\\"MysqlPrimaryPersistence\\"]:
        '''
        :schema: MysqlPrimary#persistence
        '''
        result = self._values.get(\\"persistence\\")
        return typing.cast(typing.Optional[\\"MysqlPrimaryPersistence\\"], result)

    @builtins.property
    def pod_security_context(self) -> typing.Optional[\\"MysqlPrimaryPodSecurityContext\\"]:
        '''
        :schema: MysqlPrimary#podSecurityContext
        '''
        result = self._values.get(\\"pod_security_context\\")
        return typing.cast(typing.Optional[\\"MysqlPrimaryPodSecurityContext\\"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"MysqlPrimary(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type=\\"mysql.MysqlPrimaryContainerSecurityContext\\",
    jsii_struct_bases=[],
    name_mapping={
        \\"additional_values\\": \\"additionalValues\\",
        \\"enabled\\": \\"enabled\\",
        \\"run_as_user\\": \\"runAsUser\\",
    },
)
class MysqlPrimaryContainerSecurityContext:
    def __init__(
        self,
        *,
        additional_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        enabled: typing.Optional[builtins.bool] = None,
        run_as_user: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param additional_values: Values that are not available in values.schema.json will not be code generated. You can add such values to this property.
        :param enabled: 
        :param run_as_user: 

        :schema: MysqlPrimaryContainerSecurityContext
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b6c44d7f91b4cf3cb542cb1506165f060a9a15243f09931b735b74af15eaf7ae)
            check_type(argname=\\"argument additional_values\\", value=additional_values, expected_type=type_hints[\\"additional_values\\"])
            check_type(argname=\\"argument enabled\\", value=enabled, expected_type=type_hints[\\"enabled\\"])
            check_type(argname=\\"argument run_as_user\\", value=run_as_user, expected_type=type_hints[\\"run_as_user\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if additional_values is not None:
            self._values[\\"additional_values\\"] = additional_values
        if enabled is not None:
            self._values[\\"enabled\\"] = enabled
        if run_as_user is not None:
            self._values[\\"run_as_user\\"] = run_as_user

    @builtins.property
    def additional_values(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''Values that are not available in values.schema.json will not be code generated. You can add such values to this property.

        :schema: MysqlPrimaryContainerSecurityContext#additionalValues
        '''
        result = self._values.get(\\"additional_values\\")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def enabled(self) -> typing.Optional[builtins.bool]:
        '''
        :schema: MysqlPrimaryContainerSecurityContext#enabled
        '''
        result = self._values.get(\\"enabled\\")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def run_as_user(self) -> typing.Optional[jsii.Number]:
        '''
        :schema: MysqlPrimaryContainerSecurityContext#runAsUser
        '''
        result = self._values.get(\\"run_as_user\\")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"MysqlPrimaryContainerSecurityContext(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type=\\"mysql.MysqlPrimaryPersistence\\",
    jsii_struct_bases=[],
    name_mapping={
        \\"additional_values\\": \\"additionalValues\\",
        \\"enabled\\": \\"enabled\\",
        \\"size\\": \\"size\\",
    },
)
class MysqlPrimaryPersistence:
    def __init__(
        self,
        *,
        additional_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        enabled: typing.Optional[builtins.bool] = None,
        size: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param additional_values: Values that are not available in values.schema.json will not be code generated. You can add such values to this property.
        :param enabled: 
        :param size: 

        :schema: MysqlPrimaryPersistence
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__da573ccf5d6dca82a8d1cb770a6c85bd0dd98f4b5fe00a7260e815a7140dc9ba)
            check_type(argname=\\"argument additional_values\\", value=additional_values, expected_type=type_hints[\\"additional_values\\"])
            check_type(argname=\\"argument enabled\\", value=enabled, expected_type=type_hints[\\"enabled\\"])
            check_type(argname=\\"argument size\\", value=size, expected_type=type_hints[\\"size\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if additional_values is not None:
            self._values[\\"additional_values\\"] = additional_values
        if enabled is not None:
            self._values[\\"enabled\\"] = enabled
        if size is not None:
            self._values[\\"size\\"] = size

    @builtins.property
    def additional_values(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''Values that are not available in values.schema.json will not be code generated. You can add such values to this property.

        :schema: MysqlPrimaryPersistence#additionalValues
        '''
        result = self._values.get(\\"additional_values\\")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def enabled(self) -> typing.Optional[builtins.bool]:
        '''
        :schema: MysqlPrimaryPersistence#enabled
        '''
        result = self._values.get(\\"enabled\\")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def size(self) -> typing.Optional[builtins.str]:
        '''
        :schema: MysqlPrimaryPersistence#size
        '''
        result = self._values.get(\\"size\\")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"MysqlPrimaryPersistence(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type=\\"mysql.MysqlPrimaryPodSecurityContext\\",
    jsii_struct_bases=[],
    name_mapping={
        \\"additional_values\\": \\"additionalValues\\",
        \\"enabled\\": \\"enabled\\",
        \\"fs_group\\": \\"fsGroup\\",
    },
)
class MysqlPrimaryPodSecurityContext:
    def __init__(
        self,
        *,
        additional_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        enabled: typing.Optional[builtins.bool] = None,
        fs_group: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param additional_values: Values that are not available in values.schema.json will not be code generated. You can add such values to this property.
        :param enabled: 
        :param fs_group: 

        :schema: MysqlPrimaryPodSecurityContext
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f093d2c1e555d5d67dfb226a625b4abd2741a6b3333a3f12627a45d66a375c7c)
            check_type(argname=\\"argument additional_values\\", value=additional_values, expected_type=type_hints[\\"additional_values\\"])
            check_type(argname=\\"argument enabled\\", value=enabled, expected_type=type_hints[\\"enabled\\"])
            check_type(argname=\\"argument fs_group\\", value=fs_group, expected_type=type_hints[\\"fs_group\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if additional_values is not None:
            self._values[\\"additional_values\\"] = additional_values
        if enabled is not None:
            self._values[\\"enabled\\"] = enabled
        if fs_group is not None:
            self._values[\\"fs_group\\"] = fs_group

    @builtins.property
    def additional_values(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''Values that are not available in values.schema.json will not be code generated. You can add such values to this property.

        :schema: MysqlPrimaryPodSecurityContext#additionalValues
        '''
        result = self._values.get(\\"additional_values\\")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def enabled(self) -> typing.Optional[builtins.bool]:
        '''
        :schema: MysqlPrimaryPodSecurityContext#enabled
        '''
        result = self._values.get(\\"enabled\\")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def fs_group(self) -> typing.Optional[jsii.Number]:
        '''
        :schema: MysqlPrimaryPodSecurityContext#fsGroup
        '''
        result = self._values.get(\\"fs_group\\")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"MysqlPrimaryPodSecurityContext(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type=\\"mysql.MysqlProps\\",
    jsii_struct_bases=[],
    name_mapping={
        \\"helm_executable\\": \\"helmExecutable\\",
        \\"helm_flags\\": \\"helmFlags\\",
        \\"namespace\\": \\"namespace\\",
        \\"release_name\\": \\"releaseName\\",
        \\"values\\": \\"values\\",
    },
)
class MysqlProps:
    def __init__(
        self,
        *,
        helm_executable: typing.Optional[builtins.str] = None,
        helm_flags: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace: typing.Optional[builtins.str] = None,
        release_name: typing.Optional[builtins.str] = None,
        values: typing.Optional[typing.Union[\\"MysqlValues\\", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param helm_executable: -
        :param helm_flags: -
        :param namespace: -
        :param release_name: -
        :param values: -
        '''
        if isinstance(values, dict):
            values = MysqlValues(**values)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e0f01c3bcbff3f33dcd5e42ea1dca1754a4ffa560d4ed4393b91bf8167da3e71)
            check_type(argname=\\"argument helm_executable\\", value=helm_executable, expected_type=type_hints[\\"helm_executable\\"])
            check_type(argname=\\"argument helm_flags\\", value=helm_flags, expected_type=type_hints[\\"helm_flags\\"])
            check_type(argname=\\"argument namespace\\", value=namespace, expected_type=type_hints[\\"namespace\\"])
            check_type(argname=\\"argument release_name\\", value=release_name, expected_type=type_hints[\\"release_name\\"])
            check_type(argname=\\"argument values\\", value=values, expected_type=type_hints[\\"values\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if helm_executable is not None:
            self._values[\\"helm_executable\\"] = helm_executable
        if helm_flags is not None:
            self._values[\\"helm_flags\\"] = helm_flags
        if namespace is not None:
            self._values[\\"namespace\\"] = namespace
        if release_name is not None:
            self._values[\\"release_name\\"] = release_name
        if values is not None:
            self._values[\\"values\\"] = values

    @builtins.property
    def helm_executable(self) -> typing.Optional[builtins.str]:
        result = self._values.get(\\"helm_executable\\")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def helm_flags(self) -> typing.Optional[typing.List[builtins.str]]:
        result = self._values.get(\\"helm_flags\\")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        result = self._values.get(\\"namespace\\")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def release_name(self) -> typing.Optional[builtins.str]:
        result = self._values.get(\\"release_name\\")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def values(self) -> typing.Optional[\\"MysqlValues\\"]:
        result = self._values.get(\\"values\\")
        return typing.cast(typing.Optional[\\"MysqlValues\\"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"MysqlProps(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type=\\"mysql.MysqlSecondary\\",
    jsii_struct_bases=[],
    name_mapping={
        \\"additional_values\\": \\"additionalValues\\",
        \\"container_security_context\\": \\"containerSecurityContext\\",
        \\"persistence\\": \\"persistence\\",
        \\"pod_security_context\\": \\"podSecurityContext\\",
    },
)
class MysqlSecondary:
    def __init__(
        self,
        *,
        additional_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        container_security_context: typing.Optional[typing.Union[\\"MysqlSecondaryContainerSecurityContext\\", typing.Dict[builtins.str, typing.Any]]] = None,
        persistence: typing.Optional[typing.Union[\\"MysqlSecondaryPersistence\\", typing.Dict[builtins.str, typing.Any]]] = None,
        pod_security_context: typing.Optional[typing.Union[\\"MysqlSecondaryPodSecurityContext\\", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param additional_values: Values that are not available in values.schema.json will not be code generated. You can add such values to this property.
        :param container_security_context: 
        :param persistence: 
        :param pod_security_context: 

        :schema: MysqlSecondary
        '''
        if isinstance(container_security_context, dict):
            container_security_context = MysqlSecondaryContainerSecurityContext(**container_security_context)
        if isinstance(persistence, dict):
            persistence = MysqlSecondaryPersistence(**persistence)
        if isinstance(pod_security_context, dict):
            pod_security_context = MysqlSecondaryPodSecurityContext(**pod_security_context)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9f5e9436f8b23b1168f49948e6f47f206871fa357437067fe13eb80a1e4844f2)
            check_type(argname=\\"argument additional_values\\", value=additional_values, expected_type=type_hints[\\"additional_values\\"])
            check_type(argname=\\"argument container_security_context\\", value=container_security_context, expected_type=type_hints[\\"container_security_context\\"])
            check_type(argname=\\"argument persistence\\", value=persistence, expected_type=type_hints[\\"persistence\\"])
            check_type(argname=\\"argument pod_security_context\\", value=pod_security_context, expected_type=type_hints[\\"pod_security_context\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if additional_values is not None:
            self._values[\\"additional_values\\"] = additional_values
        if container_security_context is not None:
            self._values[\\"container_security_context\\"] = container_security_context
        if persistence is not None:
            self._values[\\"persistence\\"] = persistence
        if pod_security_context is not None:
            self._values[\\"pod_security_context\\"] = pod_security_context

    @builtins.property
    def additional_values(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''Values that are not available in values.schema.json will not be code generated. You can add such values to this property.

        :schema: MysqlSecondary#additionalValues
        '''
        result = self._values.get(\\"additional_values\\")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def container_security_context(
        self,
    ) -> typing.Optional[\\"MysqlSecondaryContainerSecurityContext\\"]:
        '''
        :schema: MysqlSecondary#containerSecurityContext
        '''
        result = self._values.get(\\"container_security_context\\")
        return typing.cast(typing.Optional[\\"MysqlSecondaryContainerSecurityContext\\"], result)

    @builtins.property
    def persistence(self) -> typing.Optional[\\"MysqlSecondaryPersistence\\"]:
        '''
        :schema: MysqlSecondary#persistence
        '''
        result = self._values.get(\\"persistence\\")
        return typing.cast(typing.Optional[\\"MysqlSecondaryPersistence\\"], result)

    @builtins.property
    def pod_security_context(
        self,
    ) -> typing.Optional[\\"MysqlSecondaryPodSecurityContext\\"]:
        '''
        :schema: MysqlSecondary#podSecurityContext
        '''
        result = self._values.get(\\"pod_security_context\\")
        return typing.cast(typing.Optional[\\"MysqlSecondaryPodSecurityContext\\"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"MysqlSecondary(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type=\\"mysql.MysqlSecondaryContainerSecurityContext\\",
    jsii_struct_bases=[],
    name_mapping={
        \\"additional_values\\": \\"additionalValues\\",
        \\"enabled\\": \\"enabled\\",
        \\"run_as_user\\": \\"runAsUser\\",
    },
)
class MysqlSecondaryContainerSecurityContext:
    def __init__(
        self,
        *,
        additional_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        enabled: typing.Optional[builtins.bool] = None,
        run_as_user: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param additional_values: Values that are not available in values.schema.json will not be code generated. You can add such values to this property.
        :param enabled: 
        :param run_as_user: 

        :schema: MysqlSecondaryContainerSecurityContext
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1ae0b9a8b2ed30dd59da81691df3e07509c48d79c4bae3cf246ab40221c987b1)
            check_type(argname=\\"argument additional_values\\", value=additional_values, expected_type=type_hints[\\"additional_values\\"])
            check_type(argname=\\"argument enabled\\", value=enabled, expected_type=type_hints[\\"enabled\\"])
            check_type(argname=\\"argument run_as_user\\", value=run_as_user, expected_type=type_hints[\\"run_as_user\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if additional_values is not None:
            self._values[\\"additional_values\\"] = additional_values
        if enabled is not None:
            self._values[\\"enabled\\"] = enabled
        if run_as_user is not None:
            self._values[\\"run_as_user\\"] = run_as_user

    @builtins.property
    def additional_values(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''Values that are not available in values.schema.json will not be code generated. You can add such values to this property.

        :schema: MysqlSecondaryContainerSecurityContext#additionalValues
        '''
        result = self._values.get(\\"additional_values\\")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def enabled(self) -> typing.Optional[builtins.bool]:
        '''
        :schema: MysqlSecondaryContainerSecurityContext#enabled
        '''
        result = self._values.get(\\"enabled\\")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def run_as_user(self) -> typing.Optional[jsii.Number]:
        '''
        :schema: MysqlSecondaryContainerSecurityContext#runAsUser
        '''
        result = self._values.get(\\"run_as_user\\")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"MysqlSecondaryContainerSecurityContext(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type=\\"mysql.MysqlSecondaryPersistence\\",
    jsii_struct_bases=[],
    name_mapping={
        \\"additional_values\\": \\"additionalValues\\",
        \\"enabled\\": \\"enabled\\",
        \\"size\\": \\"size\\",
    },
)
class MysqlSecondaryPersistence:
    def __init__(
        self,
        *,
        additional_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        enabled: typing.Optional[builtins.bool] = None,
        size: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param additional_values: Values that are not available in values.schema.json will not be code generated. You can add such values to this property.
        :param enabled: 
        :param size: 

        :schema: MysqlSecondaryPersistence
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__948c5c8f94b41fa54e53ae6a34ae87281865e016dcca8ad5308b1666738cbd56)
            check_type(argname=\\"argument additional_values\\", value=additional_values, expected_type=type_hints[\\"additional_values\\"])
            check_type(argname=\\"argument enabled\\", value=enabled, expected_type=type_hints[\\"enabled\\"])
            check_type(argname=\\"argument size\\", value=size, expected_type=type_hints[\\"size\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if additional_values is not None:
            self._values[\\"additional_values\\"] = additional_values
        if enabled is not None:
            self._values[\\"enabled\\"] = enabled
        if size is not None:
            self._values[\\"size\\"] = size

    @builtins.property
    def additional_values(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''Values that are not available in values.schema.json will not be code generated. You can add such values to this property.

        :schema: MysqlSecondaryPersistence#additionalValues
        '''
        result = self._values.get(\\"additional_values\\")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def enabled(self) -> typing.Optional[builtins.bool]:
        '''
        :schema: MysqlSecondaryPersistence#enabled
        '''
        result = self._values.get(\\"enabled\\")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def size(self) -> typing.Optional[builtins.str]:
        '''
        :schema: MysqlSecondaryPersistence#size
        '''
        result = self._values.get(\\"size\\")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"MysqlSecondaryPersistence(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type=\\"mysql.MysqlSecondaryPodSecurityContext\\",
    jsii_struct_bases=[],
    name_mapping={
        \\"additional_values\\": \\"additionalValues\\",
        \\"enabled\\": \\"enabled\\",
        \\"fs_group\\": \\"fsGroup\\",
    },
)
class MysqlSecondaryPodSecurityContext:
    def __init__(
        self,
        *,
        additional_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        enabled: typing.Optional[builtins.bool] = None,
        fs_group: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param additional_values: Values that are not available in values.schema.json will not be code generated. You can add such values to this property.
        :param enabled: 
        :param fs_group: 

        :schema: MysqlSecondaryPodSecurityContext
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c3d21a01f61c5c4594bfd80de49afce454aa452afa8cc380cf0792cf29872ce7)
            check_type(argname=\\"argument additional_values\\", value=additional_values, expected_type=type_hints[\\"additional_values\\"])
            check_type(argname=\\"argument enabled\\", value=enabled, expected_type=type_hints[\\"enabled\\"])
            check_type(argname=\\"argument fs_group\\", value=fs_group, expected_type=type_hints[\\"fs_group\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if additional_values is not None:
            self._values[\\"additional_values\\"] = additional_values
        if enabled is not None:
            self._values[\\"enabled\\"] = enabled
        if fs_group is not None:
            self._values[\\"fs_group\\"] = fs_group

    @builtins.property
    def additional_values(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''Values that are not available in values.schema.json will not be code generated. You can add such values to this property.

        :schema: MysqlSecondaryPodSecurityContext#additionalValues
        '''
        result = self._values.get(\\"additional_values\\")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def enabled(self) -> typing.Optional[builtins.bool]:
        '''
        :schema: MysqlSecondaryPodSecurityContext#enabled
        '''
        result = self._values.get(\\"enabled\\")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def fs_group(self) -> typing.Optional[jsii.Number]:
        '''
        :schema: MysqlSecondaryPodSecurityContext#fsGroup
        '''
        result = self._values.get(\\"fs_group\\")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"MysqlSecondaryPodSecurityContext(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type=\\"mysql.MysqlValues\\",
    jsii_struct_bases=[],
    name_mapping={
        \\"additional_values\\": \\"additionalValues\\",
        \\"architecture\\": \\"architecture\\",
        \\"auth\\": \\"auth\\",
        \\"common\\": \\"common\\",
        \\"global_\\": \\"global\\",
        \\"primary\\": \\"primary\\",
        \\"secondary\\": \\"secondary\\",
    },
)
class MysqlValues:
    def __init__(
        self,
        *,
        additional_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        architecture: typing.Optional[MysqlArchitecture] = None,
        auth: typing.Optional[typing.Union[MysqlAuth, typing.Dict[builtins.str, typing.Any]]] = None,
        common: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        global_: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        primary: typing.Optional[typing.Union[MysqlPrimary, typing.Dict[builtins.str, typing.Any]]] = None,
        secondary: typing.Optional[typing.Union[MysqlSecondary, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param additional_values: Values that are not available in values.schema.json will not be code generated. You can add such values to this property.
        :param architecture: Allowed values: \`\`standalone\`\` or \`\`replication\`\`.
        :param auth: 
        :param common: 
        :param global_: 
        :param primary: 
        :param secondary: 

        :schema: mysql
        '''
        if isinstance(auth, dict):
            auth = MysqlAuth(**auth)
        if isinstance(primary, dict):
            primary = MysqlPrimary(**primary)
        if isinstance(secondary, dict):
            secondary = MysqlSecondary(**secondary)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ba4b7249d1a1862400c9b19cff8ae48324c2ce9cf5eddeb6ee91753a02247696)
            check_type(argname=\\"argument additional_values\\", value=additional_values, expected_type=type_hints[\\"additional_values\\"])
            check_type(argname=\\"argument architecture\\", value=architecture, expected_type=type_hints[\\"architecture\\"])
            check_type(argname=\\"argument auth\\", value=auth, expected_type=type_hints[\\"auth\\"])
            check_type(argname=\\"argument common\\", value=common, expected_type=type_hints[\\"common\\"])
            check_type(argname=\\"argument global_\\", value=global_, expected_type=type_hints[\\"global_\\"])
            check_type(argname=\\"argument primary\\", value=primary, expected_type=type_hints[\\"primary\\"])
            check_type(argname=\\"argument secondary\\", value=secondary, expected_type=type_hints[\\"secondary\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if additional_values is not None:
            self._values[\\"additional_values\\"] = additional_values
        if architecture is not None:
            self._values[\\"architecture\\"] = architecture
        if auth is not None:
            self._values[\\"auth\\"] = auth
        if common is not None:
            self._values[\\"common\\"] = common
        if global_ is not None:
            self._values[\\"global_\\"] = global_
        if primary is not None:
            self._values[\\"primary\\"] = primary
        if secondary is not None:
            self._values[\\"secondary\\"] = secondary

    @builtins.property
    def additional_values(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''Values that are not available in values.schema.json will not be code generated. You can add such values to this property.

        :schema: mysql#additionalValues
        '''
        result = self._values.get(\\"additional_values\\")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def architecture(self) -> typing.Optional[MysqlArchitecture]:
        '''Allowed values: \`\`standalone\`\` or \`\`replication\`\`.

        :schema: mysql#architecture
        '''
        result = self._values.get(\\"architecture\\")
        return typing.cast(typing.Optional[MysqlArchitecture], result)

    @builtins.property
    def auth(self) -> typing.Optional[MysqlAuth]:
        '''
        :schema: mysql#auth
        '''
        result = self._values.get(\\"auth\\")
        return typing.cast(typing.Optional[MysqlAuth], result)

    @builtins.property
    def common(self) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''
        :schema: mysql#common
        '''
        result = self._values.get(\\"common\\")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def global_(self) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''
        :schema: mysql#global
        '''
        result = self._values.get(\\"global_\\")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def primary(self) -> typing.Optional[MysqlPrimary]:
        '''
        :schema: mysql#primary
        '''
        result = self._values.get(\\"primary\\")
        return typing.cast(typing.Optional[MysqlPrimary], result)

    @builtins.property
    def secondary(self) -> typing.Optional[MysqlSecondary]:
        '''
        :schema: mysql#secondary
        '''
        result = self._values.get(\\"secondary\\")
        return typing.cast(typing.Optional[MysqlSecondary], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"MysqlValues(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


__all__ = [
    \\"Mysql\\",
    \\"MysqlArchitecture\\",
    \\"MysqlAuth\\",
    \\"MysqlPrimary\\",
    \\"MysqlPrimaryContainerSecurityContext\\",
    \\"MysqlPrimaryPersistence\\",
    \\"MysqlPrimaryPodSecurityContext\\",
    \\"MysqlProps\\",
    \\"MysqlSecondary\\",
    \\"MysqlSecondaryContainerSecurityContext\\",
    \\"MysqlSecondaryPersistence\\",
    \\"MysqlSecondaryPodSecurityContext\\",
    \\"MysqlValues\\",
]

publication.publish()

def _typecheckingstub__95a811b01af67eee2d8e2ae24fcefa9fa2ac995a1f9685f3e921af5330ef82ff(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    helm_executable: typing.Optional[builtins.str] = None,
    helm_flags: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespace: typing.Optional[builtins.str] = None,
    release_name: typing.Optional[builtins.str] = None,
    values: typing.Optional[typing.Union[MysqlValues, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__ee06bc5fa81868398bad26c41946af017c8765bcca5abe66e5d88d360a20e315(
    *,
    password: builtins.str,
    username: builtins.str,
    additional_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    create_database: typing.Optional[builtins.bool] = None,
    database: typing.Optional[builtins.str] = None,
    replication_password: typing.Optional[builtins.str] = None,
    replication_user: typing.Optional[builtins.str] = None,
    root_password: typing.Optional[builtins.str] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__5f80f16db85307f6e2dc2fd18749079a45e96857945ee617d44938b1e1fa49dd(
    *,
    additional_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    container_security_context: typing.Optional[typing.Union[MysqlPrimaryContainerSecurityContext, typing.Dict[builtins.str, typing.Any]]] = None,
    persistence: typing.Optional[typing.Union[MysqlPrimaryPersistence, typing.Dict[builtins.str, typing.Any]]] = None,
    pod_security_context: typing.Optional[typing.Union[MysqlPrimaryPodSecurityContext, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__b6c44d7f91b4cf3cb542cb1506165f060a9a15243f09931b735b74af15eaf7ae(
    *,
    additional_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    enabled: typing.Optional[builtins.bool] = None,
    run_as_user: typing.Optional[jsii.Number] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__da573ccf5d6dca82a8d1cb770a6c85bd0dd98f4b5fe00a7260e815a7140dc9ba(
    *,
    additional_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    enabled: typing.Optional[builtins.bool] = None,
    size: typing.Optional[builtins.str] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__f093d2c1e555d5d67dfb226a625b4abd2741a6b3333a3f12627a45d66a375c7c(
    *,
    additional_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    enabled: typing.Optional[builtins.bool] = None,
    fs_group: typing.Optional[jsii.Number] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__e0f01c3bcbff3f33dcd5e42ea1dca1754a4ffa560d4ed4393b91bf8167da3e71(
    *,
    helm_executable: typing.Optional[builtins.str] = None,
    helm_flags: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespace: typing.Optional[builtins.str] = None,
    release_name: typing.Optional[builtins.str] = None,
    values: typing.Optional[typing.Union[MysqlValues, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__9f5e9436f8b23b1168f49948e6f47f206871fa357437067fe13eb80a1e4844f2(
    *,
    additional_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    container_security_context: typing.Optional[typing.Union[MysqlSecondaryContainerSecurityContext, typing.Dict[builtins.str, typing.Any]]] = None,
    persistence: typing.Optional[typing.Union[MysqlSecondaryPersistence, typing.Dict[builtins.str, typing.Any]]] = None,
    pod_security_context: typing.Optional[typing.Union[MysqlSecondaryPodSecurityContext, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__1ae0b9a8b2ed30dd59da81691df3e07509c48d79c4bae3cf246ab40221c987b1(
    *,
    additional_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    enabled: typing.Optional[builtins.bool] = None,
    run_as_user: typing.Optional[jsii.Number] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__948c5c8f94b41fa54e53ae6a34ae87281865e016dcca8ad5308b1666738cbd56(
    *,
    additional_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    enabled: typing.Optional[builtins.bool] = None,
    size: typing.Optional[builtins.str] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__c3d21a01f61c5c4594bfd80de49afce454aa452afa8cc380cf0792cf29872ce7(
    *,
    additional_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    enabled: typing.Optional[builtins.bool] = None,
    fs_group: typing.Optional[jsii.Number] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__ba4b7249d1a1862400c9b19cff8ae48324c2ce9cf5eddeb6ee91753a02247696(
    *,
    additional_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    architecture: typing.Optional[MysqlArchitecture] = None,
    auth: typing.Optional[typing.Union[MysqlAuth, typing.Dict[builtins.str, typing.Any]]] = None,
    common: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    global_: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    primary: typing.Optional[typing.Union[MysqlPrimary, typing.Dict[builtins.str, typing.Any]]] = None,
    secondary: typing.Optional[typing.Union[MysqlSecondary, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass
",
  "mysql/_jsii/__init__.py": "from pkgutil import extend_path
__path__ = extend_path(__path__, __name__)

import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

import typeguard
from importlib.metadata import version as _metadata_package_version
TYPEGUARD_MAJOR_VERSION = int(_metadata_package_version('typeguard').split('.')[0])

def check_type(argname: str, value: object, expected_type: typing.Any) -> typing.Any:
    if TYPEGUARD_MAJOR_VERSION <= 2:
        return typeguard.check_type(argname=argname, value=value, expected_type=expected_type) # type:ignore
    else:
        if isinstance(value, jsii._reference_map.InterfaceDynamicProxy): # pyright: ignore [reportAttributeAccessIssue]
           pass
        else:
            if TYPEGUARD_MAJOR_VERSION == 3:
                typeguard.config.collection_check_strategy = typeguard.CollectionCheckStrategy.ALL_ITEMS # type:ignore
                typeguard.check_type(value=value, expected_type=expected_type) # type:ignore
            else:
                typeguard.check_type(value=value, expected_type=expected_type, collection_check_strategy=typeguard.CollectionCheckStrategy.ALL_ITEMS) # type:ignore

import cdk8s._jsii
import constructs._jsii

__jsii_assembly__ = jsii.JSIIAssembly.load(
    \\"mysql\\", \\"0.0.0\\", __name__[0:-6], \\"mysql@0.0.0.jsii.tgz\\"
)

__all__ = [
    \\"__jsii_assembly__\\",
]

publication.publish()
",
  "mysql/py.typed": "
",
}
`;

exports[`importing helm chart helm:https://charts.bitnami.com/bitnami/mysql@9.10.10 with typescript lanugage 1`] = `
Object {
  "author": Object {
    "name": "generated@generated.com",
    "roles": Array [
      "author",
    ],
  },
  "dependencies": "__omitted__",
  "dependencyClosure": Object {
    "cdk8s": Object {
      "targets": Object {
        "dotnet": Object {
          "namespace": "Org.Cdk8s",
          "packageId": "Org.Cdk8s",
        },
        "go": Object {
          "moduleName": "github.com/cdk8s-team/cdk8s-core-go",
        },
        "java": Object {
          "maven": Object {
            "artifactId": "cdk8s",
            "groupId": "org.cdk8s",
          },
          "package": "org.cdk8s",
        },
        "js": Object {
          "npm": "cdk8s",
        },
        "python": Object {
          "distName": "cdk8s",
          "module": "cdk8s",
        },
      },
    },
    "constructs": Object {
      "targets": Object {
        "dotnet": Object {
          "namespace": "Constructs",
          "packageId": "Constructs",
        },
        "go": Object {
          "moduleName": "github.com/aws/constructs-go",
        },
        "java": Object {
          "maven": Object {
            "artifactId": "constructs",
            "groupId": "software.constructs",
          },
          "package": "software.constructs",
        },
        "js": Object {
          "npm": "constructs",
        },
        "python": Object {
          "distName": "constructs",
          "module": "constructs",
        },
      },
    },
  },
  "description": "mysql",
  "fingerprint": "<fingerprint>",
  "homepage": "http://generated",
  "jsiiVersion": "__omitted__",
  "license": "UNLICENSED",
  "metadata": Object {
    "jsii": Object {
      "pacmak": Object {
        "hasDefaultInterfaces": true,
      },
    },
  },
  "name": "mysql",
  "repository": Object {
    "type": "git",
    "url": "http://generated",
  },
  "schema": "jsii/0.10.0",
  "targets": Object {
    "js": Object {
      "npm": "mysql",
    },
  },
  "types": Object {
    "mysql.Mysql": Object {
      "assembly": "mysql",
      "base": "constructs.Construct",
      "fqn": "mysql.Mysql",
      "initializer": Object {
        "locationInModule": Object {
          "filename": "mysql.ts",
          "line": 14,
        },
        "parameters": Array [
          Object {
            "name": "scope",
            "type": Object {
              "fqn": "constructs.Construct",
            },
          },
          Object {
            "name": "id",
            "type": Object {
              "primitive": "string",
            },
          },
          Object {
            "name": "props",
            "optional": true,
            "type": Object {
              "fqn": "mysql.MysqlProps",
            },
          },
        ],
      },
      "kind": "class",
      "locationInModule": Object {
        "filename": "mysql.ts",
        "line": 13,
      },
      "name": "Mysql",
      "symbolId": "mysql:Mysql",
    },
    "mysql.MysqlArchitecture": Object {
      "assembly": "mysql",
      "docs": Object {
        "custom": Object {
          "schema": "MysqlArchitecture",
        },
        "summary": "Allowed values: \`standalone\` or \`replication\`.",
      },
      "fqn": "mysql.MysqlArchitecture",
      "kind": "enum",
      "locationInModule": Object {
        "filename": "mysql.ts",
        "line": 113,
      },
      "members": Array [
        Object {
          "docs": Object {
            "summary": "standalone.",
          },
          "name": "STANDALONE",
        },
        Object {
          "docs": Object {
            "summary": "replication.",
          },
          "name": "REPLICATION",
        },
      ],
      "name": "MysqlArchitecture",
      "symbolId": "mysql:MysqlArchitecture",
    },
    "mysql.MysqlAuth": Object {
      "assembly": "mysql",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "MysqlAuth",
        },
      },
      "fqn": "mysql.MysqlAuth",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "mysql.ts",
        "line": 123,
      },
      "name": "MysqlAuth",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlAuth#password",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 145,
          },
          "name": "password",
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlAuth#username",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 140,
          },
          "name": "username",
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlAuth#additionalValues",
            },
            "summary": "Values that are not available in values.schema.json will not be code generated. You can add such values to this property.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 167,
          },
          "name": "additionalValues",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "any",
              },
              "kind": "map",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlAuth#createDatabase",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 160,
          },
          "name": "createDatabase",
          "optional": true,
          "type": Object {
            "primitive": "boolean",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlAuth#database",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 135,
          },
          "name": "database",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlAuth#replicationPassword",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 155,
          },
          "name": "replicationPassword",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlAuth#replicationUser",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 150,
          },
          "name": "replicationUser",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlAuth#rootPassword",
            },
            "default": "a random 10-character alphanumeric string if not set",
            "summary": "Defaults to a random 10-character alphanumeric string if not set.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 130,
          },
          "name": "rootPassword",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
      ],
      "symbolId": "mysql:MysqlAuth",
    },
    "mysql.MysqlPrimary": Object {
      "assembly": "mysql",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "MysqlPrimary",
        },
      },
      "fqn": "mysql.MysqlPrimary",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "mysql.ts",
        "line": 174,
      },
      "name": "MysqlPrimary",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlPrimary#additionalValues",
            },
            "summary": "Values that are not available in values.schema.json will not be code generated. You can add such values to this property.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 195,
          },
          "name": "additionalValues",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "any",
              },
              "kind": "map",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlPrimary#containerSecurityContext",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 183,
          },
          "name": "containerSecurityContext",
          "optional": true,
          "type": Object {
            "fqn": "mysql.MysqlPrimaryContainerSecurityContext",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlPrimary#persistence",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 188,
          },
          "name": "persistence",
          "optional": true,
          "type": Object {
            "fqn": "mysql.MysqlPrimaryPersistence",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlPrimary#podSecurityContext",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 178,
          },
          "name": "podSecurityContext",
          "optional": true,
          "type": Object {
            "fqn": "mysql.MysqlPrimaryPodSecurityContext",
          },
        },
      ],
      "symbolId": "mysql:MysqlPrimary",
    },
    "mysql.MysqlPrimaryContainerSecurityContext": Object {
      "assembly": "mysql",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "MysqlPrimaryContainerSecurityContext",
        },
      },
      "fqn": "mysql.MysqlPrimaryContainerSecurityContext",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "mysql.ts",
        "line": 253,
      },
      "name": "MysqlPrimaryContainerSecurityContext",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlPrimaryContainerSecurityContext#additionalValues",
            },
            "summary": "Values that are not available in values.schema.json will not be code generated. You can add such values to this property.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 269,
          },
          "name": "additionalValues",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "any",
              },
              "kind": "map",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlPrimaryContainerSecurityContext#enabled",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 257,
          },
          "name": "enabled",
          "optional": true,
          "type": Object {
            "primitive": "boolean",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlPrimaryContainerSecurityContext#runAsUser",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 262,
          },
          "name": "runAsUser",
          "optional": true,
          "type": Object {
            "primitive": "number",
          },
        },
      ],
      "symbolId": "mysql:MysqlPrimaryContainerSecurityContext",
    },
    "mysql.MysqlPrimaryPersistence": Object {
      "assembly": "mysql",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "MysqlPrimaryPersistence",
        },
      },
      "fqn": "mysql.MysqlPrimaryPersistence",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "mysql.ts",
        "line": 276,
      },
      "name": "MysqlPrimaryPersistence",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlPrimaryPersistence#additionalValues",
            },
            "summary": "Values that are not available in values.schema.json will not be code generated. You can add such values to this property.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 292,
          },
          "name": "additionalValues",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "any",
              },
              "kind": "map",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlPrimaryPersistence#enabled",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 280,
          },
          "name": "enabled",
          "optional": true,
          "type": Object {
            "primitive": "boolean",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlPrimaryPersistence#size",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 285,
          },
          "name": "size",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
      ],
      "symbolId": "mysql:MysqlPrimaryPersistence",
    },
    "mysql.MysqlPrimaryPodSecurityContext": Object {
      "assembly": "mysql",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "MysqlPrimaryPodSecurityContext",
        },
      },
      "fqn": "mysql.MysqlPrimaryPodSecurityContext",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "mysql.ts",
        "line": 230,
      },
      "name": "MysqlPrimaryPodSecurityContext",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlPrimaryPodSecurityContext#additionalValues",
            },
            "summary": "Values that are not available in values.schema.json will not be code generated. You can add such values to this property.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 246,
          },
          "name": "additionalValues",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "any",
              },
              "kind": "map",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlPrimaryPodSecurityContext#enabled",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 234,
          },
          "name": "enabled",
          "optional": true,
          "type": Object {
            "primitive": "boolean",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlPrimaryPodSecurityContext#fsGroup",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 239,
          },
          "name": "fsGroup",
          "optional": true,
          "type": Object {
            "primitive": "number",
          },
        },
      ],
      "symbolId": "mysql:MysqlPrimaryPodSecurityContext",
    },
    "mysql.MysqlProps": Object {
      "assembly": "mysql",
      "datatype": true,
      "fqn": "mysql.MysqlProps",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "mysql.ts",
        "line": 5,
      },
      "name": "MysqlProps",
      "properties": Array [
        Object {
          "abstract": true,
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 8,
          },
          "name": "helmExecutable",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 9,
          },
          "name": "helmFlags",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "string",
              },
              "kind": "array",
            },
          },
        },
        Object {
          "abstract": true,
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 6,
          },
          "name": "namespace",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 7,
          },
          "name": "releaseName",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 10,
          },
          "name": "values",
          "optional": true,
          "type": Object {
            "fqn": "mysql.MysqlValues",
          },
        },
      ],
      "symbolId": "mysql:MysqlProps",
    },
    "mysql.MysqlSecondary": Object {
      "assembly": "mysql",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "MysqlSecondary",
        },
      },
      "fqn": "mysql.MysqlSecondary",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "mysql.ts",
        "line": 202,
      },
      "name": "MysqlSecondary",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlSecondary#additionalValues",
            },
            "summary": "Values that are not available in values.schema.json will not be code generated. You can add such values to this property.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 223,
          },
          "name": "additionalValues",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "any",
              },
              "kind": "map",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlSecondary#containerSecurityContext",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 211,
          },
          "name": "containerSecurityContext",
          "optional": true,
          "type": Object {
            "fqn": "mysql.MysqlSecondaryContainerSecurityContext",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlSecondary#persistence",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 216,
          },
          "name": "persistence",
          "optional": true,
          "type": Object {
            "fqn": "mysql.MysqlSecondaryPersistence",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlSecondary#podSecurityContext",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 206,
          },
          "name": "podSecurityContext",
          "optional": true,
          "type": Object {
            "fqn": "mysql.MysqlSecondaryPodSecurityContext",
          },
        },
      ],
      "symbolId": "mysql:MysqlSecondary",
    },
    "mysql.MysqlSecondaryContainerSecurityContext": Object {
      "assembly": "mysql",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "MysqlSecondaryContainerSecurityContext",
        },
      },
      "fqn": "mysql.MysqlSecondaryContainerSecurityContext",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "mysql.ts",
        "line": 322,
      },
      "name": "MysqlSecondaryContainerSecurityContext",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlSecondaryContainerSecurityContext#additionalValues",
            },
            "summary": "Values that are not available in values.schema.json will not be code generated. You can add such values to this property.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 338,
          },
          "name": "additionalValues",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "any",
              },
              "kind": "map",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlSecondaryContainerSecurityContext#enabled",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 326,
          },
          "name": "enabled",
          "optional": true,
          "type": Object {
            "primitive": "boolean",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlSecondaryContainerSecurityContext#runAsUser",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 331,
          },
          "name": "runAsUser",
          "optional": true,
          "type": Object {
            "primitive": "number",
          },
        },
      ],
      "symbolId": "mysql:MysqlSecondaryContainerSecurityContext",
    },
    "mysql.MysqlSecondaryPersistence": Object {
      "assembly": "mysql",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "MysqlSecondaryPersistence",
        },
      },
      "fqn": "mysql.MysqlSecondaryPersistence",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "mysql.ts",
        "line": 345,
      },
      "name": "MysqlSecondaryPersistence",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlSecondaryPersistence#additionalValues",
            },
            "summary": "Values that are not available in values.schema.json will not be code generated. You can add such values to this property.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 361,
          },
          "name": "additionalValues",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "any",
              },
              "kind": "map",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlSecondaryPersistence#enabled",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 349,
          },
          "name": "enabled",
          "optional": true,
          "type": Object {
            "primitive": "boolean",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlSecondaryPersistence#size",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 354,
          },
          "name": "size",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
      ],
      "symbolId": "mysql:MysqlSecondaryPersistence",
    },
    "mysql.MysqlSecondaryPodSecurityContext": Object {
      "assembly": "mysql",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "MysqlSecondaryPodSecurityContext",
        },
      },
      "fqn": "mysql.MysqlSecondaryPodSecurityContext",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "mysql.ts",
        "line": 299,
      },
      "name": "MysqlSecondaryPodSecurityContext",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlSecondaryPodSecurityContext#additionalValues",
            },
            "summary": "Values that are not available in values.schema.json will not be code generated. You can add such values to this property.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 315,
          },
          "name": "additionalValues",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "any",
              },
              "kind": "map",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlSecondaryPodSecurityContext#enabled",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 303,
          },
          "name": "enabled",
          "optional": true,
          "type": Object {
            "primitive": "boolean",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlSecondaryPodSecurityContext#fsGroup",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 308,
          },
          "name": "fsGroup",
          "optional": true,
          "type": Object {
            "primitive": "number",
          },
        },
      ],
      "symbolId": "mysql:MysqlSecondaryPodSecurityContext",
    },
    "mysql.MysqlValues": Object {
      "assembly": "mysql",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "mysql",
        },
      },
      "fqn": "mysql.MysqlValues",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "mysql.ts",
        "line": 66,
      },
      "name": "MysqlValues",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "mysql#additionalValues",
            },
            "summary": "Values that are not available in values.schema.json will not be code generated. You can add such values to this property.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 104,
          },
          "name": "additionalValues",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "any",
              },
              "kind": "map",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "mysql#architecture",
            },
            "summary": "Allowed values: \`standalone\` or \`replication\`.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 72,
          },
          "name": "architecture",
          "optional": true,
          "type": Object {
            "fqn": "mysql.MysqlArchitecture",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "mysql#auth",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 77,
          },
          "name": "auth",
          "optional": true,
          "type": Object {
            "fqn": "mysql.MysqlAuth",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "mysql#common",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 92,
          },
          "name": "common",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "any",
              },
              "kind": "map",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "mysql#global",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 97,
          },
          "name": "global",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "any",
              },
              "kind": "map",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "mysql#primary",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 82,
          },
          "name": "primary",
          "optional": true,
          "type": Object {
            "fqn": "mysql.MysqlPrimary",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "mysql#secondary",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 87,
          },
          "name": "secondary",
          "optional": true,
          "type": Object {
            "fqn": "mysql.MysqlSecondary",
          },
        },
      ],
      "symbolId": "mysql:MysqlValues",
    },
  },
  "version": "0.0.0",
}
`;

exports[`importing helm chart helm:https://charts.bitnami.com/bitnami/mysql@9.10.10 with typescript lanugage 2`] = `
Object {
  "mysql.ts": "// generated by cdk8s
import { Helm, HelmProps } from 'cdk8s';
import { Construct } from 'constructs';

export interface MysqlProps {
  readonly namespace?: string;
  readonly releaseName?: string;
  readonly helmExecutable?: string;
  readonly helmFlags?: string[];
  readonly values?: MysqlValues;
}

export class Mysql extends Construct {
  public constructor(scope: Construct, id: string, props: MysqlProps = {}) {
    super(scope, id);
    let updatedProps = {};

    if (props.values) {
      const { additionalValues, ...valuesWithoutAdditionalValues } = props.values;
      updatedProps = {
        ...props,
        values: {
          ...this.flattenAdditionalValues(valuesWithoutAdditionalValues),
          ...additionalValues,
        },
      };
    }

    const finalProps: HelmProps = {
      chart: 'mysql',
      repo: 'https://charts.bitnami.com/bitnami',
      version: '9.10.10',
      ...(Object.keys(updatedProps).length !== 0 ? updatedProps : props),
    };

    new Helm(this, 'Helm', finalProps);
  }

  private flattenAdditionalValues(props: { [key: string]: any }): { [key: string]: any } {
    for (let prop in props) {
      if (Array.isArray(props[prop])) {
        props[prop].map((item: any) => {
          if (typeof item === 'object' && prop !== 'additionalValues') {
            return this.flattenAdditionalValues(item);
          }
          return item;
        });
      }
      else if (typeof props[prop] === 'object' && prop !== 'additionalValues') {
        props[prop] = this.flattenAdditionalValues(props[prop]);
      }
    }

    const { additionalValues, ...valuesWithoutAdditionalValues } = props;

    return {
      ...valuesWithoutAdditionalValues,
      ...additionalValues,
    };
  }
}

/**
 * @schema mysql
 */
export interface MysqlValues {
  /**
   * Allowed values: \`standalone\` or \`replication\`
   *
   * @schema mysql#architecture
   */
  readonly architecture?: MysqlArchitecture;

  /**
   * @schema mysql#auth
   */
  readonly auth?: MysqlAuth;

  /**
   * @schema mysql#primary
   */
  readonly primary?: MysqlPrimary;

  /**
   * @schema mysql#secondary
   */
  readonly secondary?: MysqlSecondary;

  /**
   * @schema mysql#common
   */
  readonly common?: { [key: string]: any };

  /**
   * @schema mysql#global
   */
  readonly global?: { [key: string]: any };

  /**
   * Values that are not available in values.schema.json will not be code generated. You can add such values to this property.
   *
   * @schema mysql#additionalValues
   */
  readonly additionalValues?: { [key: string]: any };

}

/**
 * Allowed values: \`standalone\` or \`replication\`
 *
 * @schema MysqlArchitecture
 */
export enum MysqlArchitecture {
  /** standalone */
  STANDALONE = \\"standalone\\",
  /** replication */
  REPLICATION = \\"replication\\",
}

/**
 * @schema MysqlAuth
 */
export interface MysqlAuth {
  /**
   * Defaults to a random 10-character alphanumeric string if not set
   *
   * @default a random 10-character alphanumeric string if not set
   * @schema MysqlAuth#rootPassword
   */
  readonly rootPassword?: string;

  /**
   * @schema MysqlAuth#database
   */
  readonly database?: string;

  /**
   * @schema MysqlAuth#username
   */
  readonly username: string;

  /**
   * @schema MysqlAuth#password
   */
  readonly password: string;

  /**
   * @schema MysqlAuth#replicationUser
   */
  readonly replicationUser?: string;

  /**
   * @schema MysqlAuth#replicationPassword
   */
  readonly replicationPassword?: string;

  /**
   * @schema MysqlAuth#createDatabase
   */
  readonly createDatabase?: boolean;

  /**
   * Values that are not available in values.schema.json will not be code generated. You can add such values to this property.
   *
   * @schema MysqlAuth#additionalValues
   */
  readonly additionalValues?: { [key: string]: any };

}

/**
 * @schema MysqlPrimary
 */
export interface MysqlPrimary {
  /**
   * @schema MysqlPrimary#podSecurityContext
   */
  readonly podSecurityContext?: MysqlPrimaryPodSecurityContext;

  /**
   * @schema MysqlPrimary#containerSecurityContext
   */
  readonly containerSecurityContext?: MysqlPrimaryContainerSecurityContext;

  /**
   * @schema MysqlPrimary#persistence
   */
  readonly persistence?: MysqlPrimaryPersistence;

  /**
   * Values that are not available in values.schema.json will not be code generated. You can add such values to this property.
   *
   * @schema MysqlPrimary#additionalValues
   */
  readonly additionalValues?: { [key: string]: any };

}

/**
 * @schema MysqlSecondary
 */
export interface MysqlSecondary {
  /**
   * @schema MysqlSecondary#podSecurityContext
   */
  readonly podSecurityContext?: MysqlSecondaryPodSecurityContext;

  /**
   * @schema MysqlSecondary#containerSecurityContext
   */
  readonly containerSecurityContext?: MysqlSecondaryContainerSecurityContext;

  /**
   * @schema MysqlSecondary#persistence
   */
  readonly persistence?: MysqlSecondaryPersistence;

  /**
   * Values that are not available in values.schema.json will not be code generated. You can add such values to this property.
   *
   * @schema MysqlSecondary#additionalValues
   */
  readonly additionalValues?: { [key: string]: any };

}

/**
 * @schema MysqlPrimaryPodSecurityContext
 */
export interface MysqlPrimaryPodSecurityContext {
  /**
   * @schema MysqlPrimaryPodSecurityContext#enabled
   */
  readonly enabled?: boolean;

  /**
   * @schema MysqlPrimaryPodSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * Values that are not available in values.schema.json will not be code generated. You can add such values to this property.
   *
   * @schema MysqlPrimaryPodSecurityContext#additionalValues
   */
  readonly additionalValues?: { [key: string]: any };

}

/**
 * @schema MysqlPrimaryContainerSecurityContext
 */
export interface MysqlPrimaryContainerSecurityContext {
  /**
   * @schema MysqlPrimaryContainerSecurityContext#enabled
   */
  readonly enabled?: boolean;

  /**
   * @schema MysqlPrimaryContainerSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * Values that are not available in values.schema.json will not be code generated. You can add such values to this property.
   *
   * @schema MysqlPrimaryContainerSecurityContext#additionalValues
   */
  readonly additionalValues?: { [key: string]: any };

}

/**
 * @schema MysqlPrimaryPersistence
 */
export interface MysqlPrimaryPersistence {
  /**
   * @schema MysqlPrimaryPersistence#enabled
   */
  readonly enabled?: boolean;

  /**
   * @schema MysqlPrimaryPersistence#size
   */
  readonly size?: string;

  /**
   * Values that are not available in values.schema.json will not be code generated. You can add such values to this property.
   *
   * @schema MysqlPrimaryPersistence#additionalValues
   */
  readonly additionalValues?: { [key: string]: any };

}

/**
 * @schema MysqlSecondaryPodSecurityContext
 */
export interface MysqlSecondaryPodSecurityContext {
  /**
   * @schema MysqlSecondaryPodSecurityContext#enabled
   */
  readonly enabled?: boolean;

  /**
   * @schema MysqlSecondaryPodSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * Values that are not available in values.schema.json will not be code generated. You can add such values to this property.
   *
   * @schema MysqlSecondaryPodSecurityContext#additionalValues
   */
  readonly additionalValues?: { [key: string]: any };

}

/**
 * @schema MysqlSecondaryContainerSecurityContext
 */
export interface MysqlSecondaryContainerSecurityContext {
  /**
   * @schema MysqlSecondaryContainerSecurityContext#enabled
   */
  readonly enabled?: boolean;

  /**
   * @schema MysqlSecondaryContainerSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * Values that are not available in values.schema.json will not be code generated. You can add such values to this property.
   *
   * @schema MysqlSecondaryContainerSecurityContext#additionalValues
   */
  readonly additionalValues?: { [key: string]: any };

}

/**
 * @schema MysqlSecondaryPersistence
 */
export interface MysqlSecondaryPersistence {
  /**
   * @schema MysqlSecondaryPersistence#enabled
   */
  readonly enabled?: boolean;

  /**
   * @schema MysqlSecondaryPersistence#size
   */
  readonly size?: string;

  /**
   * Values that are not available in values.schema.json will not be code generated. You can add such values to this property.
   *
   * @schema MysqlSecondaryPersistence#additionalValues
   */
  readonly additionalValues?: { [key: string]: any };

}

",
}
`;

exports[`importing helm chart helm:https://grafana.github.io/helm-charts/loki@5.27.0 with python lanugage 1`] = `
Object {
  "author": Object {
    "name": "generated@generated.com",
    "roles": Array [
      "author",
    ],
  },
  "dependencies": "__omitted__",
  "dependencyClosure": Object {
    "cdk8s": Object {
      "targets": Object {
        "dotnet": Object {
          "namespace": "Org.Cdk8s",
          "packageId": "Org.Cdk8s",
        },
        "go": Object {
          "moduleName": "github.com/cdk8s-team/cdk8s-core-go",
        },
        "java": Object {
          "maven": Object {
            "artifactId": "cdk8s",
            "groupId": "org.cdk8s",
          },
          "package": "org.cdk8s",
        },
        "js": Object {
          "npm": "cdk8s",
        },
        "python": Object {
          "distName": "cdk8s",
          "module": "cdk8s",
        },
      },
    },
    "constructs": Object {
      "targets": Object {
        "dotnet": Object {
          "namespace": "Constructs",
          "packageId": "Constructs",
        },
        "go": Object {
          "moduleName": "github.com/aws/constructs-go",
        },
        "java": Object {
          "maven": Object {
            "artifactId": "constructs",
            "groupId": "software.constructs",
          },
          "package": "software.constructs",
        },
        "js": Object {
          "npm": "constructs",
        },
        "python": Object {
          "distName": "constructs",
          "module": "constructs",
        },
      },
    },
  },
  "description": "loki",
  "fingerprint": "<fingerprint>",
  "homepage": "http://generated",
  "jsiiVersion": "__omitted__",
  "license": "UNLICENSED",
  "metadata": Object {
    "jsii": Object {
      "pacmak": Object {
        "hasDefaultInterfaces": true,
      },
    },
  },
  "name": "loki",
  "repository": Object {
    "type": "git",
    "url": "http://generated",
  },
  "schema": "jsii/0.10.0",
  "targets": Object {
    "js": Object {
      "npm": "loki",
    },
    "python": Object {
      "distName": "generated",
      "module": "loki",
    },
  },
  "types": Object {
    "loki.Loki": Object {
      "assembly": "loki",
      "base": "constructs.Construct",
      "fqn": "loki.Loki",
      "initializer": Object {
        "locationInModule": Object {
          "filename": "loki.ts",
          "line": 14,
        },
        "parameters": Array [
          Object {
            "name": "scope",
            "type": Object {
              "fqn": "constructs.Construct",
            },
          },
          Object {
            "name": "id",
            "type": Object {
              "primitive": "string",
            },
          },
          Object {
            "name": "props",
            "optional": true,
            "type": Object {
              "fqn": "loki.LokiProps",
            },
          },
        ],
      },
      "kind": "class",
      "locationInModule": Object {
        "filename": "loki.ts",
        "line": 13,
      },
      "name": "Loki",
      "symbolId": "loki:Loki",
    },
    "loki.LokiProps": Object {
      "assembly": "loki",
      "datatype": true,
      "fqn": "loki.LokiProps",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "loki.ts",
        "line": 5,
      },
      "name": "LokiProps",
      "properties": Array [
        Object {
          "abstract": true,
          "immutable": true,
          "locationInModule": Object {
            "filename": "loki.ts",
            "line": 8,
          },
          "name": "helmExecutable",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "immutable": true,
          "locationInModule": Object {
            "filename": "loki.ts",
            "line": 9,
          },
          "name": "helmFlags",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "string",
              },
              "kind": "array",
            },
          },
        },
        Object {
          "abstract": true,
          "immutable": true,
          "locationInModule": Object {
            "filename": "loki.ts",
            "line": 6,
          },
          "name": "namespace",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "immutable": true,
          "locationInModule": Object {
            "filename": "loki.ts",
            "line": 7,
          },
          "name": "releaseName",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "immutable": true,
          "locationInModule": Object {
            "filename": "loki.ts",
            "line": 10,
          },
          "name": "values",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "any",
              },
              "kind": "map",
            },
          },
        },
      ],
      "symbolId": "loki:LokiProps",
    },
  },
  "version": "0.0.0",
}
`;

exports[`importing helm chart helm:https://grafana.github.io/helm-charts/loki@5.27.0 with python lanugage 2`] = `
Object {
  "loki/__init__.py": "from pkgutil import extend_path
__path__ = extend_path(__path__, __name__)

import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

import typeguard
from importlib.metadata import version as _metadata_package_version
TYPEGUARD_MAJOR_VERSION = int(_metadata_package_version('typeguard').split('.')[0])

def check_type(argname: str, value: object, expected_type: typing.Any) -> typing.Any:
    if TYPEGUARD_MAJOR_VERSION <= 2:
        return typeguard.check_type(argname=argname, value=value, expected_type=expected_type) # type:ignore
    else:
        if isinstance(value, jsii._reference_map.InterfaceDynamicProxy): # pyright: ignore [reportAttributeAccessIssue]
           pass
        else:
            if TYPEGUARD_MAJOR_VERSION == 3:
                typeguard.config.collection_check_strategy = typeguard.CollectionCheckStrategy.ALL_ITEMS # type:ignore
                typeguard.check_type(value=value, expected_type=expected_type) # type:ignore
            else:
                typeguard.check_type(value=value, expected_type=expected_type, collection_check_strategy=typeguard.CollectionCheckStrategy.ALL_ITEMS) # type:ignore

from ._jsii import *

import constructs as _constructs_77d1e7e8


class Loki(
    _constructs_77d1e7e8.Construct,
    metaclass=jsii.JSIIMeta,
    jsii_type=\\"loki.Loki\\",
):
    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        helm_executable: typing.Optional[builtins.str] = None,
        helm_flags: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace: typing.Optional[builtins.str] = None,
        release_name: typing.Optional[builtins.str] = None,
        values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param helm_executable: -
        :param helm_flags: -
        :param namespace: -
        :param release_name: -
        :param values: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f1d23af9ace606bd925629648645169df04574e2a303e09d4fcaf42d666e0f62)
            check_type(argname=\\"argument scope\\", value=scope, expected_type=type_hints[\\"scope\\"])
            check_type(argname=\\"argument id\\", value=id, expected_type=type_hints[\\"id\\"])
        props = LokiProps(
            helm_executable=helm_executable,
            helm_flags=helm_flags,
            namespace=namespace,
            release_name=release_name,
            values=values,
        )

        jsii.create(self.__class__, self, [scope, id, props])


@jsii.data_type(
    jsii_type=\\"loki.LokiProps\\",
    jsii_struct_bases=[],
    name_mapping={
        \\"helm_executable\\": \\"helmExecutable\\",
        \\"helm_flags\\": \\"helmFlags\\",
        \\"namespace\\": \\"namespace\\",
        \\"release_name\\": \\"releaseName\\",
        \\"values\\": \\"values\\",
    },
)
class LokiProps:
    def __init__(
        self,
        *,
        helm_executable: typing.Optional[builtins.str] = None,
        helm_flags: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace: typing.Optional[builtins.str] = None,
        release_name: typing.Optional[builtins.str] = None,
        values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    ) -> None:
        '''
        :param helm_executable: -
        :param helm_flags: -
        :param namespace: -
        :param release_name: -
        :param values: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c8e7d6706b1656a9b1ed96c19860786a777f4336504fed38f4230700ca183292)
            check_type(argname=\\"argument helm_executable\\", value=helm_executable, expected_type=type_hints[\\"helm_executable\\"])
            check_type(argname=\\"argument helm_flags\\", value=helm_flags, expected_type=type_hints[\\"helm_flags\\"])
            check_type(argname=\\"argument namespace\\", value=namespace, expected_type=type_hints[\\"namespace\\"])
            check_type(argname=\\"argument release_name\\", value=release_name, expected_type=type_hints[\\"release_name\\"])
            check_type(argname=\\"argument values\\", value=values, expected_type=type_hints[\\"values\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if helm_executable is not None:
            self._values[\\"helm_executable\\"] = helm_executable
        if helm_flags is not None:
            self._values[\\"helm_flags\\"] = helm_flags
        if namespace is not None:
            self._values[\\"namespace\\"] = namespace
        if release_name is not None:
            self._values[\\"release_name\\"] = release_name
        if values is not None:
            self._values[\\"values\\"] = values

    @builtins.property
    def helm_executable(self) -> typing.Optional[builtins.str]:
        result = self._values.get(\\"helm_executable\\")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def helm_flags(self) -> typing.Optional[typing.List[builtins.str]]:
        result = self._values.get(\\"helm_flags\\")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        result = self._values.get(\\"namespace\\")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def release_name(self) -> typing.Optional[builtins.str]:
        result = self._values.get(\\"release_name\\")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def values(self) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        result = self._values.get(\\"values\\")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"LokiProps(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


__all__ = [
    \\"Loki\\",
    \\"LokiProps\\",
]

publication.publish()

def _typecheckingstub__f1d23af9ace606bd925629648645169df04574e2a303e09d4fcaf42d666e0f62(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    helm_executable: typing.Optional[builtins.str] = None,
    helm_flags: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespace: typing.Optional[builtins.str] = None,
    release_name: typing.Optional[builtins.str] = None,
    values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__c8e7d6706b1656a9b1ed96c19860786a777f4336504fed38f4230700ca183292(
    *,
    helm_executable: typing.Optional[builtins.str] = None,
    helm_flags: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespace: typing.Optional[builtins.str] = None,
    release_name: typing.Optional[builtins.str] = None,
    values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass
",
  "loki/_jsii/__init__.py": "from pkgutil import extend_path
__path__ = extend_path(__path__, __name__)

import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

import typeguard
from importlib.metadata import version as _metadata_package_version
TYPEGUARD_MAJOR_VERSION = int(_metadata_package_version('typeguard').split('.')[0])

def check_type(argname: str, value: object, expected_type: typing.Any) -> typing.Any:
    if TYPEGUARD_MAJOR_VERSION <= 2:
        return typeguard.check_type(argname=argname, value=value, expected_type=expected_type) # type:ignore
    else:
        if isinstance(value, jsii._reference_map.InterfaceDynamicProxy): # pyright: ignore [reportAttributeAccessIssue]
           pass
        else:
            if TYPEGUARD_MAJOR_VERSION == 3:
                typeguard.config.collection_check_strategy = typeguard.CollectionCheckStrategy.ALL_ITEMS # type:ignore
                typeguard.check_type(value=value, expected_type=expected_type) # type:ignore
            else:
                typeguard.check_type(value=value, expected_type=expected_type, collection_check_strategy=typeguard.CollectionCheckStrategy.ALL_ITEMS) # type:ignore

import cdk8s._jsii
import constructs._jsii

__jsii_assembly__ = jsii.JSIIAssembly.load(
    \\"loki\\", \\"0.0.0\\", __name__[0:-6], \\"loki@0.0.0.jsii.tgz\\"
)

__all__ = [
    \\"__jsii_assembly__\\",
]

publication.publish()
",
  "loki/py.typed": "
",
}
`;

exports[`importing helm chart helm:https://grafana.github.io/helm-charts/loki@5.27.0 with typescript lanugage 1`] = `
Object {
  "author": Object {
    "name": "generated@generated.com",
    "roles": Array [
      "author",
    ],
  },
  "dependencies": "__omitted__",
  "dependencyClosure": Object {
    "cdk8s": Object {
      "targets": Object {
        "dotnet": Object {
          "namespace": "Org.Cdk8s",
          "packageId": "Org.Cdk8s",
        },
        "go": Object {
          "moduleName": "github.com/cdk8s-team/cdk8s-core-go",
        },
        "java": Object {
          "maven": Object {
            "artifactId": "cdk8s",
            "groupId": "org.cdk8s",
          },
          "package": "org.cdk8s",
        },
        "js": Object {
          "npm": "cdk8s",
        },
        "python": Object {
          "distName": "cdk8s",
          "module": "cdk8s",
        },
      },
    },
    "constructs": Object {
      "targets": Object {
        "dotnet": Object {
          "namespace": "Constructs",
          "packageId": "Constructs",
        },
        "go": Object {
          "moduleName": "github.com/aws/constructs-go",
        },
        "java": Object {
          "maven": Object {
            "artifactId": "constructs",
            "groupId": "software.constructs",
          },
          "package": "software.constructs",
        },
        "js": Object {
          "npm": "constructs",
        },
        "python": Object {
          "distName": "constructs",
          "module": "constructs",
        },
      },
    },
  },
  "description": "loki",
  "fingerprint": "<fingerprint>",
  "homepage": "http://generated",
  "jsiiVersion": "__omitted__",
  "license": "UNLICENSED",
  "metadata": Object {
    "jsii": Object {
      "pacmak": Object {
        "hasDefaultInterfaces": true,
      },
    },
  },
  "name": "loki",
  "repository": Object {
    "type": "git",
    "url": "http://generated",
  },
  "schema": "jsii/0.10.0",
  "targets": Object {
    "js": Object {
      "npm": "loki",
    },
  },
  "types": Object {
    "loki.Loki": Object {
      "assembly": "loki",
      "base": "constructs.Construct",
      "fqn": "loki.Loki",
      "initializer": Object {
        "locationInModule": Object {
          "filename": "loki.ts",
          "line": 14,
        },
        "parameters": Array [
          Object {
            "name": "scope",
            "type": Object {
              "fqn": "constructs.Construct",
            },
          },
          Object {
            "name": "id",
            "type": Object {
              "primitive": "string",
            },
          },
          Object {
            "name": "props",
            "optional": true,
            "type": Object {
              "fqn": "loki.LokiProps",
            },
          },
        ],
      },
      "kind": "class",
      "locationInModule": Object {
        "filename": "loki.ts",
        "line": 13,
      },
      "name": "Loki",
      "symbolId": "loki:Loki",
    },
    "loki.LokiProps": Object {
      "assembly": "loki",
      "datatype": true,
      "fqn": "loki.LokiProps",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "loki.ts",
        "line": 5,
      },
      "name": "LokiProps",
      "properties": Array [
        Object {
          "abstract": true,
          "immutable": true,
          "locationInModule": Object {
            "filename": "loki.ts",
            "line": 8,
          },
          "name": "helmExecutable",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "immutable": true,
          "locationInModule": Object {
            "filename": "loki.ts",
            "line": 9,
          },
          "name": "helmFlags",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "string",
              },
              "kind": "array",
            },
          },
        },
        Object {
          "abstract": true,
          "immutable": true,
          "locationInModule": Object {
            "filename": "loki.ts",
            "line": 6,
          },
          "name": "namespace",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "immutable": true,
          "locationInModule": Object {
            "filename": "loki.ts",
            "line": 7,
          },
          "name": "releaseName",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "immutable": true,
          "locationInModule": Object {
            "filename": "loki.ts",
            "line": 10,
          },
          "name": "values",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "any",
              },
              "kind": "map",
            },
          },
        },
      ],
      "symbolId": "loki:LokiProps",
    },
  },
  "version": "0.0.0",
}
`;

exports[`importing helm chart helm:https://grafana.github.io/helm-charts/loki@5.27.0 with typescript lanugage 2`] = `
Object {
  "loki.ts": "// generated by cdk8s
import { Helm, HelmProps } from 'cdk8s';
import { Construct } from 'constructs';

export interface LokiProps {
  readonly namespace?: string;
  readonly releaseName?: string;
  readonly helmExecutable?: string;
  readonly helmFlags?: string[];
  readonly values?: { [key: string]: any };
}

export class Loki extends Construct {
  public constructor(scope: Construct, id: string, props: LokiProps = {}) {
    super(scope, id);
    let updatedProps = {};

    if (props.values) {
      const { additionalValues, ...valuesWithoutAdditionalValues } = props.values;
      updatedProps = {
        ...props,
        values: {
          ...this.flattenAdditionalValues(valuesWithoutAdditionalValues),
          ...additionalValues,
        },
      };
    }

    const finalProps: HelmProps = {
      chart: 'loki',
      repo: 'https://grafana.github.io/helm-charts',
      version: '5.27.0',
      ...(Object.keys(updatedProps).length !== 0 ? updatedProps : props),
    };

    new Helm(this, 'Helm', finalProps);
  }

  private flattenAdditionalValues(props: { [key: string]: any }): { [key: string]: any } {
    for (let prop in props) {
      if (Array.isArray(props[prop])) {
        props[prop].map((item: any) => {
          if (typeof item === 'object' && prop !== 'additionalValues') {
            return this.flattenAdditionalValues(item);
          }
          return item;
        });
      }
      else if (typeof props[prop] === 'object' && prop !== 'additionalValues') {
        props[prop] = this.flattenAdditionalValues(props[prop]);
      }
    }

    const { additionalValues, ...valuesWithoutAdditionalValues } = props;

    return {
      ...valuesWithoutAdditionalValues,
      ...additionalValues,
    };
  }
}

",
}
`;

exports[`importing helm chart helm:https://kubernetes.github.io/ingress-nginx/ingress-nginx@4.8.0 with python lanugage 1`] = `
Object {
  "author": Object {
    "name": "generated@generated.com",
    "roles": Array [
      "author",
    ],
  },
  "dependencies": "__omitted__",
  "dependencyClosure": Object {
    "cdk8s": Object {
      "targets": Object {
        "dotnet": Object {
          "namespace": "Org.Cdk8s",
          "packageId": "Org.Cdk8s",
        },
        "go": Object {
          "moduleName": "github.com/cdk8s-team/cdk8s-core-go",
        },
        "java": Object {
          "maven": Object {
            "artifactId": "cdk8s",
            "groupId": "org.cdk8s",
          },
          "package": "org.cdk8s",
        },
        "js": Object {
          "npm": "cdk8s",
        },
        "python": Object {
          "distName": "cdk8s",
          "module": "cdk8s",
        },
      },
    },
    "constructs": Object {
      "targets": Object {
        "dotnet": Object {
          "namespace": "Constructs",
          "packageId": "Constructs",
        },
        "go": Object {
          "moduleName": "github.com/aws/constructs-go",
        },
        "java": Object {
          "maven": Object {
            "artifactId": "constructs",
            "groupId": "software.constructs",
          },
          "package": "software.constructs",
        },
        "js": Object {
          "npm": "constructs",
        },
        "python": Object {
          "distName": "constructs",
          "module": "constructs",
        },
      },
    },
  },
  "description": "ingress-nginx",
  "fingerprint": "<fingerprint>",
  "homepage": "http://generated",
  "jsiiVersion": "__omitted__",
  "license": "UNLICENSED",
  "metadata": Object {
    "jsii": Object {
      "pacmak": Object {
        "hasDefaultInterfaces": true,
      },
    },
  },
  "name": "ingress-nginx",
  "repository": Object {
    "type": "git",
    "url": "http://generated",
  },
  "schema": "jsii/0.10.0",
  "targets": Object {
    "js": Object {
      "npm": "ingress-nginx",
    },
    "python": Object {
      "distName": "generated",
      "module": "ingress_nginx",
    },
  },
  "types": Object {
    "ingress-nginx.IngressNginx": Object {
      "assembly": "ingress-nginx",
      "base": "constructs.Construct",
      "fqn": "ingress-nginx.IngressNginx",
      "initializer": Object {
        "locationInModule": Object {
          "filename": "ingress-nginx.ts",
          "line": 14,
        },
        "parameters": Array [
          Object {
            "name": "scope",
            "type": Object {
              "fqn": "constructs.Construct",
            },
          },
          Object {
            "name": "id",
            "type": Object {
              "primitive": "string",
            },
          },
          Object {
            "name": "props",
            "optional": true,
            "type": Object {
              "fqn": "ingress-nginx.IngressNginxProps",
            },
          },
        ],
      },
      "kind": "class",
      "locationInModule": Object {
        "filename": "ingress-nginx.ts",
        "line": 13,
      },
      "name": "IngressNginx",
      "symbolId": "ingress-nginx:IngressNginx",
    },
    "ingress-nginx.IngressNginxProps": Object {
      "assembly": "ingress-nginx",
      "datatype": true,
      "fqn": "ingress-nginx.IngressNginxProps",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "ingress-nginx.ts",
        "line": 5,
      },
      "name": "IngressNginxProps",
      "properties": Array [
        Object {
          "abstract": true,
          "immutable": true,
          "locationInModule": Object {
            "filename": "ingress-nginx.ts",
            "line": 8,
          },
          "name": "helmExecutable",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "immutable": true,
          "locationInModule": Object {
            "filename": "ingress-nginx.ts",
            "line": 9,
          },
          "name": "helmFlags",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "string",
              },
              "kind": "array",
            },
          },
        },
        Object {
          "abstract": true,
          "immutable": true,
          "locationInModule": Object {
            "filename": "ingress-nginx.ts",
            "line": 6,
          },
          "name": "namespace",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "immutable": true,
          "locationInModule": Object {
            "filename": "ingress-nginx.ts",
            "line": 7,
          },
          "name": "releaseName",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "immutable": true,
          "locationInModule": Object {
            "filename": "ingress-nginx.ts",
            "line": 10,
          },
          "name": "values",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "any",
              },
              "kind": "map",
            },
          },
        },
      ],
      "symbolId": "ingress-nginx:IngressNginxProps",
    },
  },
  "version": "0.0.0",
}
`;

exports[`importing helm chart helm:https://kubernetes.github.io/ingress-nginx/ingress-nginx@4.8.0 with python lanugage 2`] = `
Object {
  "ingress_nginx/__init__.py": "from pkgutil import extend_path
__path__ = extend_path(__path__, __name__)

import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

import typeguard
from importlib.metadata import version as _metadata_package_version
TYPEGUARD_MAJOR_VERSION = int(_metadata_package_version('typeguard').split('.')[0])

def check_type(argname: str, value: object, expected_type: typing.Any) -> typing.Any:
    if TYPEGUARD_MAJOR_VERSION <= 2:
        return typeguard.check_type(argname=argname, value=value, expected_type=expected_type) # type:ignore
    else:
        if isinstance(value, jsii._reference_map.InterfaceDynamicProxy): # pyright: ignore [reportAttributeAccessIssue]
           pass
        else:
            if TYPEGUARD_MAJOR_VERSION == 3:
                typeguard.config.collection_check_strategy = typeguard.CollectionCheckStrategy.ALL_ITEMS # type:ignore
                typeguard.check_type(value=value, expected_type=expected_type) # type:ignore
            else:
                typeguard.check_type(value=value, expected_type=expected_type, collection_check_strategy=typeguard.CollectionCheckStrategy.ALL_ITEMS) # type:ignore

from ._jsii import *

import constructs as _constructs_77d1e7e8


class IngressNginx(
    _constructs_77d1e7e8.Construct,
    metaclass=jsii.JSIIMeta,
    jsii_type=\\"ingress-nginx.IngressNginx\\",
):
    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        helm_executable: typing.Optional[builtins.str] = None,
        helm_flags: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace: typing.Optional[builtins.str] = None,
        release_name: typing.Optional[builtins.str] = None,
        values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param helm_executable: -
        :param helm_flags: -
        :param namespace: -
        :param release_name: -
        :param values: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__45b0366c982454dda75ec7b3c4f4b0edf925261d6ae50d25c84ec696545df8bf)
            check_type(argname=\\"argument scope\\", value=scope, expected_type=type_hints[\\"scope\\"])
            check_type(argname=\\"argument id\\", value=id, expected_type=type_hints[\\"id\\"])
        props = IngressNginxProps(
            helm_executable=helm_executable,
            helm_flags=helm_flags,
            namespace=namespace,
            release_name=release_name,
            values=values,
        )

        jsii.create(self.__class__, self, [scope, id, props])


@jsii.data_type(
    jsii_type=\\"ingress-nginx.IngressNginxProps\\",
    jsii_struct_bases=[],
    name_mapping={
        \\"helm_executable\\": \\"helmExecutable\\",
        \\"helm_flags\\": \\"helmFlags\\",
        \\"namespace\\": \\"namespace\\",
        \\"release_name\\": \\"releaseName\\",
        \\"values\\": \\"values\\",
    },
)
class IngressNginxProps:
    def __init__(
        self,
        *,
        helm_executable: typing.Optional[builtins.str] = None,
        helm_flags: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace: typing.Optional[builtins.str] = None,
        release_name: typing.Optional[builtins.str] = None,
        values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    ) -> None:
        '''
        :param helm_executable: -
        :param helm_flags: -
        :param namespace: -
        :param release_name: -
        :param values: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fa1ad20aee8506867d7a9a951634bb1e075e978d51060ca2245cb7a42fd16877)
            check_type(argname=\\"argument helm_executable\\", value=helm_executable, expected_type=type_hints[\\"helm_executable\\"])
            check_type(argname=\\"argument helm_flags\\", value=helm_flags, expected_type=type_hints[\\"helm_flags\\"])
            check_type(argname=\\"argument namespace\\", value=namespace, expected_type=type_hints[\\"namespace\\"])
            check_type(argname=\\"argument release_name\\", value=release_name, expected_type=type_hints[\\"release_name\\"])
            check_type(argname=\\"argument values\\", value=values, expected_type=type_hints[\\"values\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if helm_executable is not None:
            self._values[\\"helm_executable\\"] = helm_executable
        if helm_flags is not None:
            self._values[\\"helm_flags\\"] = helm_flags
        if namespace is not None:
            self._values[\\"namespace\\"] = namespace
        if release_name is not None:
            self._values[\\"release_name\\"] = release_name
        if values is not None:
            self._values[\\"values\\"] = values

    @builtins.property
    def helm_executable(self) -> typing.Optional[builtins.str]:
        result = self._values.get(\\"helm_executable\\")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def helm_flags(self) -> typing.Optional[typing.List[builtins.str]]:
        result = self._values.get(\\"helm_flags\\")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        result = self._values.get(\\"namespace\\")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def release_name(self) -> typing.Optional[builtins.str]:
        result = self._values.get(\\"release_name\\")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def values(self) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        result = self._values.get(\\"values\\")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"IngressNginxProps(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


__all__ = [
    \\"IngressNginx\\",
    \\"IngressNginxProps\\",
]

publication.publish()

def _typecheckingstub__45b0366c982454dda75ec7b3c4f4b0edf925261d6ae50d25c84ec696545df8bf(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    helm_executable: typing.Optional[builtins.str] = None,
    helm_flags: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespace: typing.Optional[builtins.str] = None,
    release_name: typing.Optional[builtins.str] = None,
    values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__fa1ad20aee8506867d7a9a951634bb1e075e978d51060ca2245cb7a42fd16877(
    *,
    helm_executable: typing.Optional[builtins.str] = None,
    helm_flags: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespace: typing.Optional[builtins.str] = None,
    release_name: typing.Optional[builtins.str] = None,
    values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass
",
  "ingress_nginx/_jsii/__init__.py": "from pkgutil import extend_path
__path__ = extend_path(__path__, __name__)

import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

import typeguard
from importlib.metadata import version as _metadata_package_version
TYPEGUARD_MAJOR_VERSION = int(_metadata_package_version('typeguard').split('.')[0])

def check_type(argname: str, value: object, expected_type: typing.Any) -> typing.Any:
    if TYPEGUARD_MAJOR_VERSION <= 2:
        return typeguard.check_type(argname=argname, value=value, expected_type=expected_type) # type:ignore
    else:
        if isinstance(value, jsii._reference_map.InterfaceDynamicProxy): # pyright: ignore [reportAttributeAccessIssue]
           pass
        else:
            if TYPEGUARD_MAJOR_VERSION == 3:
                typeguard.config.collection_check_strategy = typeguard.CollectionCheckStrategy.ALL_ITEMS # type:ignore
                typeguard.check_type(value=value, expected_type=expected_type) # type:ignore
            else:
                typeguard.check_type(value=value, expected_type=expected_type, collection_check_strategy=typeguard.CollectionCheckStrategy.ALL_ITEMS) # type:ignore

import cdk8s._jsii
import constructs._jsii

__jsii_assembly__ = jsii.JSIIAssembly.load(
    \\"ingress-nginx\\", \\"0.0.0\\", __name__[0:-6], \\"ingress-nginx@0.0.0.jsii.tgz\\"
)

__all__ = [
    \\"__jsii_assembly__\\",
]

publication.publish()
",
  "ingress_nginx/py.typed": "
",
}
`;

exports[`importing helm chart helm:https://kubernetes.github.io/ingress-nginx/ingress-nginx@4.8.0 with typescript lanugage 1`] = `
Object {
  "author": Object {
    "name": "generated@generated.com",
    "roles": Array [
      "author",
    ],
  },
  "dependencies": "__omitted__",
  "dependencyClosure": Object {
    "cdk8s": Object {
      "targets": Object {
        "dotnet": Object {
          "namespace": "Org.Cdk8s",
          "packageId": "Org.Cdk8s",
        },
        "go": Object {
          "moduleName": "github.com/cdk8s-team/cdk8s-core-go",
        },
        "java": Object {
          "maven": Object {
            "artifactId": "cdk8s",
            "groupId": "org.cdk8s",
          },
          "package": "org.cdk8s",
        },
        "js": Object {
          "npm": "cdk8s",
        },
        "python": Object {
          "distName": "cdk8s",
          "module": "cdk8s",
        },
      },
    },
    "constructs": Object {
      "targets": Object {
        "dotnet": Object {
          "namespace": "Constructs",
          "packageId": "Constructs",
        },
        "go": Object {
          "moduleName": "github.com/aws/constructs-go",
        },
        "java": Object {
          "maven": Object {
            "artifactId": "constructs",
            "groupId": "software.constructs",
          },
          "package": "software.constructs",
        },
        "js": Object {
          "npm": "constructs",
        },
        "python": Object {
          "distName": "constructs",
          "module": "constructs",
        },
      },
    },
  },
  "description": "ingress-nginx",
  "fingerprint": "<fingerprint>",
  "homepage": "http://generated",
  "jsiiVersion": "__omitted__",
  "license": "UNLICENSED",
  "metadata": Object {
    "jsii": Object {
      "pacmak": Object {
        "hasDefaultInterfaces": true,
      },
    },
  },
  "name": "ingress-nginx",
  "repository": Object {
    "type": "git",
    "url": "http://generated",
  },
  "schema": "jsii/0.10.0",
  "targets": Object {
    "js": Object {
      "npm": "ingress-nginx",
    },
  },
  "types": Object {
    "ingress-nginx.IngressNginx": Object {
      "assembly": "ingress-nginx",
      "base": "constructs.Construct",
      "fqn": "ingress-nginx.IngressNginx",
      "initializer": Object {
        "locationInModule": Object {
          "filename": "ingress-nginx.ts",
          "line": 14,
        },
        "parameters": Array [
          Object {
            "name": "scope",
            "type": Object {
              "fqn": "constructs.Construct",
            },
          },
          Object {
            "name": "id",
            "type": Object {
              "primitive": "string",
            },
          },
          Object {
            "name": "props",
            "optional": true,
            "type": Object {
              "fqn": "ingress-nginx.IngressNginxProps",
            },
          },
        ],
      },
      "kind": "class",
      "locationInModule": Object {
        "filename": "ingress-nginx.ts",
        "line": 13,
      },
      "name": "IngressNginx",
      "symbolId": "ingress-nginx:IngressNginx",
    },
    "ingress-nginx.IngressNginxProps": Object {
      "assembly": "ingress-nginx",
      "datatype": true,
      "fqn": "ingress-nginx.IngressNginxProps",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "ingress-nginx.ts",
        "line": 5,
      },
      "name": "IngressNginxProps",
      "properties": Array [
        Object {
          "abstract": true,
          "immutable": true,
          "locationInModule": Object {
            "filename": "ingress-nginx.ts",
            "line": 8,
          },
          "name": "helmExecutable",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "immutable": true,
          "locationInModule": Object {
            "filename": "ingress-nginx.ts",
            "line": 9,
          },
          "name": "helmFlags",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "string",
              },
              "kind": "array",
            },
          },
        },
        Object {
          "abstract": true,
          "immutable": true,
          "locationInModule": Object {
            "filename": "ingress-nginx.ts",
            "line": 6,
          },
          "name": "namespace",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "immutable": true,
          "locationInModule": Object {
            "filename": "ingress-nginx.ts",
            "line": 7,
          },
          "name": "releaseName",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "immutable": true,
          "locationInModule": Object {
            "filename": "ingress-nginx.ts",
            "line": 10,
          },
          "name": "values",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "any",
              },
              "kind": "map",
            },
          },
        },
      ],
      "symbolId": "ingress-nginx:IngressNginxProps",
    },
  },
  "version": "0.0.0",
}
`;

exports[`importing helm chart helm:https://kubernetes.github.io/ingress-nginx/ingress-nginx@4.8.0 with typescript lanugage 2`] = `
Object {
  "ingress-nginx.ts": "// generated by cdk8s
import { Helm, HelmProps } from 'cdk8s';
import { Construct } from 'constructs';

export interface IngressNginxProps {
  readonly namespace?: string;
  readonly releaseName?: string;
  readonly helmExecutable?: string;
  readonly helmFlags?: string[];
  readonly values?: { [key: string]: any };
}

export class IngressNginx extends Construct {
  public constructor(scope: Construct, id: string, props: IngressNginxProps = {}) {
    super(scope, id);
    let updatedProps = {};

    if (props.values) {
      const { additionalValues, ...valuesWithoutAdditionalValues } = props.values;
      updatedProps = {
        ...props,
        values: {
          ...this.flattenAdditionalValues(valuesWithoutAdditionalValues),
          ...additionalValues,
        },
      };
    }

    const finalProps: HelmProps = {
      chart: 'ingress-nginx',
      repo: 'https://kubernetes.github.io/ingress-nginx',
      version: '4.8.0',
      ...(Object.keys(updatedProps).length !== 0 ? updatedProps : props),
    };

    new Helm(this, 'Helm', finalProps);
  }

  private flattenAdditionalValues(props: { [key: string]: any }): { [key: string]: any } {
    for (let prop in props) {
      if (Array.isArray(props[prop])) {
        props[prop].map((item: any) => {
          if (typeof item === 'object' && prop !== 'additionalValues') {
            return this.flattenAdditionalValues(item);
          }
          return item;
        });
      }
      else if (typeof props[prop] === 'object' && prop !== 'additionalValues') {
        props[prop] = this.flattenAdditionalValues(props[prop]);
      }
    }

    const { additionalValues, ...valuesWithoutAdditionalValues } = props;

    return {
      ...valuesWithoutAdditionalValues,
      ...additionalValues,
    };
  }
}

",
}
`;

exports[`importing helm chart helm:https://lacework.github.io/helm-charts/lacework-agent@6.9.0 with python lanugage 1`] = `
Object {
  "author": Object {
    "name": "generated@generated.com",
    "roles": Array [
      "author",
    ],
  },
  "dependencies": "__omitted__",
  "dependencyClosure": Object {
    "cdk8s": Object {
      "targets": Object {
        "dotnet": Object {
          "namespace": "Org.Cdk8s",
          "packageId": "Org.Cdk8s",
        },
        "go": Object {
          "moduleName": "github.com/cdk8s-team/cdk8s-core-go",
        },
        "java": Object {
          "maven": Object {
            "artifactId": "cdk8s",
            "groupId": "org.cdk8s",
          },
          "package": "org.cdk8s",
        },
        "js": Object {
          "npm": "cdk8s",
        },
        "python": Object {
          "distName": "cdk8s",
          "module": "cdk8s",
        },
      },
    },
    "constructs": Object {
      "targets": Object {
        "dotnet": Object {
          "namespace": "Constructs",
          "packageId": "Constructs",
        },
        "go": Object {
          "moduleName": "github.com/aws/constructs-go",
        },
        "java": Object {
          "maven": Object {
            "artifactId": "constructs",
            "groupId": "software.constructs",
          },
          "package": "software.constructs",
        },
        "js": Object {
          "npm": "constructs",
        },
        "python": Object {
          "distName": "constructs",
          "module": "constructs",
        },
      },
    },
  },
  "description": "lacework-agent",
  "fingerprint": "<fingerprint>",
  "homepage": "http://generated",
  "jsiiVersion": "__omitted__",
  "license": "UNLICENSED",
  "metadata": Object {
    "jsii": Object {
      "pacmak": Object {
        "hasDefaultInterfaces": true,
      },
    },
  },
  "name": "lacework-agent",
  "repository": Object {
    "type": "git",
    "url": "http://generated",
  },
  "schema": "jsii/0.10.0",
  "targets": Object {
    "js": Object {
      "npm": "lacework-agent",
    },
    "python": Object {
      "distName": "generated",
      "module": "lacework_agent",
    },
  },
  "types": Object {
    "lacework-agent.IoK8SApiCoreV1Affinity": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "io.k8s.api.core.v1.Affinity",
        },
        "summary": "Affinity is a group of affinity scheduling rules.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1Affinity",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 591,
      },
      "name": "IoK8SApiCoreV1Affinity",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "io.k8s.api.core.v1.Affinity#nodeAffinity",
            },
            "summary": "Node affinity is a group of node affinity scheduling rules.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 597,
          },
          "name": "nodeAffinity",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.IoK8SApiCoreV1AffinityNodeAffinity",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "io.k8s.api.core.v1.Affinity#podAffinity",
            },
            "summary": "Pod affinity is a group of inter pod affinity scheduling rules.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 604,
          },
          "name": "podAffinity",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAffinity",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "io.k8s.api.core.v1.Affinity#podAntiAffinity",
            },
            "summary": "Pod anti affinity is a group of inter pod anti affinity scheduling rules.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 611,
          },
          "name": "podAntiAffinity",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinity",
          },
        },
      ],
      "symbolId": "lacework-agent:IoK8SApiCoreV1Affinity",
    },
    "lacework-agent.IoK8SApiCoreV1AffinityNodeAffinity": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1AffinityNodeAffinity",
        },
        "summary": "Node affinity is a group of node affinity scheduling rules.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1AffinityNodeAffinity",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 960,
      },
      "name": "IoK8SApiCoreV1AffinityNodeAffinity",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution",
            },
            "remarks": "The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding \\"weight\\" to the sum if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the most preferred.",
            "summary": "The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 966,
          },
          "name": "preferredDuringSchedulingIgnoredDuringExecution",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "fqn": "lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution",
              },
              "kind": "array",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution",
            },
            "remarks": "that is, it represents the OR of the selectors represented by the node selector terms.",
            "summary": "A node selector represents the union of the results of one or more label queries over a set of nodes;",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 973,
          },
          "name": "requiredDuringSchedulingIgnoredDuringExecution",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution",
          },
        },
      ],
      "symbolId": "lacework-agent:IoK8SApiCoreV1AffinityNodeAffinity",
    },
    "lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution",
        },
        "summary": "An empty preferred scheduling term matches all objects with implicit weight 0 (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 1081,
      },
      "name": "IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference",
            },
            "remarks": "The requirements of them are ANDed. The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.",
            "summary": "A null or empty node selector term matches no objects.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1087,
          },
          "name": "preference",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight",
            },
            "summary": "Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1094,
          },
          "name": "weight",
          "optional": true,
          "type": Object {
            "primitive": "number",
          },
        },
      ],
      "symbolId": "lacework-agent:IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    },
    "lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference",
        },
        "remarks": "The requirements of them are ANDed. The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.",
        "summary": "A null or empty node selector term matches no objects.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 1234,
      },
      "name": "IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions",
            },
            "summary": "A list of node selector requirements by node's labels.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1240,
          },
          "name": "matchExpressions",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "fqn": "lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions",
              },
              "kind": "array",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields",
            },
            "summary": "A list of node selector requirements by node's fields.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1247,
          },
          "name": "matchFields",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "fqn": "lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields",
              },
              "kind": "array",
            },
          },
        },
      ],
      "symbolId": "lacework-agent:IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference",
    },
    "lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions",
        },
        "summary": "A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 1438,
      },
      "name": "IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key",
            },
            "summary": "The label key that the selector applies to.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1444,
          },
          "name": "key",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator",
            },
            "remarks": "Possible enum values:
- \`\\"DoesNotExist\\"\`
- \`\\"Exists\\"\`
- \`\\"Gt\\"\`
- \`\\"In\\"\`
- \`\\"Lt\\"\`
- \`\\"NotIn\\"\`",
            "summary": "Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1459,
          },
          "name": "operator",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOperator",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values",
            },
            "remarks": "If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.",
            "summary": "An array of string values.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1466,
          },
          "name": "values",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "string",
              },
              "kind": "array",
            },
          },
        },
      ],
      "symbolId": "lacework-agent:IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions",
    },
    "lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOperator": Object {
      "assembly": "lacework-agent",
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOperator",
        },
        "remarks": "Possible enum values:
- \`\\"DoesNotExist\\"\`
- \`\\"Exists\\"\`
- \`\\"Gt\\"\`
- \`\\"In\\"\`
- \`\\"Lt\\"\`
- \`\\"NotIn\\"\`",
        "summary": "Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOperator",
      "kind": "enum",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 1798,
      },
      "members": Array [
        Object {
          "docs": Object {
            "summary": "DoesNotExist.",
          },
          "name": "DOES_NOT_EXIST",
        },
        Object {
          "docs": Object {
            "summary": "Exists.",
          },
          "name": "EXISTS",
        },
        Object {
          "docs": Object {
            "summary": "Gt.",
          },
          "name": "GT",
        },
        Object {
          "docs": Object {
            "summary": "In.",
          },
          "name": "IN",
        },
        Object {
          "docs": Object {
            "summary": "Lt.",
          },
          "name": "LT",
        },
        Object {
          "docs": Object {
            "summary": "NotIn.",
          },
          "name": "NOT_IN",
        },
      ],
      "name": "IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOperator",
      "symbolId": "lacework-agent:IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOperator",
    },
    "lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields",
        },
        "summary": "A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 1475,
      },
      "name": "IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key",
            },
            "summary": "The label key that the selector applies to.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1481,
          },
          "name": "key",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator",
            },
            "remarks": "Possible enum values:
- \`\\"DoesNotExist\\"\`
- \`\\"Exists\\"\`
- \`\\"Gt\\"\`
- \`\\"In\\"\`
- \`\\"Lt\\"\`
- \`\\"NotIn\\"\`",
            "summary": "Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1496,
          },
          "name": "operator",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOperator",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values",
            },
            "remarks": "If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.",
            "summary": "An array of string values.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1503,
          },
          "name": "values",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "string",
              },
              "kind": "array",
            },
          },
        },
      ],
      "symbolId": "lacework-agent:IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields",
    },
    "lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOperator": Object {
      "assembly": "lacework-agent",
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOperator",
        },
        "remarks": "Possible enum values:
- \`\\"DoesNotExist\\"\`
- \`\\"Exists\\"\`
- \`\\"Gt\\"\`
- \`\\"In\\"\`
- \`\\"Lt\\"\`
- \`\\"NotIn\\"\`",
        "summary": "Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOperator",
      "kind": "enum",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 1826,
      },
      "members": Array [
        Object {
          "docs": Object {
            "summary": "DoesNotExist.",
          },
          "name": "DOES_NOT_EXIST",
        },
        Object {
          "docs": Object {
            "summary": "Exists.",
          },
          "name": "EXISTS",
        },
        Object {
          "docs": Object {
            "summary": "Gt.",
          },
          "name": "GT",
        },
        Object {
          "docs": Object {
            "summary": "In.",
          },
          "name": "IN",
        },
        Object {
          "docs": Object {
            "summary": "Lt.",
          },
          "name": "LT",
        },
        Object {
          "docs": Object {
            "summary": "NotIn.",
          },
          "name": "NOT_IN",
        },
      ],
      "name": "IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOperator",
      "symbolId": "lacework-agent:IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOperator",
    },
    "lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution",
        },
        "remarks": "that is, it represents the OR of the selectors represented by the node selector terms.",
        "summary": "A node selector represents the union of the results of one or more label queries over a set of nodes;",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 1103,
      },
      "name": "IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms",
            },
            "remarks": "A list of node selector terms. The terms are ORed.",
            "summary": "Required.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1109,
          },
          "name": "nodeSelectorTerms",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "fqn": "lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms",
              },
              "kind": "array",
            },
          },
        },
      ],
      "symbolId": "lacework-agent:IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    },
    "lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms",
        },
        "remarks": "The requirements of them are ANDed. The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.",
        "summary": "A null or empty node selector term matches no objects.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 1256,
      },
      "name": "IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions",
            },
            "summary": "A list of node selector requirements by node's labels.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1262,
          },
          "name": "matchExpressions",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "fqn": "lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions",
              },
              "kind": "array",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields",
            },
            "summary": "A list of node selector requirements by node's fields.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1269,
          },
          "name": "matchFields",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "fqn": "lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields",
              },
              "kind": "array",
            },
          },
        },
      ],
      "symbolId": "lacework-agent:IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms",
    },
    "lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions",
        },
        "summary": "A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 1512,
      },
      "name": "IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key",
            },
            "summary": "The label key that the selector applies to.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1518,
          },
          "name": "key",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator",
            },
            "remarks": "Possible enum values:
- \`\\"DoesNotExist\\"\`
- \`\\"Exists\\"\`
- \`\\"Gt\\"\`
- \`\\"In\\"\`
- \`\\"Lt\\"\`
- \`\\"NotIn\\"\`",
            "summary": "Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1533,
          },
          "name": "operator",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOperator",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values",
            },
            "remarks": "If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.",
            "summary": "An array of string values.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1540,
          },
          "name": "values",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "string",
              },
              "kind": "array",
            },
          },
        },
      ],
      "symbolId": "lacework-agent:IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions",
    },
    "lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOperator": Object {
      "assembly": "lacework-agent",
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOperator",
        },
        "remarks": "Possible enum values:
- \`\\"DoesNotExist\\"\`
- \`\\"Exists\\"\`
- \`\\"Gt\\"\`
- \`\\"In\\"\`
- \`\\"Lt\\"\`
- \`\\"NotIn\\"\`",
        "summary": "Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOperator",
      "kind": "enum",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 1854,
      },
      "members": Array [
        Object {
          "docs": Object {
            "summary": "DoesNotExist.",
          },
          "name": "DOES_NOT_EXIST",
        },
        Object {
          "docs": Object {
            "summary": "Exists.",
          },
          "name": "EXISTS",
        },
        Object {
          "docs": Object {
            "summary": "Gt.",
          },
          "name": "GT",
        },
        Object {
          "docs": Object {
            "summary": "In.",
          },
          "name": "IN",
        },
        Object {
          "docs": Object {
            "summary": "Lt.",
          },
          "name": "LT",
        },
        Object {
          "docs": Object {
            "summary": "NotIn.",
          },
          "name": "NOT_IN",
        },
      ],
      "name": "IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOperator",
      "symbolId": "lacework-agent:IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOperator",
    },
    "lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields",
        },
        "summary": "A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 1549,
      },
      "name": "IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key",
            },
            "summary": "The label key that the selector applies to.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1555,
          },
          "name": "key",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator",
            },
            "remarks": "Possible enum values:
- \`\\"DoesNotExist\\"\`
- \`\\"Exists\\"\`
- \`\\"Gt\\"\`
- \`\\"In\\"\`
- \`\\"Lt\\"\`
- \`\\"NotIn\\"\`",
            "summary": "Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1570,
          },
          "name": "operator",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOperator",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values",
            },
            "remarks": "If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.",
            "summary": "An array of string values.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1577,
          },
          "name": "values",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "string",
              },
              "kind": "array",
            },
          },
        },
      ],
      "symbolId": "lacework-agent:IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields",
    },
    "lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOperator": Object {
      "assembly": "lacework-agent",
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOperator",
        },
        "remarks": "Possible enum values:
- \`\\"DoesNotExist\\"\`
- \`\\"Exists\\"\`
- \`\\"Gt\\"\`
- \`\\"In\\"\`
- \`\\"Lt\\"\`
- \`\\"NotIn\\"\`",
        "summary": "Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOperator",
      "kind": "enum",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 1882,
      },
      "members": Array [
        Object {
          "docs": Object {
            "summary": "DoesNotExist.",
          },
          "name": "DOES_NOT_EXIST",
        },
        Object {
          "docs": Object {
            "summary": "Exists.",
          },
          "name": "EXISTS",
        },
        Object {
          "docs": Object {
            "summary": "Gt.",
          },
          "name": "GT",
        },
        Object {
          "docs": Object {
            "summary": "In.",
          },
          "name": "IN",
        },
        Object {
          "docs": Object {
            "summary": "Lt.",
          },
          "name": "LT",
        },
        Object {
          "docs": Object {
            "summary": "NotIn.",
          },
          "name": "NOT_IN",
        },
      ],
      "name": "IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOperator",
      "symbolId": "lacework-agent:IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOperator",
    },
    "lacework-agent.IoK8SApiCoreV1AffinityPodAffinity": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1AffinityPodAffinity",
        },
        "summary": "Pod affinity is a group of inter pod affinity scheduling rules.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAffinity",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 982,
      },
      "name": "IoK8SApiCoreV1AffinityPodAffinity",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution",
            },
            "remarks": "The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding \\"weight\\" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.",
            "summary": "The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 988,
          },
          "name": "preferredDuringSchedulingIgnoredDuringExecution",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution",
              },
              "kind": "array",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution",
            },
            "remarks": "If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.",
            "summary": "If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 995,
          },
          "name": "requiredDuringSchedulingIgnoredDuringExecution",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution",
              },
              "kind": "array",
            },
          },
        },
      ],
      "symbolId": "lacework-agent:IoK8SApiCoreV1AffinityPodAffinity",
    },
    "lacework-agent.IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution",
        },
        "summary": "The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s).",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 1118,
      },
      "name": "IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm",
            },
            "summary": "Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1124,
          },
          "name": "podAffinityTerm",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight",
            },
            "summary": "weight associated with matching the corresponding podAffinityTerm, in the range 1-100.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1131,
          },
          "name": "weight",
          "optional": true,
          "type": Object {
            "primitive": "number",
          },
        },
      ],
      "symbolId": "lacework-agent:IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    },
    "lacework-agent.IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
        },
        "summary": "Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 1278,
      },
      "name": "IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey",
            },
            "remarks": "Empty topologyKey is not allowed.",
            "summary": "This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1305,
          },
          "name": "topologyKey",
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector",
            },
            "remarks": "The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.",
            "summary": "A label selector is a label query over a set of resources.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1284,
          },
          "name": "labelSelector",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces",
            },
            "remarks": "The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means \\"this pod's namespace\\".",
            "summary": "namespaces specifies a static list of namespace names that the term applies to.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1298,
          },
          "name": "namespaces",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "string",
              },
              "kind": "array",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector",
            },
            "remarks": "The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.",
            "summary": "A label selector is a label query over a set of resources.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1291,
          },
          "name": "namespaceSelector",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector",
          },
        },
      ],
      "symbolId": "lacework-agent:IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
    },
    "lacework-agent.IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
        },
        "remarks": "The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.",
        "summary": "A label selector is a label query over a set of resources.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 1586,
      },
      "name": "IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions",
            },
            "remarks": "The requirements are ANDed.",
            "summary": "matchExpressions is a list of label selector requirements.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1592,
          },
          "name": "matchExpressions",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
              },
              "kind": "array",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels",
            },
            "remarks": "A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \\"key\\", the operator is \\"In\\", and the values array contains only \\"value\\". The requirements are ANDed.",
            "summary": "matchLabels is a map of {key,value} pairs.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1599,
          },
          "name": "matchLabels",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "string",
              },
              "kind": "map",
            },
          },
        },
      ],
      "symbolId": "lacework-agent:IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
    },
    "lacework-agent.IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
        },
        "summary": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 1902,
      },
      "name": "IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key",
            },
            "summary": "key is the label key that the selector applies to.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1908,
          },
          "name": "key",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator",
            },
            "remarks": "Valid operators are In, NotIn, Exists and DoesNotExist.",
            "summary": "operator represents a key's relationship to a set of values.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1915,
          },
          "name": "operator",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values",
            },
            "remarks": "If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
            "summary": "values is an array of string values.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1922,
          },
          "name": "values",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "string",
              },
              "kind": "array",
            },
          },
        },
      ],
      "symbolId": "lacework-agent:IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
    },
    "lacework-agent.IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector",
        },
        "remarks": "The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.",
        "summary": "A label selector is a label query over a set of resources.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 1608,
      },
      "name": "IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions",
            },
            "remarks": "The requirements are ANDed.",
            "summary": "matchExpressions is a list of label selector requirements.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1614,
          },
          "name": "matchExpressions",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions",
              },
              "kind": "array",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels",
            },
            "remarks": "A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \\"key\\", the operator is \\"In\\", and the values array contains only \\"value\\". The requirements are ANDed.",
            "summary": "matchLabels is a map of {key,value} pairs.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1621,
          },
          "name": "matchLabels",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "string",
              },
              "kind": "map",
            },
          },
        },
      ],
      "symbolId": "lacework-agent:IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector",
    },
    "lacework-agent.IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions",
        },
        "summary": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 1931,
      },
      "name": "IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key",
            },
            "summary": "key is the label key that the selector applies to.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1937,
          },
          "name": "key",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator",
            },
            "remarks": "Valid operators are In, NotIn, Exists and DoesNotExist.",
            "summary": "operator represents a key's relationship to a set of values.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1944,
          },
          "name": "operator",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values",
            },
            "remarks": "If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
            "summary": "values is an array of string values.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1951,
          },
          "name": "values",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "string",
              },
              "kind": "array",
            },
          },
        },
      ],
      "symbolId": "lacework-agent:IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions",
    },
    "lacework-agent.IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution",
        },
        "summary": "Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 1140,
      },
      "name": "IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector",
            },
            "remarks": "The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.",
            "summary": "A label selector is a label query over a set of resources.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1146,
          },
          "name": "labelSelector",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces",
            },
            "remarks": "The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means \\"this pod's namespace\\".",
            "summary": "namespaces specifies a static list of namespace names that the term applies to.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1160,
          },
          "name": "namespaces",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "string",
              },
              "kind": "array",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector",
            },
            "remarks": "The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.",
            "summary": "A label selector is a label query over a set of resources.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1153,
          },
          "name": "namespaceSelector",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey",
            },
            "remarks": "Empty topologyKey is not allowed.",
            "summary": "This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1167,
          },
          "name": "topologyKey",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
      ],
      "symbolId": "lacework-agent:IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    },
    "lacework-agent.IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
        },
        "remarks": "The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.",
        "summary": "A label selector is a label query over a set of resources.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 1314,
      },
      "name": "IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions",
            },
            "remarks": "The requirements are ANDed.",
            "summary": "matchExpressions is a list of label selector requirements.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1320,
          },
          "name": "matchExpressions",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
              },
              "kind": "array",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels",
            },
            "remarks": "A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \\"key\\", the operator is \\"In\\", and the values array contains only \\"value\\". The requirements are ANDed.",
            "summary": "matchLabels is a map of {key,value} pairs.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1327,
          },
          "name": "matchLabels",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "string",
              },
              "kind": "map",
            },
          },
        },
      ],
      "symbolId": "lacework-agent:IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
    },
    "lacework-agent.IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
        },
        "summary": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 1630,
      },
      "name": "IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key",
            },
            "summary": "key is the label key that the selector applies to.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1636,
          },
          "name": "key",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator",
            },
            "remarks": "Valid operators are In, NotIn, Exists and DoesNotExist.",
            "summary": "operator represents a key's relationship to a set of values.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1643,
          },
          "name": "operator",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values",
            },
            "remarks": "If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
            "summary": "values is an array of string values.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1650,
          },
          "name": "values",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "string",
              },
              "kind": "array",
            },
          },
        },
      ],
      "symbolId": "lacework-agent:IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
    },
    "lacework-agent.IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector",
        },
        "remarks": "The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.",
        "summary": "A label selector is a label query over a set of resources.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 1336,
      },
      "name": "IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions",
            },
            "remarks": "The requirements are ANDed.",
            "summary": "matchExpressions is a list of label selector requirements.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1342,
          },
          "name": "matchExpressions",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions",
              },
              "kind": "array",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels",
            },
            "remarks": "A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \\"key\\", the operator is \\"In\\", and the values array contains only \\"value\\". The requirements are ANDed.",
            "summary": "matchLabels is a map of {key,value} pairs.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1349,
          },
          "name": "matchLabels",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "string",
              },
              "kind": "map",
            },
          },
        },
      ],
      "symbolId": "lacework-agent:IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector",
    },
    "lacework-agent.IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions",
        },
        "summary": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 1659,
      },
      "name": "IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key",
            },
            "summary": "key is the label key that the selector applies to.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1665,
          },
          "name": "key",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator",
            },
            "remarks": "Valid operators are In, NotIn, Exists and DoesNotExist.",
            "summary": "operator represents a key's relationship to a set of values.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1672,
          },
          "name": "operator",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values",
            },
            "remarks": "If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
            "summary": "values is an array of string values.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1679,
          },
          "name": "values",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "string",
              },
              "kind": "array",
            },
          },
        },
      ],
      "symbolId": "lacework-agent:IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions",
    },
    "lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinity": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1AffinityPodAntiAffinity",
        },
        "summary": "Pod anti affinity is a group of inter pod anti affinity scheduling rules.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinity",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 1004,
      },
      "name": "IoK8SApiCoreV1AffinityPodAntiAffinity",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution",
            },
            "remarks": "The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding \\"weight\\" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.",
            "summary": "The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1010,
          },
          "name": "preferredDuringSchedulingIgnoredDuringExecution",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution",
              },
              "kind": "array",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution",
            },
            "remarks": "If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.",
            "summary": "If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1017,
          },
          "name": "requiredDuringSchedulingIgnoredDuringExecution",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution",
              },
              "kind": "array",
            },
          },
        },
      ],
      "symbolId": "lacework-agent:IoK8SApiCoreV1AffinityPodAntiAffinity",
    },
    "lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution",
        },
        "summary": "The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s).",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 1176,
      },
      "name": "IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm",
            },
            "summary": "Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1182,
          },
          "name": "podAffinityTerm",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight",
            },
            "summary": "weight associated with matching the corresponding podAffinityTerm, in the range 1-100.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1189,
          },
          "name": "weight",
          "optional": true,
          "type": Object {
            "primitive": "number",
          },
        },
      ],
      "symbolId": "lacework-agent:IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    },
    "lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
        },
        "summary": "Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 1358,
      },
      "name": "IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey",
            },
            "remarks": "Empty topologyKey is not allowed.",
            "summary": "This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1385,
          },
          "name": "topologyKey",
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector",
            },
            "remarks": "The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.",
            "summary": "A label selector is a label query over a set of resources.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1364,
          },
          "name": "labelSelector",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces",
            },
            "remarks": "The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means \\"this pod's namespace\\".",
            "summary": "namespaces specifies a static list of namespace names that the term applies to.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1378,
          },
          "name": "namespaces",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "string",
              },
              "kind": "array",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector",
            },
            "remarks": "The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.",
            "summary": "A label selector is a label query over a set of resources.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1371,
          },
          "name": "namespaceSelector",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector",
          },
        },
      ],
      "symbolId": "lacework-agent:IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
    },
    "lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
        },
        "remarks": "The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.",
        "summary": "A label selector is a label query over a set of resources.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 1688,
      },
      "name": "IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions",
            },
            "remarks": "The requirements are ANDed.",
            "summary": "matchExpressions is a list of label selector requirements.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1694,
          },
          "name": "matchExpressions",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
              },
              "kind": "array",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels",
            },
            "remarks": "A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \\"key\\", the operator is \\"In\\", and the values array contains only \\"value\\". The requirements are ANDed.",
            "summary": "matchLabels is a map of {key,value} pairs.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1701,
          },
          "name": "matchLabels",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "string",
              },
              "kind": "map",
            },
          },
        },
      ],
      "symbolId": "lacework-agent:IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
    },
    "lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
        },
        "summary": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 1960,
      },
      "name": "IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key",
            },
            "summary": "key is the label key that the selector applies to.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1966,
          },
          "name": "key",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator",
            },
            "remarks": "Valid operators are In, NotIn, Exists and DoesNotExist.",
            "summary": "operator represents a key's relationship to a set of values.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1973,
          },
          "name": "operator",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values",
            },
            "remarks": "If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
            "summary": "values is an array of string values.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1980,
          },
          "name": "values",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "string",
              },
              "kind": "array",
            },
          },
        },
      ],
      "symbolId": "lacework-agent:IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
    },
    "lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector",
        },
        "remarks": "The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.",
        "summary": "A label selector is a label query over a set of resources.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 1710,
      },
      "name": "IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions",
            },
            "remarks": "The requirements are ANDed.",
            "summary": "matchExpressions is a list of label selector requirements.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1716,
          },
          "name": "matchExpressions",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions",
              },
              "kind": "array",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels",
            },
            "remarks": "A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \\"key\\", the operator is \\"In\\", and the values array contains only \\"value\\". The requirements are ANDed.",
            "summary": "matchLabels is a map of {key,value} pairs.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1723,
          },
          "name": "matchLabels",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "string",
              },
              "kind": "map",
            },
          },
        },
      ],
      "symbolId": "lacework-agent:IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector",
    },
    "lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions",
        },
        "summary": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 1989,
      },
      "name": "IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key",
            },
            "summary": "key is the label key that the selector applies to.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1995,
          },
          "name": "key",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator",
            },
            "remarks": "Valid operators are In, NotIn, Exists and DoesNotExist.",
            "summary": "operator represents a key's relationship to a set of values.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 2002,
          },
          "name": "operator",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values",
            },
            "remarks": "If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
            "summary": "values is an array of string values.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 2009,
          },
          "name": "values",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "string",
              },
              "kind": "array",
            },
          },
        },
      ],
      "symbolId": "lacework-agent:IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions",
    },
    "lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution",
        },
        "summary": "Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 1198,
      },
      "name": "IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector",
            },
            "remarks": "The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.",
            "summary": "A label selector is a label query over a set of resources.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1204,
          },
          "name": "labelSelector",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces",
            },
            "remarks": "The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means \\"this pod's namespace\\".",
            "summary": "namespaces specifies a static list of namespace names that the term applies to.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1218,
          },
          "name": "namespaces",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "string",
              },
              "kind": "array",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector",
            },
            "remarks": "The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.",
            "summary": "A label selector is a label query over a set of resources.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1211,
          },
          "name": "namespaceSelector",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey",
            },
            "remarks": "Empty topologyKey is not allowed.",
            "summary": "This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1225,
          },
          "name": "topologyKey",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
      ],
      "symbolId": "lacework-agent:IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    },
    "lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
        },
        "remarks": "The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.",
        "summary": "A label selector is a label query over a set of resources.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 1394,
      },
      "name": "IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions",
            },
            "remarks": "The requirements are ANDed.",
            "summary": "matchExpressions is a list of label selector requirements.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1400,
          },
          "name": "matchExpressions",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
              },
              "kind": "array",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels",
            },
            "remarks": "A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \\"key\\", the operator is \\"In\\", and the values array contains only \\"value\\". The requirements are ANDed.",
            "summary": "matchLabels is a map of {key,value} pairs.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1407,
          },
          "name": "matchLabels",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "string",
              },
              "kind": "map",
            },
          },
        },
      ],
      "symbolId": "lacework-agent:IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
    },
    "lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
        },
        "summary": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 1732,
      },
      "name": "IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key",
            },
            "summary": "key is the label key that the selector applies to.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1738,
          },
          "name": "key",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator",
            },
            "remarks": "Valid operators are In, NotIn, Exists and DoesNotExist.",
            "summary": "operator represents a key's relationship to a set of values.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1745,
          },
          "name": "operator",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values",
            },
            "remarks": "If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
            "summary": "values is an array of string values.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1752,
          },
          "name": "values",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "string",
              },
              "kind": "array",
            },
          },
        },
      ],
      "symbolId": "lacework-agent:IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
    },
    "lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector",
        },
        "remarks": "The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.",
        "summary": "A label selector is a label query over a set of resources.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 1416,
      },
      "name": "IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions",
            },
            "remarks": "The requirements are ANDed.",
            "summary": "matchExpressions is a list of label selector requirements.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1422,
          },
          "name": "matchExpressions",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions",
              },
              "kind": "array",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels",
            },
            "remarks": "A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \\"key\\", the operator is \\"In\\", and the values array contains only \\"value\\". The requirements are ANDed.",
            "summary": "matchLabels is a map of {key,value} pairs.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1429,
          },
          "name": "matchLabels",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "string",
              },
              "kind": "map",
            },
          },
        },
      ],
      "symbolId": "lacework-agent:IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector",
    },
    "lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions",
        },
        "summary": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 1761,
      },
      "name": "IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key",
            },
            "summary": "key is the label key that the selector applies to.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1767,
          },
          "name": "key",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator",
            },
            "remarks": "Valid operators are In, NotIn, Exists and DoesNotExist.",
            "summary": "operator represents a key's relationship to a set of values.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1774,
          },
          "name": "operator",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values",
            },
            "remarks": "If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
            "summary": "values is an array of string values.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1781,
          },
          "name": "values",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "string",
              },
              "kind": "array",
            },
          },
        },
      ],
      "symbolId": "lacework-agent:IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions",
    },
    "lacework-agent.IoK8SApiCoreV1DaemonSetUpdateStrategy": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "io.k8s.api.core.v1.DaemonSetUpdateStrategy",
        },
        "summary": "DaemonSetUpdateStrategy is a struct used to control the update strategy for a DaemonSet.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1DaemonSetUpdateStrategy",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 620,
      },
      "name": "IoK8SApiCoreV1DaemonSetUpdateStrategy",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "io.k8s.api.core.v1.DaemonSetUpdateStrategy#rollingUpdate",
            },
            "summary": "Spec to control the desired behavior of daemon set rolling update.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 626,
          },
          "name": "rollingUpdate",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.IoK8SApiCoreV1DaemonSetUpdateStrategyRollingUpdate",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "io.k8s.api.core.v1.DaemonSetUpdateStrategy#type",
            },
            "default": "RollingUpdate.",
            "remarks": "Possible enum values:
- \`\\"OnDelete\\"\` Replace the old daemons only when it's killed
- \`\\"RollingUpdate\\"\` Replace the old daemons by new ones using rolling update i.e replace them on each node one after the other.",
            "summary": "Type of daemon set update. Can be \\"RollingUpdate\\" or \\"OnDelete\\". Default is RollingUpdate.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 638,
          },
          "name": "type",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.IoK8SApiCoreV1DaemonSetUpdateStrategyType",
          },
        },
      ],
      "symbolId": "lacework-agent:IoK8SApiCoreV1DaemonSetUpdateStrategy",
    },
    "lacework-agent.IoK8SApiCoreV1DaemonSetUpdateStrategyRollingUpdate": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1DaemonSetUpdateStrategyRollingUpdate",
        },
        "summary": "Spec to control the desired behavior of daemon set rolling update.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1DaemonSetUpdateStrategyRollingUpdate",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 1026,
      },
      "name": "IoK8SApiCoreV1DaemonSetUpdateStrategyRollingUpdate",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1DaemonSetUpdateStrategyRollingUpdate#maxSurge",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1030,
          },
          "name": "maxSurge",
          "optional": true,
          "type": Object {
            "primitive": "any",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1DaemonSetUpdateStrategyRollingUpdate#maxUnavailable",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1035,
          },
          "name": "maxUnavailable",
          "optional": true,
          "type": Object {
            "primitive": "any",
          },
        },
      ],
      "symbolId": "lacework-agent:IoK8SApiCoreV1DaemonSetUpdateStrategyRollingUpdate",
    },
    "lacework-agent.IoK8SApiCoreV1DaemonSetUpdateStrategyType": Object {
      "assembly": "lacework-agent",
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1DaemonSetUpdateStrategyType",
        },
        "default": "RollingUpdate.",
        "remarks": "Possible enum values:
- \`\\"OnDelete\\"\` Replace the old daemons only when it's killed
- \`\\"RollingUpdate\\"\` Replace the old daemons by new ones using rolling update i.e replace them on each node one after the other.",
        "summary": "Type of daemon set update. Can be \\"RollingUpdate\\" or \\"OnDelete\\". Default is RollingUpdate.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1DaemonSetUpdateStrategyType",
      "kind": "enum",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 1049,
      },
      "members": Array [
        Object {
          "docs": Object {
            "summary": "OnDelete.",
          },
          "name": "ON_DELETE",
        },
        Object {
          "docs": Object {
            "summary": "RollingUpdate.",
          },
          "name": "ROLLING_UPDATE",
        },
      ],
      "name": "IoK8SApiCoreV1DaemonSetUpdateStrategyType",
      "symbolId": "lacework-agent:IoK8SApiCoreV1DaemonSetUpdateStrategyType",
    },
    "lacework-agent.IoK8SApiCoreV1LocalObjectReference": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "io.k8s.api.core.v1.LocalObjectReference",
        },
        "summary": "LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1LocalObjectReference",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 658,
      },
      "name": "IoK8SApiCoreV1LocalObjectReference",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "io.k8s.api.core.v1.LocalObjectReference#name",
            },
            "remarks": "More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
            "summary": "Name of the referent.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 664,
          },
          "name": "name",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
      ],
      "symbolId": "lacework-agent:IoK8SApiCoreV1LocalObjectReference",
    },
    "lacework-agent.IoK8SApiCoreV1ResourceRequirements": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "io.k8s.api.core.v1.ResourceRequirements",
        },
        "summary": "ResourceRequirements describes the compute resource requirements.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1ResourceRequirements",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 516,
      },
      "name": "IoK8SApiCoreV1ResourceRequirements",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "io.k8s.api.core.v1.ResourceRequirements#limits",
            },
            "remarks": "More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/",
            "summary": "Limits describes the maximum amount of compute resources allowed.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 522,
          },
          "name": "limits",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "any",
              },
              "kind": "map",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "io.k8s.api.core.v1.ResourceRequirements#requests",
            },
            "remarks": "If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/",
            "summary": "Requests describes the minimum amount of compute resources required.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 529,
          },
          "name": "requests",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "any",
              },
              "kind": "map",
            },
          },
        },
      ],
      "symbolId": "lacework-agent:IoK8SApiCoreV1ResourceRequirements",
    },
    "lacework-agent.IoK8SApiCoreV1Toleration": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "io.k8s.api.core.v1.Toleration",
        },
        "summary": "The pod this Toleration is attached to tolerates any taint that matches the triple <key,value,effect> using the matching operator <operator>.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1Toleration",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 538,
      },
      "name": "IoK8SApiCoreV1Toleration",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "io.k8s.api.core.v1.Toleration#effect",
            },
            "remarks": "Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.

Possible enum values:
- \`\\"NoExecute\\"\` Evict any already-running pods that do not tolerate the taint. Currently enforced by NodeController.
- \`\\"NoSchedule\\"\` Do not allow new pods to schedule onto the node unless they tolerate the taint, but allow all pods submitted to Kubelet without going through the scheduler to start, and allow all already-running pods to continue running. Enforced by the scheduler.
- \`\\"PreferNoSchedule\\"\` Like TaintEffectNoSchedule, but the scheduler tries not to schedule new pods onto the node, rather than prohibiting new pods from scheduling onto the node entirely. Enforced by the scheduler.",
            "summary": "Effect indicates the taint effect to match.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 549,
          },
          "name": "effect",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.IoK8SApiCoreV1TolerationEffect",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "io.k8s.api.core.v1.Toleration#key",
            },
            "remarks": "Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.",
            "summary": "Key is the taint key that the toleration applies to.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 556,
          },
          "name": "key",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "io.k8s.api.core.v1.Toleration#operator",
            },
            "default": "Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.",
            "remarks": "Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.

Possible enum values:
- \`\\"Equal\\"\`
- \`\\"Exists\\"\`",
            "summary": "Operator represents a key's relationship to the value.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 568,
          },
          "name": "operator",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.IoK8SApiCoreV1TolerationOperator",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "io.k8s.api.core.v1.Toleration#tolerationSeconds",
            },
            "remarks": "By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.",
            "summary": "TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 575,
          },
          "name": "tolerationSeconds",
          "optional": true,
          "type": Object {
            "primitive": "number",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "io.k8s.api.core.v1.Toleration#value",
            },
            "remarks": "If the operator is Exists, the value should be empty, otherwise just a regular string.",
            "summary": "Value is the taint value the toleration matches to.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 582,
          },
          "name": "value",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
      ],
      "symbolId": "lacework-agent:IoK8SApiCoreV1Toleration",
    },
    "lacework-agent.IoK8SApiCoreV1TolerationEffect": Object {
      "assembly": "lacework-agent",
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1TolerationEffect",
        },
        "remarks": "Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.

Possible enum values:
- \`\\"NoExecute\\"\` Evict any already-running pods that do not tolerate the taint. Currently enforced by NodeController.
- \`\\"NoSchedule\\"\` Do not allow new pods to schedule onto the node unless they tolerate the taint, but allow all pods submitted to Kubelet without going through the scheduler to start, and allow all already-running pods to continue running. Enforced by the scheduler.
- \`\\"PreferNoSchedule\\"\` Like TaintEffectNoSchedule, but the scheduler tries not to schedule new pods onto the node, rather than prohibiting new pods from scheduling onto the node entirely. Enforced by the scheduler.",
        "summary": "Effect indicates the taint effect to match.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1TolerationEffect",
      "kind": "enum",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 929,
      },
      "members": Array [
        Object {
          "docs": Object {
            "summary": "NoExecute.",
          },
          "name": "NO_EXECUTE",
        },
        Object {
          "docs": Object {
            "summary": "NoSchedule.",
          },
          "name": "NO_SCHEDULE",
        },
        Object {
          "docs": Object {
            "summary": "PreferNoSchedule.",
          },
          "name": "PREFER_NO_SCHEDULE",
        },
      ],
      "name": "IoK8SApiCoreV1TolerationEffect",
      "symbolId": "lacework-agent:IoK8SApiCoreV1TolerationEffect",
    },
    "lacework-agent.IoK8SApiCoreV1TolerationOperator": Object {
      "assembly": "lacework-agent",
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1TolerationOperator",
        },
        "default": "Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.",
        "remarks": "Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.

Possible enum values:
- \`\\"Equal\\"\`
- \`\\"Exists\\"\`",
        "summary": "Operator represents a key's relationship to the value.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1TolerationOperator",
      "kind": "enum",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 948,
      },
      "members": Array [
        Object {
          "docs": Object {
            "summary": "Equal.",
          },
          "name": "EQUAL",
        },
        Object {
          "docs": Object {
            "summary": "Exists.",
          },
          "name": "EXISTS",
        },
      ],
      "name": "IoK8SApiCoreV1TolerationOperator",
      "symbolId": "lacework-agent:IoK8SApiCoreV1TolerationOperator",
    },
    "lacework-agent.LaceworkAgent": Object {
      "assembly": "lacework-agent",
      "base": "constructs.Construct",
      "fqn": "lacework-agent.LaceworkAgent",
      "initializer": Object {
        "locationInModule": Object {
          "filename": "lacework-agent.ts",
          "line": 14,
        },
        "parameters": Array [
          Object {
            "name": "scope",
            "type": Object {
              "fqn": "constructs.Construct",
            },
          },
          Object {
            "name": "id",
            "type": Object {
              "primitive": "string",
            },
          },
          Object {
            "name": "props",
            "type": Object {
              "fqn": "lacework-agent.LaceworkAgentProps",
            },
          },
        ],
      },
      "kind": "class",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 13,
      },
      "name": "LaceworkAgent",
      "symbolId": "lacework-agent:LaceworkAgent",
    },
    "lacework-agent.LaceworkAgentCloudservice": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "LaceworkAgentCloudservice",
        },
      },
      "fqn": "lacework-agent.LaceworkAgentCloudservice",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 243,
      },
      "name": "LaceworkAgentCloudservice",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentCloudservice#gke",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 247,
          },
          "name": "gke",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.LaceworkAgentCloudserviceGke",
          },
        },
      ],
      "symbolId": "lacework-agent:LaceworkAgentCloudservice",
    },
    "lacework-agent.LaceworkAgentCloudserviceGke": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "LaceworkAgentCloudserviceGke",
        },
      },
      "fqn": "lacework-agent.LaceworkAgentCloudserviceGke",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 645,
      },
      "name": "LaceworkAgentCloudserviceGke",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentCloudserviceGke#autopilot",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 649,
          },
          "name": "autopilot",
          "optional": true,
          "type": Object {
            "primitive": "boolean",
          },
        },
      ],
      "symbolId": "lacework-agent:LaceworkAgentCloudserviceGke",
    },
    "lacework-agent.LaceworkAgentClusterAgent": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "LaceworkAgentClusterAgent",
        },
      },
      "fqn": "lacework-agent.LaceworkAgentClusterAgent",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 327,
      },
      "name": "LaceworkAgentClusterAgent",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentClusterAgent#enable",
            },
            "summary": "Enable cluster agent.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 338,
          },
          "name": "enable",
          "type": Object {
            "primitive": "boolean",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentClusterAgent#image",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 331,
          },
          "name": "image",
          "type": Object {
            "fqn": "lacework-agent.LaceworkAgentClusterAgentImage",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentClusterAgent#additionalValues",
            },
            "summary": "Values that are not available in values.schema.json will not be code generated. You can add such values to this property.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 373,
          },
          "name": "additionalValues",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "any",
              },
              "kind": "map",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentClusterAgent#clusterRegion",
            },
            "summary": "Kubernetes cluster cloud region.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 352,
          },
          "name": "clusterRegion",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentClusterAgent#clusterType",
            },
            "summary": "Kubernetes cluster type.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 345,
          },
          "name": "clusterType",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.LaceworkAgentClusterAgentClusterType",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentClusterAgent#scrapeInitialDelayMins",
            },
            "summary": "Cluster mode agent's initial delay of cluster scraping after startup in minutes.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 359,
          },
          "name": "scrapeInitialDelayMins",
          "optional": true,
          "type": Object {
            "primitive": "number",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentClusterAgent#scrapeIntervalMins",
            },
            "summary": "Cluster mode agent's scrape interval in minutes.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 366,
          },
          "name": "scrapeIntervalMins",
          "optional": true,
          "type": Object {
            "primitive": "number",
          },
        },
      ],
      "symbolId": "lacework-agent:LaceworkAgentClusterAgent",
    },
    "lacework-agent.LaceworkAgentClusterAgentClusterType": Object {
      "assembly": "lacework-agent",
      "docs": Object {
        "custom": Object {
          "schema": "LaceworkAgentClusterAgentClusterType",
        },
        "summary": "Kubernetes cluster type.",
      },
      "fqn": "lacework-agent.LaceworkAgentClusterAgentClusterType",
      "kind": "enum",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 741,
      },
      "members": Array [
        Object {
          "docs": Object {
            "summary": "eks.",
          },
          "name": "EKS",
        },
        Object {
          "docs": Object {
            "summary": "gke.",
          },
          "name": "GKE",
        },
        Object {
          "docs": Object {
            "summary": "unknown.",
          },
          "name": "UNKNOWN",
        },
      ],
      "name": "LaceworkAgentClusterAgentClusterType",
      "symbolId": "lacework-agent:LaceworkAgentClusterAgentClusterType",
    },
    "lacework-agent.LaceworkAgentClusterAgentImage": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "LaceworkAgentClusterAgentImage",
        },
      },
      "fqn": "lacework-agent.LaceworkAgentClusterAgentImage",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 691,
      },
      "name": "LaceworkAgentClusterAgentImage",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentClusterAgentImage#pullPolicy",
            },
            "default": "Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images",
            "remarks": "One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images

Possible enum values:
- \`\\"Always\\"\` means that kubelet always attempts to pull the latest image. Container will fail If the pull fails.
- \`\\"IfNotPresent\\"\` means that kubelet pulls if the image isn't present on disk. Container will fail if the image isn't present and the pull fails.
- \`\\"Never\\"\` means that kubelet never pulls an image, but only uses a local image. Container will fail if the image isn't present",
            "summary": "Image pull policy.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 710,
          },
          "name": "pullPolicy",
          "type": Object {
            "fqn": "lacework-agent.LaceworkAgentClusterAgentImagePullPolicy",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentClusterAgentImage#registry",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 715,
          },
          "name": "registry",
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentClusterAgentImage#repository",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 720,
          },
          "name": "repository",
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentClusterAgentImage#tag",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 725,
          },
          "name": "tag",
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentClusterAgentImage#additionalValues",
            },
            "summary": "Values that are not available in values.schema.json will not be code generated. You can add such values to this property.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 732,
          },
          "name": "additionalValues",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "any",
              },
              "kind": "map",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentClusterAgentImage#imagePullSecrets",
            },
            "remarks": "If specified, these secrets will be passed to individual puller implementations for them to use. More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod",
            "summary": "ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 697,
          },
          "name": "imagePullSecrets",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "fqn": "lacework-agent.IoK8SApiCoreV1LocalObjectReference",
              },
              "kind": "array",
            },
          },
        },
      ],
      "symbolId": "lacework-agent:LaceworkAgentClusterAgentImage",
    },
    "lacework-agent.LaceworkAgentClusterAgentImagePullPolicy": Object {
      "assembly": "lacework-agent",
      "docs": Object {
        "custom": Object {
          "schema": "LaceworkAgentClusterAgentImagePullPolicy",
        },
        "default": "Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images",
        "remarks": "One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images

Possible enum values:
- \`\\"Always\\"\` means that kubelet always attempts to pull the latest image. Container will fail If the pull fails.
- \`\\"IfNotPresent\\"\` means that kubelet pulls if the image isn't present on disk. Container will fail if the image isn't present and the pull fails.
- \`\\"Never\\"\` means that kubelet never pulls an image, but only uses a local image. Container will fail if the image isn't present",
        "summary": "Image pull policy.",
      },
      "fqn": "lacework-agent.LaceworkAgentClusterAgentImagePullPolicy",
      "kind": "enum",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 1067,
      },
      "members": Array [
        Object {
          "docs": Object {
            "summary": "Always.",
          },
          "name": "ALWAYS",
        },
        Object {
          "docs": Object {
            "summary": "IfNotPresent.",
          },
          "name": "IF_NOT_PRESENT",
        },
        Object {
          "docs": Object {
            "summary": "Never.",
          },
          "name": "NEVER",
        },
      ],
      "name": "LaceworkAgentClusterAgentImagePullPolicy",
      "symbolId": "lacework-agent:LaceworkAgentClusterAgentImagePullPolicy",
    },
    "lacework-agent.LaceworkAgentDaemonset": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "LaceworkAgentDaemonset",
        },
      },
      "fqn": "lacework-agent.LaceworkAgentDaemonset",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 161,
      },
      "name": "LaceworkAgentDaemonset",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentDaemonset#affinity",
            },
            "summary": "If specified, the pod's scheduling constraints.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 167,
          },
          "name": "affinity",
          "type": Object {
            "fqn": "lacework-agent.IoK8SApiCoreV1Affinity",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentDaemonset#updateStrategy",
            },
            "summary": "An update strategy to replace existing DaemonSet pods with new pods.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 174,
          },
          "name": "updateStrategy",
          "type": Object {
            "fqn": "lacework-agent.IoK8SApiCoreV1DaemonSetUpdateStrategy",
          },
        },
      ],
      "symbolId": "lacework-agent:LaceworkAgentDaemonset",
    },
    "lacework-agent.LaceworkAgentDatacollector": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "LaceworkAgentDatacollector",
        },
      },
      "fqn": "lacework-agent.LaceworkAgentDatacollector",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 254,
      },
      "name": "LaceworkAgentDatacollector",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentDatacollector#additionalValues",
            },
            "summary": "Values that are not available in values.schema.json will not be code generated. You can add such values to this property.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 267,
          },
          "name": "additionalValues",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "any",
              },
              "kind": "map",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentDatacollector#enable",
            },
            "summary": "Enable lacework datacollector.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 260,
          },
          "name": "enable",
          "optional": true,
          "type": Object {
            "primitive": "boolean",
          },
        },
      ],
      "symbolId": "lacework-agent:LaceworkAgentDatacollector",
    },
    "lacework-agent.LaceworkAgentDeployment": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "LaceworkAgentDeployment",
        },
      },
      "fqn": "lacework-agent.LaceworkAgentDeployment",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 181,
      },
      "name": "LaceworkAgentDeployment",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentDeployment#affinity",
            },
            "summary": "If specified, the pod's scheduling constraints.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 187,
          },
          "name": "affinity",
          "type": Object {
            "fqn": "lacework-agent.IoK8SApiCoreV1Affinity",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentDeployment#updateStrategy",
            },
            "summary": "An update strategy to replace existing DaemonSet pods with new pods.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 194,
          },
          "name": "updateStrategy",
          "type": Object {
            "fqn": "lacework-agent.IoK8SApiCoreV1DaemonSetUpdateStrategy",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentDeployment#priorityClassCreate",
            },
            "summary": "If specified, a priority class is created and used to deploy agent.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 215,
          },
          "name": "priorityClassCreate",
          "optional": true,
          "type": Object {
            "primitive": "boolean",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentDeployment#priorityClassName",
            },
            "remarks": "\\"system-node-critical\\" and \\"system-cluster-critical\\" are two special keywords which indicate the highest priorities with the former being the highest priority. Any other name must be defined by creating a PriorityClass object with that name. If not specified, the pod priority will be default or zero if there is no default.",
            "summary": "If specified, indicates the pod's priority.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 208,
          },
          "name": "priorityClassName",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentDeployment#priorityClassPreemptionPolicy",
            },
            "summary": "If specified, it determines if agent pod can preempt a pod with a lower a priority.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 222,
          },
          "name": "priorityClassPreemptionPolicy",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentDeployment#priorityClassValue",
            },
            "summary": "If specified, it represents the priority class value to use.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 229,
          },
          "name": "priorityClassValue",
          "optional": true,
          "type": Object {
            "primitive": "number",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentDeployment#resources",
            },
            "remarks": "Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/",
            "summary": "Compute Resources required by this container.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 201,
          },
          "name": "resources",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.IoK8SApiCoreV1ResourceRequirements",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentDeployment#tolerations",
            },
            "summary": "If specified, the pod's tolerations.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 236,
          },
          "name": "tolerations",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "fqn": "lacework-agent.IoK8SApiCoreV1Toleration",
              },
              "kind": "array",
            },
          },
        },
      ],
      "symbolId": "lacework-agent:LaceworkAgentDeployment",
    },
    "lacework-agent.LaceworkAgentImage": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "LaceworkAgentImage",
        },
      },
      "fqn": "lacework-agent.LaceworkAgentImage",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 274,
      },
      "name": "LaceworkAgentImage",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentImage#pullPolicy",
            },
            "default": "Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images",
            "remarks": "One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images

Possible enum values:
- \`\\"Always\\"\` means that kubelet always attempts to pull the latest image. Container will fail If the pull fails.
- \`\\"IfNotPresent\\"\` means that kubelet pulls if the image isn't present on disk. Container will fail if the image isn't present and the pull fails.
- \`\\"Never\\"\` means that kubelet never pulls an image, but only uses a local image. Container will fail if the image isn't present",
            "summary": "Image pull policy.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 293,
          },
          "name": "pullPolicy",
          "type": Object {
            "fqn": "lacework-agent.LaceworkAgentImagePullPolicy",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentImage#registry",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 298,
          },
          "name": "registry",
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentImage#repository",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 303,
          },
          "name": "repository",
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentImage#tag",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 308,
          },
          "name": "tag",
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentImage#additionalValues",
            },
            "summary": "Values that are not available in values.schema.json will not be code generated. You can add such values to this property.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 320,
          },
          "name": "additionalValues",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "any",
              },
              "kind": "map",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentImage#imagePullSecrets",
            },
            "remarks": "If specified, these secrets will be passed to individual puller implementations for them to use. More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod",
            "summary": "ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 280,
          },
          "name": "imagePullSecrets",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "fqn": "lacework-agent.IoK8SApiCoreV1LocalObjectReference",
              },
              "kind": "array",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentImage#overrideValue",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 313,
          },
          "name": "overrideValue",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
      ],
      "symbolId": "lacework-agent:LaceworkAgentImage",
    },
    "lacework-agent.LaceworkAgentImagePullPolicy": Object {
      "assembly": "lacework-agent",
      "docs": Object {
        "custom": Object {
          "schema": "LaceworkAgentImagePullPolicy",
        },
        "default": "Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images",
        "remarks": "One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images

Possible enum values:
- \`\\"Always\\"\` means that kubelet always attempts to pull the latest image. Container will fail If the pull fails.
- \`\\"IfNotPresent\\"\` means that kubelet pulls if the image isn't present on disk. Container will fail if the image isn't present and the pull fails.
- \`\\"Never\\"\` means that kubelet never pulls an image, but only uses a local image. Container will fail if the image isn't present",
        "summary": "Image pull policy.",
      },
      "fqn": "lacework-agent.LaceworkAgentImagePullPolicy",
      "kind": "enum",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 679,
      },
      "members": Array [
        Object {
          "docs": Object {
            "summary": "Always.",
          },
          "name": "ALWAYS",
        },
        Object {
          "docs": Object {
            "summary": "IfNotPresent.",
          },
          "name": "IF_NOT_PRESENT",
        },
        Object {
          "docs": Object {
            "summary": "Never.",
          },
          "name": "NEVER",
        },
      ],
      "name": "LaceworkAgentImagePullPolicy",
      "symbolId": "lacework-agent:LaceworkAgentImagePullPolicy",
    },
    "lacework-agent.LaceworkAgentLaceworkConfig": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "LaceworkAgentLaceworkConfig",
        },
      },
      "fqn": "lacework-agent.LaceworkAgentLaceworkConfig",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 380,
      },
      "name": "LaceworkAgentLaceworkConfig",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfig#accessToken",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 384,
          },
          "name": "accessToken",
          "type": Object {
            "primitive": "any",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfig#additionalValues",
            },
            "summary": "Values that are not available in values.schema.json will not be code generated. You can add such values to this property.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 507,
          },
          "name": "additionalValues",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "any",
              },
              "kind": "map",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfig#annotations",
            },
            "remarks": "They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations",
            "summary": "Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 396,
          },
          "name": "annotations",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "string",
              },
              "kind": "map",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfig#anonymizeIncoming",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 389,
          },
          "name": "anonymizeIncoming",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.LaceworkAgentLaceworkConfigAnonymizeIncoming",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfig#autoUpgrade",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 401,
          },
          "name": "autoUpgrade",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.LaceworkAgentLaceworkConfigAutoUpgrade",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfig#cmdlinefilter",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 406,
          },
          "name": "cmdlinefilter",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.LaceworkAgentLaceworkConfigCmdlinefilter",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfig#codeaware",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 411,
          },
          "name": "codeaware",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.LaceworkAgentLaceworkConfigCodeaware",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfig#containerEngineEndpoint",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 416,
          },
          "name": "containerEngineEndpoint",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfig#containerRuntime",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 421,
          },
          "name": "containerRuntime",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.LaceworkAgentLaceworkConfigContainerRuntime",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfig#datacollector",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 426,
          },
          "name": "datacollector",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.LaceworkAgentLaceworkConfigDatacollector",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfig#env",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 455,
          },
          "name": "env",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfig#fim",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 460,
          },
          "name": "fim",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.LaceworkAgentLaceworkConfigFim",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfig#k8sNodeScrapeIntervalMins",
            },
            "summary": "Kubernetes node's scrape interval in minutes.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 433,
          },
          "name": "k8SNodeScrapeIntervalMins",
          "optional": true,
          "type": Object {
            "primitive": "number",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfig#kubernetesCluster",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 438,
          },
          "name": "kubernetesCluster",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfig#labels",
            },
            "remarks": "May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels",
            "summary": "Map of string keys and values that can be used to organize and categorize (scope and select) objects.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 445,
          },
          "name": "labels",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "string",
              },
              "kind": "map",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfig#metadataRequestInterval",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 450,
          },
          "name": "metadataRequestInterval",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfig#packagescan",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 465,
          },
          "name": "packagescan",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.LaceworkAgentLaceworkConfigPackagescan",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfig#perfmode",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 500,
          },
          "name": "perfmode",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.LaceworkAgentLaceworkConfigPerfmode",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfig#procscan",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 470,
          },
          "name": "procscan",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.LaceworkAgentLaceworkConfigProcscan",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfig#proxyUrl",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 475,
          },
          "name": "proxyUrl",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfig#serverUrl",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 480,
          },
          "name": "serverUrl",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfig#serviceAccountName",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 485,
          },
          "name": "serviceAccountName",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfig#stdoutLogging",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 490,
          },
          "name": "stdoutLogging",
          "optional": true,
          "type": Object {
            "primitive": "boolean",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfig#tags",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 495,
          },
          "name": "tags",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "string",
              },
              "kind": "map",
            },
          },
        },
      ],
      "symbolId": "lacework-agent:LaceworkAgentLaceworkConfig",
    },
    "lacework-agent.LaceworkAgentLaceworkConfigAnonymizeIncoming": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "LaceworkAgentLaceworkConfigAnonymizeIncoming",
        },
      },
      "fqn": "lacework-agent.LaceworkAgentLaceworkConfigAnonymizeIncoming",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 753,
      },
      "name": "LaceworkAgentLaceworkConfigAnonymizeIncoming",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfigAnonymizeIncoming#additionalValues",
            },
            "summary": "Values that are not available in values.schema.json will not be code generated. You can add such values to this property.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 764,
          },
          "name": "additionalValues",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "any",
              },
              "kind": "map",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfigAnonymizeIncoming#netmask",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 757,
          },
          "name": "netmask",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
      ],
      "symbolId": "lacework-agent:LaceworkAgentLaceworkConfigAnonymizeIncoming",
    },
    "lacework-agent.LaceworkAgentLaceworkConfigAutoUpgrade": Object {
      "assembly": "lacework-agent",
      "docs": Object {
        "custom": Object {
          "schema": "LaceworkAgentLaceworkConfigAutoUpgrade",
        },
      },
      "fqn": "lacework-agent.LaceworkAgentLaceworkConfigAutoUpgrade",
      "kind": "enum",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 771,
      },
      "members": Array [
        Object {
          "docs": Object {
            "summary": "disable.",
          },
          "name": "DISABLE",
        },
        Object {
          "docs": Object {
            "summary": "enable.",
          },
          "name": "ENABLE",
        },
      ],
      "name": "LaceworkAgentLaceworkConfigAutoUpgrade",
      "symbolId": "lacework-agent:LaceworkAgentLaceworkConfigAutoUpgrade",
    },
    "lacework-agent.LaceworkAgentLaceworkConfigCmdlinefilter": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "LaceworkAgentLaceworkConfigCmdlinefilter",
        },
      },
      "fqn": "lacework-agent.LaceworkAgentLaceworkConfigCmdlinefilter",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 781,
      },
      "name": "LaceworkAgentLaceworkConfigCmdlinefilter",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfigCmdlinefilter#allow",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 785,
          },
          "name": "allow",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfigCmdlinefilter#disallow",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 790,
          },
          "name": "disallow",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
      ],
      "symbolId": "lacework-agent:LaceworkAgentLaceworkConfigCmdlinefilter",
    },
    "lacework-agent.LaceworkAgentLaceworkConfigCodeaware": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "LaceworkAgentLaceworkConfigCodeaware",
        },
      },
      "fqn": "lacework-agent.LaceworkAgentLaceworkConfigCodeaware",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 797,
      },
      "name": "LaceworkAgentLaceworkConfigCodeaware",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfigCodeaware#enable",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 801,
          },
          "name": "enable",
          "optional": true,
          "type": Object {
            "primitive": "boolean",
          },
        },
      ],
      "symbolId": "lacework-agent:LaceworkAgentLaceworkConfigCodeaware",
    },
    "lacework-agent.LaceworkAgentLaceworkConfigContainerRuntime": Object {
      "assembly": "lacework-agent",
      "docs": Object {
        "custom": Object {
          "schema": "LaceworkAgentLaceworkConfigContainerRuntime",
        },
      },
      "fqn": "lacework-agent.LaceworkAgentLaceworkConfigContainerRuntime",
      "kind": "enum",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 808,
      },
      "members": Array [
        Object {
          "docs": Object {
            "summary": "containerd.",
          },
          "name": "CONTAINERD",
        },
        Object {
          "docs": Object {
            "summary": "cri-o.",
          },
          "name": "CRI_HYPHEN_O",
        },
        Object {
          "docs": Object {
            "summary": "docker.",
          },
          "name": "DOCKER",
        },
      ],
      "name": "LaceworkAgentLaceworkConfigContainerRuntime",
      "symbolId": "lacework-agent:LaceworkAgentLaceworkConfigContainerRuntime",
    },
    "lacework-agent.LaceworkAgentLaceworkConfigDatacollector": Object {
      "assembly": "lacework-agent",
      "docs": Object {
        "custom": Object {
          "schema": "LaceworkAgentLaceworkConfigDatacollector",
        },
      },
      "fqn": "lacework-agent.LaceworkAgentLaceworkConfigDatacollector",
      "kind": "enum",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 820,
      },
      "members": Array [
        Object {
          "docs": Object {
            "summary": "disable.",
          },
          "name": "DISABLE",
        },
        Object {
          "docs": Object {
            "summary": "enable.",
          },
          "name": "ENABLE",
        },
      ],
      "name": "LaceworkAgentLaceworkConfigDatacollector",
      "symbolId": "lacework-agent:LaceworkAgentLaceworkConfigDatacollector",
    },
    "lacework-agent.LaceworkAgentLaceworkConfigFim": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "LaceworkAgentLaceworkConfigFim",
        },
      },
      "fqn": "lacework-agent.LaceworkAgentLaceworkConfigFim",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 830,
      },
      "name": "LaceworkAgentLaceworkConfigFim",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfigFim#enable",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 844,
          },
          "name": "enable",
          "type": Object {
            "primitive": "boolean",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfigFim#fileIgnore",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 849,
          },
          "name": "fileIgnore",
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "string",
              },
              "kind": "array",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfigFim#filePath",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 854,
          },
          "name": "filePath",
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "string",
              },
              "kind": "array",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfigFim#additionalValues",
            },
            "summary": "Values that are not available in values.schema.json will not be code generated. You can add such values to this property.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 871,
          },
          "name": "additionalValues",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "any",
              },
              "kind": "map",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfigFim#coolingPeriod",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 834,
          },
          "name": "coolingPeriod",
          "optional": true,
          "type": Object {
            "primitive": "number",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfigFim#crawlInterval",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 839,
          },
          "name": "crawlInterval",
          "optional": true,
          "type": Object {
            "primitive": "number",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfigFim#noAtime",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 859,
          },
          "name": "noAtime",
          "optional": true,
          "type": Object {
            "primitive": "boolean",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfigFim#runAt",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 864,
          },
          "name": "runAt",
          "optional": true,
          "type": Object {
            "primitive": "any",
          },
        },
      ],
      "symbolId": "lacework-agent:LaceworkAgentLaceworkConfigFim",
    },
    "lacework-agent.LaceworkAgentLaceworkConfigPackagescan": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "LaceworkAgentLaceworkConfigPackagescan",
        },
      },
      "fqn": "lacework-agent.LaceworkAgentLaceworkConfigPackagescan",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 878,
      },
      "name": "LaceworkAgentLaceworkConfigPackagescan",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfigPackagescan#enable",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 882,
          },
          "name": "enable",
          "optional": true,
          "type": Object {
            "primitive": "boolean",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfigPackagescan#interval",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 887,
          },
          "name": "interval",
          "optional": true,
          "type": Object {
            "primitive": "number",
          },
        },
      ],
      "symbolId": "lacework-agent:LaceworkAgentLaceworkConfigPackagescan",
    },
    "lacework-agent.LaceworkAgentLaceworkConfigPerfmode": Object {
      "assembly": "lacework-agent",
      "docs": Object {
        "custom": Object {
          "schema": "LaceworkAgentLaceworkConfigPerfmode",
        },
      },
      "fqn": "lacework-agent.LaceworkAgentLaceworkConfigPerfmode",
      "kind": "enum",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 910,
      },
      "members": Array [
        Object {
          "docs": Object {
            "summary": "lite.",
          },
          "name": "LITE",
        },
        Object {
          "docs": Object {
            "summary": "scan.",
          },
          "name": "SCAN",
        },
        Object {
          "docs": Object {
            "summary": "ebpflite.",
          },
          "name": "EBPFLITE",
        },
      ],
      "name": "LaceworkAgentLaceworkConfigPerfmode",
      "symbolId": "lacework-agent:LaceworkAgentLaceworkConfigPerfmode",
    },
    "lacework-agent.LaceworkAgentLaceworkConfigProcscan": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "LaceworkAgentLaceworkConfigProcscan",
        },
      },
      "fqn": "lacework-agent.LaceworkAgentLaceworkConfigProcscan",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 894,
      },
      "name": "LaceworkAgentLaceworkConfigProcscan",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfigProcscan#enable",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 898,
          },
          "name": "enable",
          "optional": true,
          "type": Object {
            "primitive": "boolean",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfigProcscan#interval",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 903,
          },
          "name": "interval",
          "optional": true,
          "type": Object {
            "primitive": "number",
          },
        },
      ],
      "symbolId": "lacework-agent:LaceworkAgentLaceworkConfigProcscan",
    },
    "lacework-agent.LaceworkAgentProps": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "fqn": "lacework-agent.LaceworkAgentProps",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 5,
      },
      "name": "LaceworkAgentProps",
      "properties": Array [
        Object {
          "abstract": true,
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 10,
          },
          "name": "values",
          "type": Object {
            "fqn": "lacework-agent.LaceworkAgentValues",
          },
        },
        Object {
          "abstract": true,
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 8,
          },
          "name": "helmExecutable",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 9,
          },
          "name": "helmFlags",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "string",
              },
              "kind": "array",
            },
          },
        },
        Object {
          "abstract": true,
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 6,
          },
          "name": "namespace",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 7,
          },
          "name": "releaseName",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
      ],
      "symbolId": "lacework-agent:LaceworkAgentProps",
    },
    "lacework-agent.LaceworkAgentValues": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "lacework-agent",
        },
      },
      "fqn": "lacework-agent.LaceworkAgentValues",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 66,
      },
      "name": "LaceworkAgentValues",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "lacework-agent#laceworkConfig",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 105,
          },
          "name": "laceworkConfig",
          "type": Object {
            "fqn": "lacework-agent.LaceworkAgentLaceworkConfig",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "lacework-agent#additionalValues",
            },
            "summary": "Values that are not available in values.schema.json will not be code generated. You can add such values to this property.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 154,
          },
          "name": "additionalValues",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "any",
              },
              "kind": "map",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "lacework-agent#cloudservice",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 85,
          },
          "name": "cloudservice",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.LaceworkAgentCloudservice",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "lacework-agent#clusterAgent",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 100,
          },
          "name": "clusterAgent",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.LaceworkAgentClusterAgent",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "lacework-agent#daemonset",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 75,
          },
          "name": "daemonset",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.LaceworkAgentDaemonset",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "lacework-agent#datacollector",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 90,
          },
          "name": "datacollector",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.LaceworkAgentDatacollector",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "lacework-agent#deployment",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 80,
          },
          "name": "deployment",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.LaceworkAgentDeployment",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "lacework-agent#global",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 70,
          },
          "name": "global",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "any",
              },
              "kind": "map",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "lacework-agent#image",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 95,
          },
          "name": "image",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.LaceworkAgentImage",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "lacework-agent#priorityClassCreate",
            },
            "summary": "If specified, a priority class is created and used to deploy agent.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 126,
          },
          "name": "priorityClassCreate",
          "optional": true,
          "type": Object {
            "primitive": "boolean",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "lacework-agent#priorityClassName",
            },
            "remarks": "\\"system-node-critical\\" and \\"system-cluster-critical\\" are two special keywords which indicate the highest priorities with the former being the highest priority. Any other name must be defined by creating a PriorityClass object with that name. If not specified, the pod priority will be default or zero if there is no default.",
            "summary": "If specified, indicates the pod's priority.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 119,
          },
          "name": "priorityClassName",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "lacework-agent#priorityClassPreemptionPolicy",
            },
            "summary": "If specified, it determines if agent pod can preempt a pod with a lower a priority.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 133,
          },
          "name": "priorityClassPreemptionPolicy",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "lacework-agent#priorityClassValue",
            },
            "summary": "If specified, it represents the priority class value to use.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 140,
          },
          "name": "priorityClassValue",
          "optional": true,
          "type": Object {
            "primitive": "number",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "lacework-agent#resources",
            },
            "remarks": "Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/",
            "summary": "Compute Resources required by this container.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 112,
          },
          "name": "resources",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.IoK8SApiCoreV1ResourceRequirements",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "lacework-agent#tolerations",
            },
            "summary": "If specified, the pod's tolerations.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 147,
          },
          "name": "tolerations",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "fqn": "lacework-agent.IoK8SApiCoreV1Toleration",
              },
              "kind": "array",
            },
          },
        },
      ],
      "symbolId": "lacework-agent:LaceworkAgentValues",
    },
  },
  "version": "0.0.0",
}
`;

exports[`importing helm chart helm:https://lacework.github.io/helm-charts/lacework-agent@6.9.0 with python lanugage 2`] = `
Object {
  "lacework_agent/__init__.py": "from pkgutil import extend_path
__path__ = extend_path(__path__, __name__)

import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

import typeguard
from importlib.metadata import version as _metadata_package_version
TYPEGUARD_MAJOR_VERSION = int(_metadata_package_version('typeguard').split('.')[0])

def check_type(argname: str, value: object, expected_type: typing.Any) -> typing.Any:
    if TYPEGUARD_MAJOR_VERSION <= 2:
        return typeguard.check_type(argname=argname, value=value, expected_type=expected_type) # type:ignore
    else:
        if isinstance(value, jsii._reference_map.InterfaceDynamicProxy): # pyright: ignore [reportAttributeAccessIssue]
           pass
        else:
            if TYPEGUARD_MAJOR_VERSION == 3:
                typeguard.config.collection_check_strategy = typeguard.CollectionCheckStrategy.ALL_ITEMS # type:ignore
                typeguard.check_type(value=value, expected_type=expected_type) # type:ignore
            else:
                typeguard.check_type(value=value, expected_type=expected_type, collection_check_strategy=typeguard.CollectionCheckStrategy.ALL_ITEMS) # type:ignore

from ._jsii import *

import constructs as _constructs_77d1e7e8


@jsii.data_type(
    jsii_type=\\"lacework-agent.IoK8SApiCoreV1Affinity\\",
    jsii_struct_bases=[],
    name_mapping={
        \\"node_affinity\\": \\"nodeAffinity\\",
        \\"pod_affinity\\": \\"podAffinity\\",
        \\"pod_anti_affinity\\": \\"podAntiAffinity\\",
    },
)
class IoK8SApiCoreV1Affinity:
    def __init__(
        self,
        *,
        node_affinity: typing.Optional[typing.Union[\\"IoK8SApiCoreV1AffinityNodeAffinity\\", typing.Dict[builtins.str, typing.Any]]] = None,
        pod_affinity: typing.Optional[typing.Union[\\"IoK8SApiCoreV1AffinityPodAffinity\\", typing.Dict[builtins.str, typing.Any]]] = None,
        pod_anti_affinity: typing.Optional[typing.Union[\\"IoK8SApiCoreV1AffinityPodAntiAffinity\\", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Affinity is a group of affinity scheduling rules.

        :param node_affinity: Node affinity is a group of node affinity scheduling rules.
        :param pod_affinity: Pod affinity is a group of inter pod affinity scheduling rules.
        :param pod_anti_affinity: Pod anti affinity is a group of inter pod anti affinity scheduling rules.

        :schema: io.k8s.api.core.v1.Affinity
        '''
        if isinstance(node_affinity, dict):
            node_affinity = IoK8SApiCoreV1AffinityNodeAffinity(**node_affinity)
        if isinstance(pod_affinity, dict):
            pod_affinity = IoK8SApiCoreV1AffinityPodAffinity(**pod_affinity)
        if isinstance(pod_anti_affinity, dict):
            pod_anti_affinity = IoK8SApiCoreV1AffinityPodAntiAffinity(**pod_anti_affinity)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dcbd3c1d64c57915cdfe4d3e9c252dc593c38b7af2c271606308ad2dd0688fca)
            check_type(argname=\\"argument node_affinity\\", value=node_affinity, expected_type=type_hints[\\"node_affinity\\"])
            check_type(argname=\\"argument pod_affinity\\", value=pod_affinity, expected_type=type_hints[\\"pod_affinity\\"])
            check_type(argname=\\"argument pod_anti_affinity\\", value=pod_anti_affinity, expected_type=type_hints[\\"pod_anti_affinity\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if node_affinity is not None:
            self._values[\\"node_affinity\\"] = node_affinity
        if pod_affinity is not None:
            self._values[\\"pod_affinity\\"] = pod_affinity
        if pod_anti_affinity is not None:
            self._values[\\"pod_anti_affinity\\"] = pod_anti_affinity

    @builtins.property
    def node_affinity(self) -> typing.Optional[\\"IoK8SApiCoreV1AffinityNodeAffinity\\"]:
        '''Node affinity is a group of node affinity scheduling rules.

        :schema: io.k8s.api.core.v1.Affinity#nodeAffinity
        '''
        result = self._values.get(\\"node_affinity\\")
        return typing.cast(typing.Optional[\\"IoK8SApiCoreV1AffinityNodeAffinity\\"], result)

    @builtins.property
    def pod_affinity(self) -> typing.Optional[\\"IoK8SApiCoreV1AffinityPodAffinity\\"]:
        '''Pod affinity is a group of inter pod affinity scheduling rules.

        :schema: io.k8s.api.core.v1.Affinity#podAffinity
        '''
        result = self._values.get(\\"pod_affinity\\")
        return typing.cast(typing.Optional[\\"IoK8SApiCoreV1AffinityPodAffinity\\"], result)

    @builtins.property
    def pod_anti_affinity(
        self,
    ) -> typing.Optional[\\"IoK8SApiCoreV1AffinityPodAntiAffinity\\"]:
        '''Pod anti affinity is a group of inter pod anti affinity scheduling rules.

        :schema: io.k8s.api.core.v1.Affinity#podAntiAffinity
        '''
        result = self._values.get(\\"pod_anti_affinity\\")
        return typing.cast(typing.Optional[\\"IoK8SApiCoreV1AffinityPodAntiAffinity\\"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"IoK8SApiCoreV1Affinity(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type=\\"lacework-agent.IoK8SApiCoreV1AffinityNodeAffinity\\",
    jsii_struct_bases=[],
    name_mapping={
        \\"preferred_during_scheduling_ignored_during_execution\\": \\"preferredDuringSchedulingIgnoredDuringExecution\\",
        \\"required_during_scheduling_ignored_during_execution\\": \\"requiredDuringSchedulingIgnoredDuringExecution\\",
    },
)
class IoK8SApiCoreV1AffinityNodeAffinity:
    def __init__(
        self,
        *,
        preferred_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union[\\"IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution\\", typing.Dict[builtins.str, typing.Any]]]] = None,
        required_during_scheduling_ignored_during_execution: typing.Optional[typing.Union[\\"IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution\\", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Node affinity is a group of node affinity scheduling rules.

        :param preferred_during_scheduling_ignored_during_execution: The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding \\"weight\\" to the sum if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the most preferred.
        :param required_during_scheduling_ignored_during_execution: A node selector represents the union of the results of one or more label queries over a set of nodes; that is, it represents the OR of the selectors represented by the node selector terms.

        :schema: IoK8SApiCoreV1AffinityNodeAffinity
        '''
        if isinstance(required_during_scheduling_ignored_during_execution, dict):
            required_during_scheduling_ignored_during_execution = IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(**required_during_scheduling_ignored_during_execution)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__83fb7082ba953b5b9e787cc0ee59a9bef2197db6a48b11240fdf117606315a5a)
            check_type(argname=\\"argument preferred_during_scheduling_ignored_during_execution\\", value=preferred_during_scheduling_ignored_during_execution, expected_type=type_hints[\\"preferred_during_scheduling_ignored_during_execution\\"])
            check_type(argname=\\"argument required_during_scheduling_ignored_during_execution\\", value=required_during_scheduling_ignored_during_execution, expected_type=type_hints[\\"required_during_scheduling_ignored_during_execution\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if preferred_during_scheduling_ignored_during_execution is not None:
            self._values[\\"preferred_during_scheduling_ignored_during_execution\\"] = preferred_during_scheduling_ignored_during_execution
        if required_during_scheduling_ignored_during_execution is not None:
            self._values[\\"required_during_scheduling_ignored_during_execution\\"] = required_during_scheduling_ignored_during_execution

    @builtins.property
    def preferred_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[typing.List[\\"IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution\\"]]:
        '''The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions.

        The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding \\"weight\\" to the sum if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the most preferred.

        :schema: IoK8SApiCoreV1AffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get(\\"preferred_during_scheduling_ignored_during_execution\\")
        return typing.cast(typing.Optional[typing.List[\\"IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution\\"]], result)

    @builtins.property
    def required_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[\\"IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution\\"]:
        '''A node selector represents the union of the results of one or more label queries over a set of nodes;

        that is, it represents the OR of the selectors represented by the node selector terms.

        :schema: IoK8SApiCoreV1AffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get(\\"required_during_scheduling_ignored_during_execution\\")
        return typing.cast(typing.Optional[\\"IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution\\"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"IoK8SApiCoreV1AffinityNodeAffinity(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type=\\"lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution\\",
    jsii_struct_bases=[],
    name_mapping={\\"preference\\": \\"preference\\", \\"weight\\": \\"weight\\"},
)
class IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        preference: typing.Optional[typing.Union[\\"IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference\\", typing.Dict[builtins.str, typing.Any]]] = None,
        weight: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''An empty preferred scheduling term matches all objects with implicit weight 0 (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).

        :param preference: A null or empty node selector term matches no objects. The requirements of them are ANDed. The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
        :param weight: Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.

        :schema: IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
        '''
        if isinstance(preference, dict):
            preference = IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(**preference)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3bc3a7ad7604790369045dfb4698addef29a8a8a6153811d9f7dd8f99e3ee359)
            check_type(argname=\\"argument preference\\", value=preference, expected_type=type_hints[\\"preference\\"])
            check_type(argname=\\"argument weight\\", value=weight, expected_type=type_hints[\\"weight\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if preference is not None:
            self._values[\\"preference\\"] = preference
        if weight is not None:
            self._values[\\"weight\\"] = weight

    @builtins.property
    def preference(
        self,
    ) -> typing.Optional[\\"IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference\\"]:
        '''A null or empty node selector term matches no objects.

        The requirements of them are ANDed. The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.

        :schema: IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
        '''
        result = self._values.get(\\"preference\\")
        return typing.cast(typing.Optional[\\"IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference\\"], result)

    @builtins.property
    def weight(self) -> typing.Optional[jsii.Number]:
        '''Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.

        :schema: IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
        '''
        result = self._values.get(\\"weight\\")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type=\\"lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference\\",
    jsii_struct_bases=[],
    name_mapping={
        \\"match_expressions\\": \\"matchExpressions\\",
        \\"match_fields\\": \\"matchFields\\",
    },
)
class IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union[\\"IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions\\", typing.Dict[builtins.str, typing.Any]]]] = None,
        match_fields: typing.Optional[typing.Sequence[typing.Union[\\"IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields\\", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''A null or empty node selector term matches no objects.

        The requirements of them are ANDed. The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.

        :param match_expressions: A list of node selector requirements by node's labels.
        :param match_fields: A list of node selector requirements by node's fields.

        :schema: IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__41dee617dee988ead026c7bad2ebb4fae531007cc7f48f0db25cfa20dca41762)
            check_type(argname=\\"argument match_expressions\\", value=match_expressions, expected_type=type_hints[\\"match_expressions\\"])
            check_type(argname=\\"argument match_fields\\", value=match_fields, expected_type=type_hints[\\"match_fields\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if match_expressions is not None:
            self._values[\\"match_expressions\\"] = match_expressions
        if match_fields is not None:
            self._values[\\"match_fields\\"] = match_fields

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List[\\"IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions\\"]]:
        '''A list of node selector requirements by node's labels.

        :schema: IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
        '''
        result = self._values.get(\\"match_expressions\\")
        return typing.cast(typing.Optional[typing.List[\\"IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions\\"]], result)

    @builtins.property
    def match_fields(
        self,
    ) -> typing.Optional[typing.List[\\"IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields\\"]]:
        '''A list of node selector requirements by node's fields.

        :schema: IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
        '''
        result = self._values.get(\\"match_fields\\")
        return typing.cast(typing.Optional[typing.List[\\"IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields\\"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type=\\"lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions\\",
    jsii_struct_bases=[],
    name_mapping={\\"key\\": \\"key\\", \\"operator\\": \\"operator\\", \\"values\\": \\"values\\"},
)
class IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        operator: typing.Optional[\\"IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOperator\\"] = None,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.

        :param key: The label key that the selector applies to.
        :param operator: Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt. Possible enum values: - \`\`\\"DoesNotExist\\"\`\` - \`\`\\"Exists\\"\`\` - \`\`\\"Gt\\"\`\` - \`\`\\"In\\"\`\` - \`\`\\"Lt\\"\`\` - \`\`\\"NotIn\\"\`\`
        :param values: An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.

        :schema: IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3730cdd540fb8e7d48cf1be08570870a521033bbdb76cecc74c8fb287aebc010)
            check_type(argname=\\"argument key\\", value=key, expected_type=type_hints[\\"key\\"])
            check_type(argname=\\"argument operator\\", value=operator, expected_type=type_hints[\\"operator\\"])
            check_type(argname=\\"argument values\\", value=values, expected_type=type_hints[\\"values\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values[\\"key\\"] = key
        if operator is not None:
            self._values[\\"operator\\"] = operator
        if values is not None:
            self._values[\\"values\\"] = values

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The label key that the selector applies to.

        :schema: IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
        '''
        result = self._values.get(\\"key\\")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def operator(
        self,
    ) -> typing.Optional[\\"IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOperator\\"]:
        '''Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.

        Possible enum values:

        - \`\`\\"DoesNotExist\\"\`\`
        - \`\`\\"Exists\\"\`\`
        - \`\`\\"Gt\\"\`\`
        - \`\`\\"In\\"\`\`
        - \`\`\\"Lt\\"\`\`
        - \`\`\\"NotIn\\"\`\`

        :schema: IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
        '''
        result = self._values.get(\\"operator\\")
        return typing.cast(typing.Optional[\\"IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOperator\\"], result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''An array of string values.

        If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.

        :schema: IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
        '''
        result = self._values.get(\\"values\\")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type=\\"lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOperator\\"
)
class IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOperator(
    enum.Enum,
):
    '''Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.

    Possible enum values:

    - \`\`\\"DoesNotExist\\"\`\`
    - \`\`\\"Exists\\"\`\`
    - \`\`\\"Gt\\"\`\`
    - \`\`\\"In\\"\`\`
    - \`\`\\"Lt\\"\`\`
    - \`\`\\"NotIn\\"\`\`

    :schema: IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOperator
    '''

    DOES_NOT_EXIST = \\"DOES_NOT_EXIST\\"
    '''DoesNotExist.'''
    EXISTS = \\"EXISTS\\"
    '''Exists.'''
    GT = \\"GT\\"
    '''Gt.'''
    IN = \\"IN\\"
    '''In.'''
    LT = \\"LT\\"
    '''Lt.'''
    NOT_IN = \\"NOT_IN\\"
    '''NotIn.'''


@jsii.data_type(
    jsii_type=\\"lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields\\",
    jsii_struct_bases=[],
    name_mapping={\\"key\\": \\"key\\", \\"operator\\": \\"operator\\", \\"values\\": \\"values\\"},
)
class IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        operator: typing.Optional[\\"IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOperator\\"] = None,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.

        :param key: The label key that the selector applies to.
        :param operator: Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt. Possible enum values: - \`\`\\"DoesNotExist\\"\`\` - \`\`\\"Exists\\"\`\` - \`\`\\"Gt\\"\`\` - \`\`\\"In\\"\`\` - \`\`\\"Lt\\"\`\` - \`\`\\"NotIn\\"\`\`
        :param values: An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.

        :schema: IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7b9dade3151f99e1afdce33c41e3c8dd8d3c83a16e10b28ddaf5ea28a3e22ada)
            check_type(argname=\\"argument key\\", value=key, expected_type=type_hints[\\"key\\"])
            check_type(argname=\\"argument operator\\", value=operator, expected_type=type_hints[\\"operator\\"])
            check_type(argname=\\"argument values\\", value=values, expected_type=type_hints[\\"values\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values[\\"key\\"] = key
        if operator is not None:
            self._values[\\"operator\\"] = operator
        if values is not None:
            self._values[\\"values\\"] = values

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The label key that the selector applies to.

        :schema: IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
        '''
        result = self._values.get(\\"key\\")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def operator(
        self,
    ) -> typing.Optional[\\"IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOperator\\"]:
        '''Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.

        Possible enum values:

        - \`\`\\"DoesNotExist\\"\`\`
        - \`\`\\"Exists\\"\`\`
        - \`\`\\"Gt\\"\`\`
        - \`\`\\"In\\"\`\`
        - \`\`\\"Lt\\"\`\`
        - \`\`\\"NotIn\\"\`\`

        :schema: IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
        '''
        result = self._values.get(\\"operator\\")
        return typing.cast(typing.Optional[\\"IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOperator\\"], result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''An array of string values.

        If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.

        :schema: IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
        '''
        result = self._values.get(\\"values\\")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type=\\"lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOperator\\"
)
class IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOperator(
    enum.Enum,
):
    '''Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.

    Possible enum values:

    - \`\`\\"DoesNotExist\\"\`\`
    - \`\`\\"Exists\\"\`\`
    - \`\`\\"Gt\\"\`\`
    - \`\`\\"In\\"\`\`
    - \`\`\\"Lt\\"\`\`
    - \`\`\\"NotIn\\"\`\`

    :schema: IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOperator
    '''

    DOES_NOT_EXIST = \\"DOES_NOT_EXIST\\"
    '''DoesNotExist.'''
    EXISTS = \\"EXISTS\\"
    '''Exists.'''
    GT = \\"GT\\"
    '''Gt.'''
    IN = \\"IN\\"
    '''In.'''
    LT = \\"LT\\"
    '''Lt.'''
    NOT_IN = \\"NOT_IN\\"
    '''NotIn.'''


@jsii.data_type(
    jsii_type=\\"lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution\\",
    jsii_struct_bases=[],
    name_mapping={\\"node_selector_terms\\": \\"nodeSelectorTerms\\"},
)
class IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        node_selector_terms: typing.Optional[typing.Sequence[typing.Union[\\"IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms\\", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''A node selector represents the union of the results of one or more label queries over a set of nodes;

        that is, it represents the OR of the selectors represented by the node selector terms.

        :param node_selector_terms: Required. A list of node selector terms. The terms are ORed.

        :schema: IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9acfa843b7229c0e9ad74630682849efa291d2c9468e4afb8a72503609d4a5d6)
            check_type(argname=\\"argument node_selector_terms\\", value=node_selector_terms, expected_type=type_hints[\\"node_selector_terms\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if node_selector_terms is not None:
            self._values[\\"node_selector_terms\\"] = node_selector_terms

    @builtins.property
    def node_selector_terms(
        self,
    ) -> typing.Optional[typing.List[\\"IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms\\"]]:
        '''Required.

        A list of node selector terms. The terms are ORed.

        :schema: IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
        '''
        result = self._values.get(\\"node_selector_terms\\")
        return typing.cast(typing.Optional[typing.List[\\"IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms\\"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type=\\"lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms\\",
    jsii_struct_bases=[],
    name_mapping={
        \\"match_expressions\\": \\"matchExpressions\\",
        \\"match_fields\\": \\"matchFields\\",
    },
)
class IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union[\\"IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions\\", typing.Dict[builtins.str, typing.Any]]]] = None,
        match_fields: typing.Optional[typing.Sequence[typing.Union[\\"IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields\\", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''A null or empty node selector term matches no objects.

        The requirements of them are ANDed. The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.

        :param match_expressions: A list of node selector requirements by node's labels.
        :param match_fields: A list of node selector requirements by node's fields.

        :schema: IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2985f1fb46d7d123a1304f37a4bdd1cb669f518ddebf14def78cd809166f7135)
            check_type(argname=\\"argument match_expressions\\", value=match_expressions, expected_type=type_hints[\\"match_expressions\\"])
            check_type(argname=\\"argument match_fields\\", value=match_fields, expected_type=type_hints[\\"match_fields\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if match_expressions is not None:
            self._values[\\"match_expressions\\"] = match_expressions
        if match_fields is not None:
            self._values[\\"match_fields\\"] = match_fields

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List[\\"IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions\\"]]:
        '''A list of node selector requirements by node's labels.

        :schema: IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
        '''
        result = self._values.get(\\"match_expressions\\")
        return typing.cast(typing.Optional[typing.List[\\"IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions\\"]], result)

    @builtins.property
    def match_fields(
        self,
    ) -> typing.Optional[typing.List[\\"IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields\\"]]:
        '''A list of node selector requirements by node's fields.

        :schema: IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
        '''
        result = self._values.get(\\"match_fields\\")
        return typing.cast(typing.Optional[typing.List[\\"IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields\\"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type=\\"lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions\\",
    jsii_struct_bases=[],
    name_mapping={\\"key\\": \\"key\\", \\"operator\\": \\"operator\\", \\"values\\": \\"values\\"},
)
class IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        operator: typing.Optional[\\"IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOperator\\"] = None,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.

        :param key: The label key that the selector applies to.
        :param operator: Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt. Possible enum values: - \`\`\\"DoesNotExist\\"\`\` - \`\`\\"Exists\\"\`\` - \`\`\\"Gt\\"\`\` - \`\`\\"In\\"\`\` - \`\`\\"Lt\\"\`\` - \`\`\\"NotIn\\"\`\`
        :param values: An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.

        :schema: IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2eef7443ccd6b5aaac15c30182a3aaae735d74ec9a15de2a348964115b0f1bad)
            check_type(argname=\\"argument key\\", value=key, expected_type=type_hints[\\"key\\"])
            check_type(argname=\\"argument operator\\", value=operator, expected_type=type_hints[\\"operator\\"])
            check_type(argname=\\"argument values\\", value=values, expected_type=type_hints[\\"values\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values[\\"key\\"] = key
        if operator is not None:
            self._values[\\"operator\\"] = operator
        if values is not None:
            self._values[\\"values\\"] = values

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The label key that the selector applies to.

        :schema: IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
        '''
        result = self._values.get(\\"key\\")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def operator(
        self,
    ) -> typing.Optional[\\"IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOperator\\"]:
        '''Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.

        Possible enum values:

        - \`\`\\"DoesNotExist\\"\`\`
        - \`\`\\"Exists\\"\`\`
        - \`\`\\"Gt\\"\`\`
        - \`\`\\"In\\"\`\`
        - \`\`\\"Lt\\"\`\`
        - \`\`\\"NotIn\\"\`\`

        :schema: IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
        '''
        result = self._values.get(\\"operator\\")
        return typing.cast(typing.Optional[\\"IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOperator\\"], result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''An array of string values.

        If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.

        :schema: IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
        '''
        result = self._values.get(\\"values\\")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type=\\"lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOperator\\"
)
class IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOperator(
    enum.Enum,
):
    '''Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.

    Possible enum values:

    - \`\`\\"DoesNotExist\\"\`\`
    - \`\`\\"Exists\\"\`\`
    - \`\`\\"Gt\\"\`\`
    - \`\`\\"In\\"\`\`
    - \`\`\\"Lt\\"\`\`
    - \`\`\\"NotIn\\"\`\`

    :schema: IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOperator
    '''

    DOES_NOT_EXIST = \\"DOES_NOT_EXIST\\"
    '''DoesNotExist.'''
    EXISTS = \\"EXISTS\\"
    '''Exists.'''
    GT = \\"GT\\"
    '''Gt.'''
    IN = \\"IN\\"
    '''In.'''
    LT = \\"LT\\"
    '''Lt.'''
    NOT_IN = \\"NOT_IN\\"
    '''NotIn.'''


@jsii.data_type(
    jsii_type=\\"lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields\\",
    jsii_struct_bases=[],
    name_mapping={\\"key\\": \\"key\\", \\"operator\\": \\"operator\\", \\"values\\": \\"values\\"},
)
class IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        operator: typing.Optional[\\"IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOperator\\"] = None,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.

        :param key: The label key that the selector applies to.
        :param operator: Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt. Possible enum values: - \`\`\\"DoesNotExist\\"\`\` - \`\`\\"Exists\\"\`\` - \`\`\\"Gt\\"\`\` - \`\`\\"In\\"\`\` - \`\`\\"Lt\\"\`\` - \`\`\\"NotIn\\"\`\`
        :param values: An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.

        :schema: IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9ec67c499846b6a293071ecb3ec3a0f941758830e6820225b2170274524e6b3a)
            check_type(argname=\\"argument key\\", value=key, expected_type=type_hints[\\"key\\"])
            check_type(argname=\\"argument operator\\", value=operator, expected_type=type_hints[\\"operator\\"])
            check_type(argname=\\"argument values\\", value=values, expected_type=type_hints[\\"values\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values[\\"key\\"] = key
        if operator is not None:
            self._values[\\"operator\\"] = operator
        if values is not None:
            self._values[\\"values\\"] = values

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The label key that the selector applies to.

        :schema: IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
        '''
        result = self._values.get(\\"key\\")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def operator(
        self,
    ) -> typing.Optional[\\"IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOperator\\"]:
        '''Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.

        Possible enum values:

        - \`\`\\"DoesNotExist\\"\`\`
        - \`\`\\"Exists\\"\`\`
        - \`\`\\"Gt\\"\`\`
        - \`\`\\"In\\"\`\`
        - \`\`\\"Lt\\"\`\`
        - \`\`\\"NotIn\\"\`\`

        :schema: IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
        '''
        result = self._values.get(\\"operator\\")
        return typing.cast(typing.Optional[\\"IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOperator\\"], result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''An array of string values.

        If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.

        :schema: IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
        '''
        result = self._values.get(\\"values\\")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type=\\"lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOperator\\"
)
class IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOperator(
    enum.Enum,
):
    '''Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.

    Possible enum values:

    - \`\`\\"DoesNotExist\\"\`\`
    - \`\`\\"Exists\\"\`\`
    - \`\`\\"Gt\\"\`\`
    - \`\`\\"In\\"\`\`
    - \`\`\\"Lt\\"\`\`
    - \`\`\\"NotIn\\"\`\`

    :schema: IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOperator
    '''

    DOES_NOT_EXIST = \\"DOES_NOT_EXIST\\"
    '''DoesNotExist.'''
    EXISTS = \\"EXISTS\\"
    '''Exists.'''
    GT = \\"GT\\"
    '''Gt.'''
    IN = \\"IN\\"
    '''In.'''
    LT = \\"LT\\"
    '''Lt.'''
    NOT_IN = \\"NOT_IN\\"
    '''NotIn.'''


@jsii.data_type(
    jsii_type=\\"lacework-agent.IoK8SApiCoreV1AffinityPodAffinity\\",
    jsii_struct_bases=[],
    name_mapping={
        \\"preferred_during_scheduling_ignored_during_execution\\": \\"preferredDuringSchedulingIgnoredDuringExecution\\",
        \\"required_during_scheduling_ignored_during_execution\\": \\"requiredDuringSchedulingIgnoredDuringExecution\\",
    },
)
class IoK8SApiCoreV1AffinityPodAffinity:
    def __init__(
        self,
        *,
        preferred_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union[\\"IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution\\", typing.Dict[builtins.str, typing.Any]]]] = None,
        required_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union[\\"IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution\\", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Pod affinity is a group of inter pod affinity scheduling rules.

        :param preferred_during_scheduling_ignored_during_execution: The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding \\"weight\\" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
        :param required_during_scheduling_ignored_during_execution: If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.

        :schema: IoK8SApiCoreV1AffinityPodAffinity
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ecd2363c495f3d762f767f20f3b220c8eb4d1138684a8c2cf0ffa57e67d7aeeb)
            check_type(argname=\\"argument preferred_during_scheduling_ignored_during_execution\\", value=preferred_during_scheduling_ignored_during_execution, expected_type=type_hints[\\"preferred_during_scheduling_ignored_during_execution\\"])
            check_type(argname=\\"argument required_during_scheduling_ignored_during_execution\\", value=required_during_scheduling_ignored_during_execution, expected_type=type_hints[\\"required_during_scheduling_ignored_during_execution\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if preferred_during_scheduling_ignored_during_execution is not None:
            self._values[\\"preferred_during_scheduling_ignored_during_execution\\"] = preferred_during_scheduling_ignored_during_execution
        if required_during_scheduling_ignored_during_execution is not None:
            self._values[\\"required_during_scheduling_ignored_during_execution\\"] = required_during_scheduling_ignored_during_execution

    @builtins.property
    def preferred_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[typing.List[\\"IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution\\"]]:
        '''The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions.

        The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding \\"weight\\" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.

        :schema: IoK8SApiCoreV1AffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get(\\"preferred_during_scheduling_ignored_during_execution\\")
        return typing.cast(typing.Optional[typing.List[\\"IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution\\"]], result)

    @builtins.property
    def required_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[typing.List[\\"IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution\\"]]:
        '''If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node.

        If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.

        :schema: IoK8SApiCoreV1AffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get(\\"required_during_scheduling_ignored_during_execution\\")
        return typing.cast(typing.Optional[typing.List[\\"IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution\\"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"IoK8SApiCoreV1AffinityPodAffinity(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type=\\"lacework-agent.IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution\\",
    jsii_struct_bases=[],
    name_mapping={\\"pod_affinity_term\\": \\"podAffinityTerm\\", \\"weight\\": \\"weight\\"},
)
class IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        pod_affinity_term: typing.Optional[typing.Union[\\"IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm\\", typing.Dict[builtins.str, typing.Any]]] = None,
        weight: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s).

        :param pod_affinity_term: Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key matches that of any node on which a pod of the set of pods is running.
        :param weight: weight associated with matching the corresponding podAffinityTerm, in the range 1-100.

        :schema: IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
        '''
        if isinstance(pod_affinity_term, dict):
            pod_affinity_term = IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(**pod_affinity_term)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__73fb8396890742e720d837189aebf4ac5e0bc16c2f01edcaf5364c545a74c0a1)
            check_type(argname=\\"argument pod_affinity_term\\", value=pod_affinity_term, expected_type=type_hints[\\"pod_affinity_term\\"])
            check_type(argname=\\"argument weight\\", value=weight, expected_type=type_hints[\\"weight\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if pod_affinity_term is not None:
            self._values[\\"pod_affinity_term\\"] = pod_affinity_term
        if weight is not None:
            self._values[\\"weight\\"] = weight

    @builtins.property
    def pod_affinity_term(
        self,
    ) -> typing.Optional[\\"IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm\\"]:
        '''Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key  matches that of any node on which a pod of the set of pods is running.

        :schema: IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
        '''
        result = self._values.get(\\"pod_affinity_term\\")
        return typing.cast(typing.Optional[\\"IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm\\"], result)

    @builtins.property
    def weight(self) -> typing.Optional[jsii.Number]:
        '''weight associated with matching the corresponding podAffinityTerm, in the range 1-100.

        :schema: IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
        '''
        result = self._values.get(\\"weight\\")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type=\\"lacework-agent.IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm\\",
    jsii_struct_bases=[],
    name_mapping={
        \\"topology_key\\": \\"topologyKey\\",
        \\"label_selector\\": \\"labelSelector\\",
        \\"namespaces\\": \\"namespaces\\",
        \\"namespace_selector\\": \\"namespaceSelector\\",
    },
)
class IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm:
    def __init__(
        self,
        *,
        topology_key: builtins.str,
        label_selector: typing.Optional[typing.Union[\\"IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector\\", typing.Dict[builtins.str, typing.Any]]] = None,
        namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace_selector: typing.Optional[typing.Union[\\"IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector\\", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key  matches that of any node on which a pod of the set of pods is running.

        :param topology_key: This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
        :param label_selector: A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
        :param namespaces: namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means \\"this pod's namespace\\".
        :param namespace_selector: A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.

        :schema: IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
        '''
        if isinstance(label_selector, dict):
            label_selector = IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(**label_selector)
        if isinstance(namespace_selector, dict):
            namespace_selector = IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(**namespace_selector)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b8dcc9ff575d6ba789f0a4bf1a9431102f18c195a13405596170979aca3a6cb2)
            check_type(argname=\\"argument topology_key\\", value=topology_key, expected_type=type_hints[\\"topology_key\\"])
            check_type(argname=\\"argument label_selector\\", value=label_selector, expected_type=type_hints[\\"label_selector\\"])
            check_type(argname=\\"argument namespaces\\", value=namespaces, expected_type=type_hints[\\"namespaces\\"])
            check_type(argname=\\"argument namespace_selector\\", value=namespace_selector, expected_type=type_hints[\\"namespace_selector\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            \\"topology_key\\": topology_key,
        }
        if label_selector is not None:
            self._values[\\"label_selector\\"] = label_selector
        if namespaces is not None:
            self._values[\\"namespaces\\"] = namespaces
        if namespace_selector is not None:
            self._values[\\"namespace_selector\\"] = namespace_selector

    @builtins.property
    def topology_key(self) -> builtins.str:
        '''This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running.

        Empty topologyKey is not allowed.

        :schema: IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
        '''
        result = self._values.get(\\"topology_key\\")
        assert result is not None, \\"Required property 'topology_key' is missing\\"
        return typing.cast(builtins.str, result)

    @builtins.property
    def label_selector(
        self,
    ) -> typing.Optional[\\"IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector\\"]:
        '''A label selector is a label query over a set of resources.

        The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.

        :schema: IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
        '''
        result = self._values.get(\\"label_selector\\")
        return typing.cast(typing.Optional[\\"IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector\\"], result)

    @builtins.property
    def namespaces(self) -> typing.Optional[typing.List[builtins.str]]:
        '''namespaces specifies a static list of namespace names that the term applies to.

        The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means \\"this pod's namespace\\".

        :schema: IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
        '''
        result = self._values.get(\\"namespaces\\")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace_selector(
        self,
    ) -> typing.Optional[\\"IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector\\"]:
        '''A label selector is a label query over a set of resources.

        The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.

        :schema: IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
        '''
        result = self._values.get(\\"namespace_selector\\")
        return typing.cast(typing.Optional[\\"IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector\\"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type=\\"lacework-agent.IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector\\",
    jsii_struct_bases=[],
    name_mapping={
        \\"match_expressions\\": \\"matchExpressions\\",
        \\"match_labels\\": \\"matchLabels\\",
    },
)
class IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union[\\"IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions\\", typing.Dict[builtins.str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''A label selector is a label query over a set of resources.

        The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.

        :param match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \\"key\\", the operator is \\"In\\", and the values array contains only \\"value\\". The requirements are ANDed.

        :schema: IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__40cfaac301cd989c2a2863d9bcefa06dbd6fbab7916f86ca78ccf892347ffafb)
            check_type(argname=\\"argument match_expressions\\", value=match_expressions, expected_type=type_hints[\\"match_expressions\\"])
            check_type(argname=\\"argument match_labels\\", value=match_labels, expected_type=type_hints[\\"match_labels\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if match_expressions is not None:
            self._values[\\"match_expressions\\"] = match_expressions
        if match_labels is not None:
            self._values[\\"match_labels\\"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List[\\"IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions\\"]]:
        '''matchExpressions is a list of label selector requirements.

        The requirements are ANDed.

        :schema: IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
        '''
        result = self._values.get(\\"match_expressions\\")
        return typing.cast(typing.Optional[typing.List[\\"IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions\\"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''matchLabels is a map of {key,value} pairs.

        A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \\"key\\", the operator is \\"In\\", and the values array contains only \\"value\\". The requirements are ANDed.

        :schema: IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
        '''
        result = self._values.get(\\"match_labels\\")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type=\\"lacework-agent.IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions\\",
    jsii_struct_bases=[],
    name_mapping={\\"key\\": \\"key\\", \\"operator\\": \\"operator\\", \\"values\\": \\"values\\"},
)
class IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        operator: typing.Optional[builtins.str] = None,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.

        :param key: key is the label key that the selector applies to.
        :param operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.

        :schema: IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2b198777efafa2bcf798a86663d42e7d69dea513909618f4a7ba62c47966529f)
            check_type(argname=\\"argument key\\", value=key, expected_type=type_hints[\\"key\\"])
            check_type(argname=\\"argument operator\\", value=operator, expected_type=type_hints[\\"operator\\"])
            check_type(argname=\\"argument values\\", value=values, expected_type=type_hints[\\"values\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values[\\"key\\"] = key
        if operator is not None:
            self._values[\\"operator\\"] = operator
        if values is not None:
            self._values[\\"values\\"] = values

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''key is the label key that the selector applies to.

        :schema: IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
        '''
        result = self._values.get(\\"key\\")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def operator(self) -> typing.Optional[builtins.str]:
        '''operator represents a key's relationship to a set of values.

        Valid operators are In, NotIn, Exists and DoesNotExist.

        :schema: IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
        '''
        result = self._values.get(\\"operator\\")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''values is an array of string values.

        If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.

        :schema: IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
        '''
        result = self._values.get(\\"values\\")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type=\\"lacework-agent.IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector\\",
    jsii_struct_bases=[],
    name_mapping={
        \\"match_expressions\\": \\"matchExpressions\\",
        \\"match_labels\\": \\"matchLabels\\",
    },
)
class IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union[\\"IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions\\", typing.Dict[builtins.str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''A label selector is a label query over a set of resources.

        The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.

        :param match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \\"key\\", the operator is \\"In\\", and the values array contains only \\"value\\". The requirements are ANDed.

        :schema: IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1d7a88051a5ab512c4e0d9b5fbed96bb1f36fd6ae3201420ace8e2be23a019b2)
            check_type(argname=\\"argument match_expressions\\", value=match_expressions, expected_type=type_hints[\\"match_expressions\\"])
            check_type(argname=\\"argument match_labels\\", value=match_labels, expected_type=type_hints[\\"match_labels\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if match_expressions is not None:
            self._values[\\"match_expressions\\"] = match_expressions
        if match_labels is not None:
            self._values[\\"match_labels\\"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List[\\"IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions\\"]]:
        '''matchExpressions is a list of label selector requirements.

        The requirements are ANDed.

        :schema: IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
        '''
        result = self._values.get(\\"match_expressions\\")
        return typing.cast(typing.Optional[typing.List[\\"IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions\\"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''matchLabels is a map of {key,value} pairs.

        A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \\"key\\", the operator is \\"In\\", and the values array contains only \\"value\\". The requirements are ANDed.

        :schema: IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
        '''
        result = self._values.get(\\"match_labels\\")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type=\\"lacework-agent.IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions\\",
    jsii_struct_bases=[],
    name_mapping={\\"key\\": \\"key\\", \\"operator\\": \\"operator\\", \\"values\\": \\"values\\"},
)
class IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        operator: typing.Optional[builtins.str] = None,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.

        :param key: key is the label key that the selector applies to.
        :param operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.

        :schema: IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bbd3a72a8cffc689f71da929f6797f32d6f852fa2e1e9d97277ed0eddeaad132)
            check_type(argname=\\"argument key\\", value=key, expected_type=type_hints[\\"key\\"])
            check_type(argname=\\"argument operator\\", value=operator, expected_type=type_hints[\\"operator\\"])
            check_type(argname=\\"argument values\\", value=values, expected_type=type_hints[\\"values\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values[\\"key\\"] = key
        if operator is not None:
            self._values[\\"operator\\"] = operator
        if values is not None:
            self._values[\\"values\\"] = values

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''key is the label key that the selector applies to.

        :schema: IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
        '''
        result = self._values.get(\\"key\\")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def operator(self) -> typing.Optional[builtins.str]:
        '''operator represents a key's relationship to a set of values.

        Valid operators are In, NotIn, Exists and DoesNotExist.

        :schema: IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
        '''
        result = self._values.get(\\"operator\\")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''values is an array of string values.

        If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.

        :schema: IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
        '''
        result = self._values.get(\\"values\\")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type=\\"lacework-agent.IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution\\",
    jsii_struct_bases=[],
    name_mapping={
        \\"label_selector\\": \\"labelSelector\\",
        \\"namespaces\\": \\"namespaces\\",
        \\"namespace_selector\\": \\"namespaceSelector\\",
        \\"topology_key\\": \\"topologyKey\\",
    },
)
class IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        label_selector: typing.Optional[typing.Union[\\"IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector\\", typing.Dict[builtins.str, typing.Any]]] = None,
        namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace_selector: typing.Optional[typing.Union[\\"IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector\\", typing.Dict[builtins.str, typing.Any]]] = None,
        topology_key: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key  matches that of any node on which a pod of the set of pods is running.

        :param label_selector: A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
        :param namespaces: namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means \\"this pod's namespace\\".
        :param namespace_selector: A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
        :param topology_key: This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.

        :schema: IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
        '''
        if isinstance(label_selector, dict):
            label_selector = IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(**label_selector)
        if isinstance(namespace_selector, dict):
            namespace_selector = IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(**namespace_selector)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2a6d00d95d2d04eea9613de1c7903d2e66e53fac220751130ed1b8dc64a5e972)
            check_type(argname=\\"argument label_selector\\", value=label_selector, expected_type=type_hints[\\"label_selector\\"])
            check_type(argname=\\"argument namespaces\\", value=namespaces, expected_type=type_hints[\\"namespaces\\"])
            check_type(argname=\\"argument namespace_selector\\", value=namespace_selector, expected_type=type_hints[\\"namespace_selector\\"])
            check_type(argname=\\"argument topology_key\\", value=topology_key, expected_type=type_hints[\\"topology_key\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if label_selector is not None:
            self._values[\\"label_selector\\"] = label_selector
        if namespaces is not None:
            self._values[\\"namespaces\\"] = namespaces
        if namespace_selector is not None:
            self._values[\\"namespace_selector\\"] = namespace_selector
        if topology_key is not None:
            self._values[\\"topology_key\\"] = topology_key

    @builtins.property
    def label_selector(
        self,
    ) -> typing.Optional[\\"IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector\\"]:
        '''A label selector is a label query over a set of resources.

        The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.

        :schema: IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
        '''
        result = self._values.get(\\"label_selector\\")
        return typing.cast(typing.Optional[\\"IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector\\"], result)

    @builtins.property
    def namespaces(self) -> typing.Optional[typing.List[builtins.str]]:
        '''namespaces specifies a static list of namespace names that the term applies to.

        The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means \\"this pod's namespace\\".

        :schema: IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
        '''
        result = self._values.get(\\"namespaces\\")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace_selector(
        self,
    ) -> typing.Optional[\\"IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector\\"]:
        '''A label selector is a label query over a set of resources.

        The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.

        :schema: IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
        '''
        result = self._values.get(\\"namespace_selector\\")
        return typing.cast(typing.Optional[\\"IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector\\"], result)

    @builtins.property
    def topology_key(self) -> typing.Optional[builtins.str]:
        '''This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running.

        Empty topologyKey is not allowed.

        :schema: IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
        '''
        result = self._values.get(\\"topology_key\\")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type=\\"lacework-agent.IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector\\",
    jsii_struct_bases=[],
    name_mapping={
        \\"match_expressions\\": \\"matchExpressions\\",
        \\"match_labels\\": \\"matchLabels\\",
    },
)
class IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union[\\"IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions\\", typing.Dict[builtins.str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''A label selector is a label query over a set of resources.

        The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.

        :param match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \\"key\\", the operator is \\"In\\", and the values array contains only \\"value\\". The requirements are ANDed.

        :schema: IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__94286539963b88ed2abd60f58ddf76d754b62bbca1e65881e343f4dc1a75ecae)
            check_type(argname=\\"argument match_expressions\\", value=match_expressions, expected_type=type_hints[\\"match_expressions\\"])
            check_type(argname=\\"argument match_labels\\", value=match_labels, expected_type=type_hints[\\"match_labels\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if match_expressions is not None:
            self._values[\\"match_expressions\\"] = match_expressions
        if match_labels is not None:
            self._values[\\"match_labels\\"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List[\\"IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions\\"]]:
        '''matchExpressions is a list of label selector requirements.

        The requirements are ANDed.

        :schema: IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
        '''
        result = self._values.get(\\"match_expressions\\")
        return typing.cast(typing.Optional[typing.List[\\"IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions\\"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''matchLabels is a map of {key,value} pairs.

        A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \\"key\\", the operator is \\"In\\", and the values array contains only \\"value\\". The requirements are ANDed.

        :schema: IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
        '''
        result = self._values.get(\\"match_labels\\")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type=\\"lacework-agent.IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions\\",
    jsii_struct_bases=[],
    name_mapping={\\"key\\": \\"key\\", \\"operator\\": \\"operator\\", \\"values\\": \\"values\\"},
)
class IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        operator: typing.Optional[builtins.str] = None,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.

        :param key: key is the label key that the selector applies to.
        :param operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.

        :schema: IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__de7b755055a8d366bf9836a2f930f13b4b5936266e2bf73587ed60ba8b4b2a8c)
            check_type(argname=\\"argument key\\", value=key, expected_type=type_hints[\\"key\\"])
            check_type(argname=\\"argument operator\\", value=operator, expected_type=type_hints[\\"operator\\"])
            check_type(argname=\\"argument values\\", value=values, expected_type=type_hints[\\"values\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values[\\"key\\"] = key
        if operator is not None:
            self._values[\\"operator\\"] = operator
        if values is not None:
            self._values[\\"values\\"] = values

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''key is the label key that the selector applies to.

        :schema: IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
        '''
        result = self._values.get(\\"key\\")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def operator(self) -> typing.Optional[builtins.str]:
        '''operator represents a key's relationship to a set of values.

        Valid operators are In, NotIn, Exists and DoesNotExist.

        :schema: IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
        '''
        result = self._values.get(\\"operator\\")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''values is an array of string values.

        If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.

        :schema: IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
        '''
        result = self._values.get(\\"values\\")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type=\\"lacework-agent.IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector\\",
    jsii_struct_bases=[],
    name_mapping={
        \\"match_expressions\\": \\"matchExpressions\\",
        \\"match_labels\\": \\"matchLabels\\",
    },
)
class IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union[\\"IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions\\", typing.Dict[builtins.str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''A label selector is a label query over a set of resources.

        The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.

        :param match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \\"key\\", the operator is \\"In\\", and the values array contains only \\"value\\". The requirements are ANDed.

        :schema: IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__216dabe6923643276c2131b29326ded426ee439ab42adc975360c3f53dea4682)
            check_type(argname=\\"argument match_expressions\\", value=match_expressions, expected_type=type_hints[\\"match_expressions\\"])
            check_type(argname=\\"argument match_labels\\", value=match_labels, expected_type=type_hints[\\"match_labels\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if match_expressions is not None:
            self._values[\\"match_expressions\\"] = match_expressions
        if match_labels is not None:
            self._values[\\"match_labels\\"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List[\\"IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions\\"]]:
        '''matchExpressions is a list of label selector requirements.

        The requirements are ANDed.

        :schema: IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
        '''
        result = self._values.get(\\"match_expressions\\")
        return typing.cast(typing.Optional[typing.List[\\"IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions\\"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''matchLabels is a map of {key,value} pairs.

        A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \\"key\\", the operator is \\"In\\", and the values array contains only \\"value\\". The requirements are ANDed.

        :schema: IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
        '''
        result = self._values.get(\\"match_labels\\")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type=\\"lacework-agent.IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions\\",
    jsii_struct_bases=[],
    name_mapping={\\"key\\": \\"key\\", \\"operator\\": \\"operator\\", \\"values\\": \\"values\\"},
)
class IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        operator: typing.Optional[builtins.str] = None,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.

        :param key: key is the label key that the selector applies to.
        :param operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.

        :schema: IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3ea0d99f7344162148befe0c73dc109ce6af186931d8630c3aab4a07df5a590a)
            check_type(argname=\\"argument key\\", value=key, expected_type=type_hints[\\"key\\"])
            check_type(argname=\\"argument operator\\", value=operator, expected_type=type_hints[\\"operator\\"])
            check_type(argname=\\"argument values\\", value=values, expected_type=type_hints[\\"values\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values[\\"key\\"] = key
        if operator is not None:
            self._values[\\"operator\\"] = operator
        if values is not None:
            self._values[\\"values\\"] = values

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''key is the label key that the selector applies to.

        :schema: IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
        '''
        result = self._values.get(\\"key\\")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def operator(self) -> typing.Optional[builtins.str]:
        '''operator represents a key's relationship to a set of values.

        Valid operators are In, NotIn, Exists and DoesNotExist.

        :schema: IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
        '''
        result = self._values.get(\\"operator\\")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''values is an array of string values.

        If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.

        :schema: IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
        '''
        result = self._values.get(\\"values\\")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type=\\"lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinity\\",
    jsii_struct_bases=[],
    name_mapping={
        \\"preferred_during_scheduling_ignored_during_execution\\": \\"preferredDuringSchedulingIgnoredDuringExecution\\",
        \\"required_during_scheduling_ignored_during_execution\\": \\"requiredDuringSchedulingIgnoredDuringExecution\\",
    },
)
class IoK8SApiCoreV1AffinityPodAntiAffinity:
    def __init__(
        self,
        *,
        preferred_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union[\\"IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution\\", typing.Dict[builtins.str, typing.Any]]]] = None,
        required_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union[\\"IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution\\", typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Pod anti affinity is a group of inter pod anti affinity scheduling rules.

        :param preferred_during_scheduling_ignored_during_execution: The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding \\"weight\\" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
        :param required_during_scheduling_ignored_during_execution: If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.

        :schema: IoK8SApiCoreV1AffinityPodAntiAffinity
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b88eace380f44c65d21d90d3a959666edb3c888eb5a8b0fe785c3aaa22d86421)
            check_type(argname=\\"argument preferred_during_scheduling_ignored_during_execution\\", value=preferred_during_scheduling_ignored_during_execution, expected_type=type_hints[\\"preferred_during_scheduling_ignored_during_execution\\"])
            check_type(argname=\\"argument required_during_scheduling_ignored_during_execution\\", value=required_during_scheduling_ignored_during_execution, expected_type=type_hints[\\"required_during_scheduling_ignored_during_execution\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if preferred_during_scheduling_ignored_during_execution is not None:
            self._values[\\"preferred_during_scheduling_ignored_during_execution\\"] = preferred_during_scheduling_ignored_during_execution
        if required_during_scheduling_ignored_during_execution is not None:
            self._values[\\"required_during_scheduling_ignored_during_execution\\"] = required_during_scheduling_ignored_during_execution

    @builtins.property
    def preferred_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[typing.List[\\"IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution\\"]]:
        '''The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions.

        The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding \\"weight\\" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.

        :schema: IoK8SApiCoreV1AffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get(\\"preferred_during_scheduling_ignored_during_execution\\")
        return typing.cast(typing.Optional[typing.List[\\"IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution\\"]], result)

    @builtins.property
    def required_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[typing.List[\\"IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution\\"]]:
        '''If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node.

        If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.

        :schema: IoK8SApiCoreV1AffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get(\\"required_during_scheduling_ignored_during_execution\\")
        return typing.cast(typing.Optional[typing.List[\\"IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution\\"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"IoK8SApiCoreV1AffinityPodAntiAffinity(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type=\\"lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution\\",
    jsii_struct_bases=[],
    name_mapping={\\"pod_affinity_term\\": \\"podAffinityTerm\\", \\"weight\\": \\"weight\\"},
)
class IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        pod_affinity_term: typing.Optional[typing.Union[\\"IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm\\", typing.Dict[builtins.str, typing.Any]]] = None,
        weight: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s).

        :param pod_affinity_term: Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key matches that of any node on which a pod of the set of pods is running.
        :param weight: weight associated with matching the corresponding podAffinityTerm, in the range 1-100.

        :schema: IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
        '''
        if isinstance(pod_affinity_term, dict):
            pod_affinity_term = IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(**pod_affinity_term)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3b5279544107027f249afe15ae53a3f9fc003336039ae784915c7894311253c0)
            check_type(argname=\\"argument pod_affinity_term\\", value=pod_affinity_term, expected_type=type_hints[\\"pod_affinity_term\\"])
            check_type(argname=\\"argument weight\\", value=weight, expected_type=type_hints[\\"weight\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if pod_affinity_term is not None:
            self._values[\\"pod_affinity_term\\"] = pod_affinity_term
        if weight is not None:
            self._values[\\"weight\\"] = weight

    @builtins.property
    def pod_affinity_term(
        self,
    ) -> typing.Optional[\\"IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm\\"]:
        '''Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key  matches that of any node on which a pod of the set of pods is running.

        :schema: IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
        '''
        result = self._values.get(\\"pod_affinity_term\\")
        return typing.cast(typing.Optional[\\"IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm\\"], result)

    @builtins.property
    def weight(self) -> typing.Optional[jsii.Number]:
        '''weight associated with matching the corresponding podAffinityTerm, in the range 1-100.

        :schema: IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
        '''
        result = self._values.get(\\"weight\\")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type=\\"lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm\\",
    jsii_struct_bases=[],
    name_mapping={
        \\"topology_key\\": \\"topologyKey\\",
        \\"label_selector\\": \\"labelSelector\\",
        \\"namespaces\\": \\"namespaces\\",
        \\"namespace_selector\\": \\"namespaceSelector\\",
    },
)
class IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm:
    def __init__(
        self,
        *,
        topology_key: builtins.str,
        label_selector: typing.Optional[typing.Union[\\"IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector\\", typing.Dict[builtins.str, typing.Any]]] = None,
        namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace_selector: typing.Optional[typing.Union[\\"IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector\\", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key  matches that of any node on which a pod of the set of pods is running.

        :param topology_key: This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
        :param label_selector: A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
        :param namespaces: namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means \\"this pod's namespace\\".
        :param namespace_selector: A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.

        :schema: IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
        '''
        if isinstance(label_selector, dict):
            label_selector = IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(**label_selector)
        if isinstance(namespace_selector, dict):
            namespace_selector = IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(**namespace_selector)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d6879ad10b0b3bf32416b947889ea0fafb9697033bd98f9280aa3d9dac126887)
            check_type(argname=\\"argument topology_key\\", value=topology_key, expected_type=type_hints[\\"topology_key\\"])
            check_type(argname=\\"argument label_selector\\", value=label_selector, expected_type=type_hints[\\"label_selector\\"])
            check_type(argname=\\"argument namespaces\\", value=namespaces, expected_type=type_hints[\\"namespaces\\"])
            check_type(argname=\\"argument namespace_selector\\", value=namespace_selector, expected_type=type_hints[\\"namespace_selector\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            \\"topology_key\\": topology_key,
        }
        if label_selector is not None:
            self._values[\\"label_selector\\"] = label_selector
        if namespaces is not None:
            self._values[\\"namespaces\\"] = namespaces
        if namespace_selector is not None:
            self._values[\\"namespace_selector\\"] = namespace_selector

    @builtins.property
    def topology_key(self) -> builtins.str:
        '''This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running.

        Empty topologyKey is not allowed.

        :schema: IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
        '''
        result = self._values.get(\\"topology_key\\")
        assert result is not None, \\"Required property 'topology_key' is missing\\"
        return typing.cast(builtins.str, result)

    @builtins.property
    def label_selector(
        self,
    ) -> typing.Optional[\\"IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector\\"]:
        '''A label selector is a label query over a set of resources.

        The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.

        :schema: IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
        '''
        result = self._values.get(\\"label_selector\\")
        return typing.cast(typing.Optional[\\"IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector\\"], result)

    @builtins.property
    def namespaces(self) -> typing.Optional[typing.List[builtins.str]]:
        '''namespaces specifies a static list of namespace names that the term applies to.

        The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means \\"this pod's namespace\\".

        :schema: IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
        '''
        result = self._values.get(\\"namespaces\\")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace_selector(
        self,
    ) -> typing.Optional[\\"IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector\\"]:
        '''A label selector is a label query over a set of resources.

        The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.

        :schema: IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
        '''
        result = self._values.get(\\"namespace_selector\\")
        return typing.cast(typing.Optional[\\"IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector\\"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type=\\"lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector\\",
    jsii_struct_bases=[],
    name_mapping={
        \\"match_expressions\\": \\"matchExpressions\\",
        \\"match_labels\\": \\"matchLabels\\",
    },
)
class IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union[\\"IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions\\", typing.Dict[builtins.str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''A label selector is a label query over a set of resources.

        The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.

        :param match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \\"key\\", the operator is \\"In\\", and the values array contains only \\"value\\". The requirements are ANDed.

        :schema: IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__779e9109822ded6fb329c314168503867d9f0a2da63eb380b58847710fc7c54c)
            check_type(argname=\\"argument match_expressions\\", value=match_expressions, expected_type=type_hints[\\"match_expressions\\"])
            check_type(argname=\\"argument match_labels\\", value=match_labels, expected_type=type_hints[\\"match_labels\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if match_expressions is not None:
            self._values[\\"match_expressions\\"] = match_expressions
        if match_labels is not None:
            self._values[\\"match_labels\\"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List[\\"IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions\\"]]:
        '''matchExpressions is a list of label selector requirements.

        The requirements are ANDed.

        :schema: IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
        '''
        result = self._values.get(\\"match_expressions\\")
        return typing.cast(typing.Optional[typing.List[\\"IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions\\"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''matchLabels is a map of {key,value} pairs.

        A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \\"key\\", the operator is \\"In\\", and the values array contains only \\"value\\". The requirements are ANDed.

        :schema: IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
        '''
        result = self._values.get(\\"match_labels\\")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type=\\"lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions\\",
    jsii_struct_bases=[],
    name_mapping={\\"key\\": \\"key\\", \\"operator\\": \\"operator\\", \\"values\\": \\"values\\"},
)
class IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        operator: typing.Optional[builtins.str] = None,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.

        :param key: key is the label key that the selector applies to.
        :param operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.

        :schema: IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fbe1868dfaa4ea324e7b51741dc160ac660e7aead3d6ad63309f8527b880a9ee)
            check_type(argname=\\"argument key\\", value=key, expected_type=type_hints[\\"key\\"])
            check_type(argname=\\"argument operator\\", value=operator, expected_type=type_hints[\\"operator\\"])
            check_type(argname=\\"argument values\\", value=values, expected_type=type_hints[\\"values\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values[\\"key\\"] = key
        if operator is not None:
            self._values[\\"operator\\"] = operator
        if values is not None:
            self._values[\\"values\\"] = values

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''key is the label key that the selector applies to.

        :schema: IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
        '''
        result = self._values.get(\\"key\\")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def operator(self) -> typing.Optional[builtins.str]:
        '''operator represents a key's relationship to a set of values.

        Valid operators are In, NotIn, Exists and DoesNotExist.

        :schema: IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
        '''
        result = self._values.get(\\"operator\\")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''values is an array of string values.

        If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.

        :schema: IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
        '''
        result = self._values.get(\\"values\\")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type=\\"lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector\\",
    jsii_struct_bases=[],
    name_mapping={
        \\"match_expressions\\": \\"matchExpressions\\",
        \\"match_labels\\": \\"matchLabels\\",
    },
)
class IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union[\\"IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions\\", typing.Dict[builtins.str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''A label selector is a label query over a set of resources.

        The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.

        :param match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \\"key\\", the operator is \\"In\\", and the values array contains only \\"value\\". The requirements are ANDed.

        :schema: IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__68e47b2143b4877a3368c835d90e670218ba9b3c952ba8824d9a815404577149)
            check_type(argname=\\"argument match_expressions\\", value=match_expressions, expected_type=type_hints[\\"match_expressions\\"])
            check_type(argname=\\"argument match_labels\\", value=match_labels, expected_type=type_hints[\\"match_labels\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if match_expressions is not None:
            self._values[\\"match_expressions\\"] = match_expressions
        if match_labels is not None:
            self._values[\\"match_labels\\"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List[\\"IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions\\"]]:
        '''matchExpressions is a list of label selector requirements.

        The requirements are ANDed.

        :schema: IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
        '''
        result = self._values.get(\\"match_expressions\\")
        return typing.cast(typing.Optional[typing.List[\\"IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions\\"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''matchLabels is a map of {key,value} pairs.

        A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \\"key\\", the operator is \\"In\\", and the values array contains only \\"value\\". The requirements are ANDed.

        :schema: IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
        '''
        result = self._values.get(\\"match_labels\\")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type=\\"lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions\\",
    jsii_struct_bases=[],
    name_mapping={\\"key\\": \\"key\\", \\"operator\\": \\"operator\\", \\"values\\": \\"values\\"},
)
class IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        operator: typing.Optional[builtins.str] = None,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.

        :param key: key is the label key that the selector applies to.
        :param operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.

        :schema: IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__22b27419d7799ad450b94ff5f87bc58d4744c4e0c666e3767b396de0204de11a)
            check_type(argname=\\"argument key\\", value=key, expected_type=type_hints[\\"key\\"])
            check_type(argname=\\"argument operator\\", value=operator, expected_type=type_hints[\\"operator\\"])
            check_type(argname=\\"argument values\\", value=values, expected_type=type_hints[\\"values\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values[\\"key\\"] = key
        if operator is not None:
            self._values[\\"operator\\"] = operator
        if values is not None:
            self._values[\\"values\\"] = values

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''key is the label key that the selector applies to.

        :schema: IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
        '''
        result = self._values.get(\\"key\\")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def operator(self) -> typing.Optional[builtins.str]:
        '''operator represents a key's relationship to a set of values.

        Valid operators are In, NotIn, Exists and DoesNotExist.

        :schema: IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
        '''
        result = self._values.get(\\"operator\\")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''values is an array of string values.

        If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.

        :schema: IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
        '''
        result = self._values.get(\\"values\\")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type=\\"lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution\\",
    jsii_struct_bases=[],
    name_mapping={
        \\"label_selector\\": \\"labelSelector\\",
        \\"namespaces\\": \\"namespaces\\",
        \\"namespace_selector\\": \\"namespaceSelector\\",
        \\"topology_key\\": \\"topologyKey\\",
    },
)
class IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        label_selector: typing.Optional[typing.Union[\\"IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector\\", typing.Dict[builtins.str, typing.Any]]] = None,
        namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace_selector: typing.Optional[typing.Union[\\"IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector\\", typing.Dict[builtins.str, typing.Any]]] = None,
        topology_key: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key  matches that of any node on which a pod of the set of pods is running.

        :param label_selector: A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
        :param namespaces: namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means \\"this pod's namespace\\".
        :param namespace_selector: A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
        :param topology_key: This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.

        :schema: IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
        '''
        if isinstance(label_selector, dict):
            label_selector = IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(**label_selector)
        if isinstance(namespace_selector, dict):
            namespace_selector = IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(**namespace_selector)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__63f8c333243eb40563cc7d45ef1b7e6e5b9d38ad721d1418adf58e94b7bf4acb)
            check_type(argname=\\"argument label_selector\\", value=label_selector, expected_type=type_hints[\\"label_selector\\"])
            check_type(argname=\\"argument namespaces\\", value=namespaces, expected_type=type_hints[\\"namespaces\\"])
            check_type(argname=\\"argument namespace_selector\\", value=namespace_selector, expected_type=type_hints[\\"namespace_selector\\"])
            check_type(argname=\\"argument topology_key\\", value=topology_key, expected_type=type_hints[\\"topology_key\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if label_selector is not None:
            self._values[\\"label_selector\\"] = label_selector
        if namespaces is not None:
            self._values[\\"namespaces\\"] = namespaces
        if namespace_selector is not None:
            self._values[\\"namespace_selector\\"] = namespace_selector
        if topology_key is not None:
            self._values[\\"topology_key\\"] = topology_key

    @builtins.property
    def label_selector(
        self,
    ) -> typing.Optional[\\"IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector\\"]:
        '''A label selector is a label query over a set of resources.

        The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.

        :schema: IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
        '''
        result = self._values.get(\\"label_selector\\")
        return typing.cast(typing.Optional[\\"IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector\\"], result)

    @builtins.property
    def namespaces(self) -> typing.Optional[typing.List[builtins.str]]:
        '''namespaces specifies a static list of namespace names that the term applies to.

        The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means \\"this pod's namespace\\".

        :schema: IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
        '''
        result = self._values.get(\\"namespaces\\")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace_selector(
        self,
    ) -> typing.Optional[\\"IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector\\"]:
        '''A label selector is a label query over a set of resources.

        The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.

        :schema: IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
        '''
        result = self._values.get(\\"namespace_selector\\")
        return typing.cast(typing.Optional[\\"IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector\\"], result)

    @builtins.property
    def topology_key(self) -> typing.Optional[builtins.str]:
        '''This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running.

        Empty topologyKey is not allowed.

        :schema: IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
        '''
        result = self._values.get(\\"topology_key\\")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type=\\"lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector\\",
    jsii_struct_bases=[],
    name_mapping={
        \\"match_expressions\\": \\"matchExpressions\\",
        \\"match_labels\\": \\"matchLabels\\",
    },
)
class IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union[\\"IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions\\", typing.Dict[builtins.str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''A label selector is a label query over a set of resources.

        The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.

        :param match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \\"key\\", the operator is \\"In\\", and the values array contains only \\"value\\". The requirements are ANDed.

        :schema: IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0fc9c7df6b2de294ab5354d9cf7c44bbfcc94265b47418f00cafe7ecdf36144c)
            check_type(argname=\\"argument match_expressions\\", value=match_expressions, expected_type=type_hints[\\"match_expressions\\"])
            check_type(argname=\\"argument match_labels\\", value=match_labels, expected_type=type_hints[\\"match_labels\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if match_expressions is not None:
            self._values[\\"match_expressions\\"] = match_expressions
        if match_labels is not None:
            self._values[\\"match_labels\\"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List[\\"IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions\\"]]:
        '''matchExpressions is a list of label selector requirements.

        The requirements are ANDed.

        :schema: IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
        '''
        result = self._values.get(\\"match_expressions\\")
        return typing.cast(typing.Optional[typing.List[\\"IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions\\"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''matchLabels is a map of {key,value} pairs.

        A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \\"key\\", the operator is \\"In\\", and the values array contains only \\"value\\". The requirements are ANDed.

        :schema: IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
        '''
        result = self._values.get(\\"match_labels\\")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type=\\"lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions\\",
    jsii_struct_bases=[],
    name_mapping={\\"key\\": \\"key\\", \\"operator\\": \\"operator\\", \\"values\\": \\"values\\"},
)
class IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        operator: typing.Optional[builtins.str] = None,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.

        :param key: key is the label key that the selector applies to.
        :param operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.

        :schema: IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ed3918916c6e7886791cf2a5252525faa2413def1916ebb4df746a8a27cbb1e7)
            check_type(argname=\\"argument key\\", value=key, expected_type=type_hints[\\"key\\"])
            check_type(argname=\\"argument operator\\", value=operator, expected_type=type_hints[\\"operator\\"])
            check_type(argname=\\"argument values\\", value=values, expected_type=type_hints[\\"values\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values[\\"key\\"] = key
        if operator is not None:
            self._values[\\"operator\\"] = operator
        if values is not None:
            self._values[\\"values\\"] = values

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''key is the label key that the selector applies to.

        :schema: IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
        '''
        result = self._values.get(\\"key\\")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def operator(self) -> typing.Optional[builtins.str]:
        '''operator represents a key's relationship to a set of values.

        Valid operators are In, NotIn, Exists and DoesNotExist.

        :schema: IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
        '''
        result = self._values.get(\\"operator\\")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''values is an array of string values.

        If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.

        :schema: IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
        '''
        result = self._values.get(\\"values\\")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type=\\"lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector\\",
    jsii_struct_bases=[],
    name_mapping={
        \\"match_expressions\\": \\"matchExpressions\\",
        \\"match_labels\\": \\"matchLabels\\",
    },
)
class IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union[\\"IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions\\", typing.Dict[builtins.str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''A label selector is a label query over a set of resources.

        The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.

        :param match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \\"key\\", the operator is \\"In\\", and the values array contains only \\"value\\". The requirements are ANDed.

        :schema: IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__385d6e39815cb32272bda30489d64561dda13ec9946858d27fc65a0802694108)
            check_type(argname=\\"argument match_expressions\\", value=match_expressions, expected_type=type_hints[\\"match_expressions\\"])
            check_type(argname=\\"argument match_labels\\", value=match_labels, expected_type=type_hints[\\"match_labels\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if match_expressions is not None:
            self._values[\\"match_expressions\\"] = match_expressions
        if match_labels is not None:
            self._values[\\"match_labels\\"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List[\\"IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions\\"]]:
        '''matchExpressions is a list of label selector requirements.

        The requirements are ANDed.

        :schema: IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
        '''
        result = self._values.get(\\"match_expressions\\")
        return typing.cast(typing.Optional[typing.List[\\"IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions\\"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''matchLabels is a map of {key,value} pairs.

        A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \\"key\\", the operator is \\"In\\", and the values array contains only \\"value\\". The requirements are ANDed.

        :schema: IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
        '''
        result = self._values.get(\\"match_labels\\")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type=\\"lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions\\",
    jsii_struct_bases=[],
    name_mapping={\\"key\\": \\"key\\", \\"operator\\": \\"operator\\", \\"values\\": \\"values\\"},
)
class IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        operator: typing.Optional[builtins.str] = None,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.

        :param key: key is the label key that the selector applies to.
        :param operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.

        :schema: IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9fdfe8df35f946a45e968b4b38d69b1382d866a3449f1eda5f75ff5a6ac17808)
            check_type(argname=\\"argument key\\", value=key, expected_type=type_hints[\\"key\\"])
            check_type(argname=\\"argument operator\\", value=operator, expected_type=type_hints[\\"operator\\"])
            check_type(argname=\\"argument values\\", value=values, expected_type=type_hints[\\"values\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values[\\"key\\"] = key
        if operator is not None:
            self._values[\\"operator\\"] = operator
        if values is not None:
            self._values[\\"values\\"] = values

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''key is the label key that the selector applies to.

        :schema: IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
        '''
        result = self._values.get(\\"key\\")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def operator(self) -> typing.Optional[builtins.str]:
        '''operator represents a key's relationship to a set of values.

        Valid operators are In, NotIn, Exists and DoesNotExist.

        :schema: IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
        '''
        result = self._values.get(\\"operator\\")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''values is an array of string values.

        If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.

        :schema: IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
        '''
        result = self._values.get(\\"values\\")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type=\\"lacework-agent.IoK8SApiCoreV1DaemonSetUpdateStrategy\\",
    jsii_struct_bases=[],
    name_mapping={\\"rolling_update\\": \\"rollingUpdate\\", \\"type\\": \\"type\\"},
)
class IoK8SApiCoreV1DaemonSetUpdateStrategy:
    def __init__(
        self,
        *,
        rolling_update: typing.Optional[typing.Union[\\"IoK8SApiCoreV1DaemonSetUpdateStrategyRollingUpdate\\", typing.Dict[builtins.str, typing.Any]]] = None,
        type: typing.Optional[\\"IoK8SApiCoreV1DaemonSetUpdateStrategyType\\"] = None,
    ) -> None:
        '''DaemonSetUpdateStrategy is a struct used to control the update strategy for a DaemonSet.

        :param rolling_update: Spec to control the desired behavior of daemon set rolling update.
        :param type: Type of daemon set update. Can be \\"RollingUpdate\\" or \\"OnDelete\\". Default is RollingUpdate. Possible enum values: - \`\`\\"OnDelete\\"\`\` Replace the old daemons only when it's killed - \`\`\\"RollingUpdate\\"\`\` Replace the old daemons by new ones using rolling update i.e replace them on each node one after the other. Default: RollingUpdate.

        :schema: io.k8s.api.core.v1.DaemonSetUpdateStrategy
        '''
        if isinstance(rolling_update, dict):
            rolling_update = IoK8SApiCoreV1DaemonSetUpdateStrategyRollingUpdate(**rolling_update)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__691cf1c6250365dd9cb33a494eefd1c10935548095a168d5ef395a7441862256)
            check_type(argname=\\"argument rolling_update\\", value=rolling_update, expected_type=type_hints[\\"rolling_update\\"])
            check_type(argname=\\"argument type\\", value=type, expected_type=type_hints[\\"type\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if rolling_update is not None:
            self._values[\\"rolling_update\\"] = rolling_update
        if type is not None:
            self._values[\\"type\\"] = type

    @builtins.property
    def rolling_update(
        self,
    ) -> typing.Optional[\\"IoK8SApiCoreV1DaemonSetUpdateStrategyRollingUpdate\\"]:
        '''Spec to control the desired behavior of daemon set rolling update.

        :schema: io.k8s.api.core.v1.DaemonSetUpdateStrategy#rollingUpdate
        '''
        result = self._values.get(\\"rolling_update\\")
        return typing.cast(typing.Optional[\\"IoK8SApiCoreV1DaemonSetUpdateStrategyRollingUpdate\\"], result)

    @builtins.property
    def type(self) -> typing.Optional[\\"IoK8SApiCoreV1DaemonSetUpdateStrategyType\\"]:
        '''Type of daemon set update. Can be \\"RollingUpdate\\" or \\"OnDelete\\". Default is RollingUpdate.

        Possible enum values:

        - \`\`\\"OnDelete\\"\`\` Replace the old daemons only when it's killed
        - \`\`\\"RollingUpdate\\"\`\` Replace the old daemons by new ones using rolling update i.e replace them on each node one after the other.

        :default: RollingUpdate.

        :schema: io.k8s.api.core.v1.DaemonSetUpdateStrategy#type
        '''
        result = self._values.get(\\"type\\")
        return typing.cast(typing.Optional[\\"IoK8SApiCoreV1DaemonSetUpdateStrategyType\\"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"IoK8SApiCoreV1DaemonSetUpdateStrategy(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type=\\"lacework-agent.IoK8SApiCoreV1DaemonSetUpdateStrategyRollingUpdate\\",
    jsii_struct_bases=[],
    name_mapping={\\"max_surge\\": \\"maxSurge\\", \\"max_unavailable\\": \\"maxUnavailable\\"},
)
class IoK8SApiCoreV1DaemonSetUpdateStrategyRollingUpdate:
    def __init__(
        self,
        *,
        max_surge: typing.Any = None,
        max_unavailable: typing.Any = None,
    ) -> None:
        '''Spec to control the desired behavior of daemon set rolling update.

        :param max_surge: 
        :param max_unavailable: 

        :schema: IoK8SApiCoreV1DaemonSetUpdateStrategyRollingUpdate
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bcbe1e4525c8ae8dac04633b9fd41a3cdc32975e54777d9b5669373b2f18141c)
            check_type(argname=\\"argument max_surge\\", value=max_surge, expected_type=type_hints[\\"max_surge\\"])
            check_type(argname=\\"argument max_unavailable\\", value=max_unavailable, expected_type=type_hints[\\"max_unavailable\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if max_surge is not None:
            self._values[\\"max_surge\\"] = max_surge
        if max_unavailable is not None:
            self._values[\\"max_unavailable\\"] = max_unavailable

    @builtins.property
    def max_surge(self) -> typing.Any:
        '''
        :schema: IoK8SApiCoreV1DaemonSetUpdateStrategyRollingUpdate#maxSurge
        '''
        result = self._values.get(\\"max_surge\\")
        return typing.cast(typing.Any, result)

    @builtins.property
    def max_unavailable(self) -> typing.Any:
        '''
        :schema: IoK8SApiCoreV1DaemonSetUpdateStrategyRollingUpdate#maxUnavailable
        '''
        result = self._values.get(\\"max_unavailable\\")
        return typing.cast(typing.Any, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"IoK8SApiCoreV1DaemonSetUpdateStrategyRollingUpdate(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type=\\"lacework-agent.IoK8SApiCoreV1DaemonSetUpdateStrategyType\\")
class IoK8SApiCoreV1DaemonSetUpdateStrategyType(enum.Enum):
    '''Type of daemon set update. Can be \\"RollingUpdate\\" or \\"OnDelete\\". Default is RollingUpdate.

    Possible enum values:

    - \`\`\\"OnDelete\\"\`\` Replace the old daemons only when it's killed
    - \`\`\\"RollingUpdate\\"\`\` Replace the old daemons by new ones using rolling update i.e replace them on each node one after the other.

    :default: RollingUpdate.

    :schema: IoK8SApiCoreV1DaemonSetUpdateStrategyType
    '''

    ON_DELETE = \\"ON_DELETE\\"
    '''OnDelete.'''
    ROLLING_UPDATE = \\"ROLLING_UPDATE\\"
    '''RollingUpdate.'''


@jsii.data_type(
    jsii_type=\\"lacework-agent.IoK8SApiCoreV1LocalObjectReference\\",
    jsii_struct_bases=[],
    name_mapping={\\"name\\": \\"name\\"},
)
class IoK8SApiCoreV1LocalObjectReference:
    def __init__(self, *, name: typing.Optional[builtins.str] = None) -> None:
        '''LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.

        :param name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names

        :schema: io.k8s.api.core.v1.LocalObjectReference
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__aad31b07aae14ea370a8ca13338d399e64c240651525bbc3a724ea48937a61e8)
            check_type(argname=\\"argument name\\", value=name, expected_type=type_hints[\\"name\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if name is not None:
            self._values[\\"name\\"] = name

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''Name of the referent.

        More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names

        :schema: io.k8s.api.core.v1.LocalObjectReference#name
        '''
        result = self._values.get(\\"name\\")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"IoK8SApiCoreV1LocalObjectReference(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type=\\"lacework-agent.IoK8SApiCoreV1ResourceRequirements\\",
    jsii_struct_bases=[],
    name_mapping={\\"limits\\": \\"limits\\", \\"requests\\": \\"requests\\"},
)
class IoK8SApiCoreV1ResourceRequirements:
    def __init__(
        self,
        *,
        limits: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        requests: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    ) -> None:
        '''ResourceRequirements describes the compute resource requirements.

        :param limits: Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
        :param requests: Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/

        :schema: io.k8s.api.core.v1.ResourceRequirements
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b0cfae6cb4aad42921bb69bfe68fccfe027731b98cff20327e29d9b23d764e1a)
            check_type(argname=\\"argument limits\\", value=limits, expected_type=type_hints[\\"limits\\"])
            check_type(argname=\\"argument requests\\", value=requests, expected_type=type_hints[\\"requests\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if limits is not None:
            self._values[\\"limits\\"] = limits
        if requests is not None:
            self._values[\\"requests\\"] = requests

    @builtins.property
    def limits(self) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''Limits describes the maximum amount of compute resources allowed.

        More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/

        :schema: io.k8s.api.core.v1.ResourceRequirements#limits
        '''
        result = self._values.get(\\"limits\\")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def requests(self) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''Requests describes the minimum amount of compute resources required.

        If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/

        :schema: io.k8s.api.core.v1.ResourceRequirements#requests
        '''
        result = self._values.get(\\"requests\\")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"IoK8SApiCoreV1ResourceRequirements(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type=\\"lacework-agent.IoK8SApiCoreV1Toleration\\",
    jsii_struct_bases=[],
    name_mapping={
        \\"effect\\": \\"effect\\",
        \\"key\\": \\"key\\",
        \\"operator\\": \\"operator\\",
        \\"toleration_seconds\\": \\"tolerationSeconds\\",
        \\"value\\": \\"value\\",
    },
)
class IoK8SApiCoreV1Toleration:
    def __init__(
        self,
        *,
        effect: typing.Optional[\\"IoK8SApiCoreV1TolerationEffect\\"] = None,
        key: typing.Optional[builtins.str] = None,
        operator: typing.Optional[\\"IoK8SApiCoreV1TolerationOperator\\"] = None,
        toleration_seconds: typing.Optional[jsii.Number] = None,
        value: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The pod this Toleration is attached to tolerates any taint that matches the triple <key,value,effect> using the matching operator .

        :param effect: Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute. Possible enum values: - \`\`\\"NoExecute\\"\`\` Evict any already-running pods that do not tolerate the taint. Currently enforced by NodeController. - \`\`\\"NoSchedule\\"\`\` Do not allow new pods to schedule onto the node unless they tolerate the taint, but allow all pods submitted to Kubelet without going through the scheduler to start, and allow all already-running pods to continue running. Enforced by the scheduler. - \`\`\\"PreferNoSchedule\\"\`\` Like TaintEffectNoSchedule, but the scheduler tries not to schedule new pods onto the node, rather than prohibiting new pods from scheduling onto the node entirely. Enforced by the scheduler.
        :param key: Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
        :param operator: Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category. Possible enum values: - \`\`\\"Equal\\"\`\` - \`\`\\"Exists\\"\`\` Default: Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
        :param toleration_seconds: TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
        :param value: Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.

        :schema: io.k8s.api.core.v1.Toleration
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8961b249a3bd11e4645f57459dc73620f46a774c6a01af2d7b27f6d837bf44ea)
            check_type(argname=\\"argument effect\\", value=effect, expected_type=type_hints[\\"effect\\"])
            check_type(argname=\\"argument key\\", value=key, expected_type=type_hints[\\"key\\"])
            check_type(argname=\\"argument operator\\", value=operator, expected_type=type_hints[\\"operator\\"])
            check_type(argname=\\"argument toleration_seconds\\", value=toleration_seconds, expected_type=type_hints[\\"toleration_seconds\\"])
            check_type(argname=\\"argument value\\", value=value, expected_type=type_hints[\\"value\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if effect is not None:
            self._values[\\"effect\\"] = effect
        if key is not None:
            self._values[\\"key\\"] = key
        if operator is not None:
            self._values[\\"operator\\"] = operator
        if toleration_seconds is not None:
            self._values[\\"toleration_seconds\\"] = toleration_seconds
        if value is not None:
            self._values[\\"value\\"] = value

    @builtins.property
    def effect(self) -> typing.Optional[\\"IoK8SApiCoreV1TolerationEffect\\"]:
        '''Effect indicates the taint effect to match.

        Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.

        Possible enum values:

        - \`\`\\"NoExecute\\"\`\` Evict any already-running pods that do not tolerate the taint. Currently enforced by NodeController.
        - \`\`\\"NoSchedule\\"\`\` Do not allow new pods to schedule onto the node unless they tolerate the taint, but allow all pods submitted to Kubelet without going through the scheduler to start, and allow all already-running pods to continue running. Enforced by the scheduler.
        - \`\`\\"PreferNoSchedule\\"\`\` Like TaintEffectNoSchedule, but the scheduler tries not to schedule new pods onto the node, rather than prohibiting new pods from scheduling onto the node entirely. Enforced by the scheduler.

        :schema: io.k8s.api.core.v1.Toleration#effect
        '''
        result = self._values.get(\\"effect\\")
        return typing.cast(typing.Optional[\\"IoK8SApiCoreV1TolerationEffect\\"], result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''Key is the taint key that the toleration applies to.

        Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.

        :schema: io.k8s.api.core.v1.Toleration#key
        '''
        result = self._values.get(\\"key\\")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def operator(self) -> typing.Optional[\\"IoK8SApiCoreV1TolerationOperator\\"]:
        '''Operator represents a key's relationship to the value.

        Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.

        Possible enum values:

        - \`\`\\"Equal\\"\`\`
        - \`\`\\"Exists\\"\`\`

        :default: Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.

        :schema: io.k8s.api.core.v1.Toleration#operator
        '''
        result = self._values.get(\\"operator\\")
        return typing.cast(typing.Optional[\\"IoK8SApiCoreV1TolerationOperator\\"], result)

    @builtins.property
    def toleration_seconds(self) -> typing.Optional[jsii.Number]:
        '''TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint.

        By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.

        :schema: io.k8s.api.core.v1.Toleration#tolerationSeconds
        '''
        result = self._values.get(\\"toleration_seconds\\")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def value(self) -> typing.Optional[builtins.str]:
        '''Value is the taint value the toleration matches to.

        If the operator is Exists, the value should be empty, otherwise just a regular string.

        :schema: io.k8s.api.core.v1.Toleration#value
        '''
        result = self._values.get(\\"value\\")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"IoK8SApiCoreV1Toleration(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type=\\"lacework-agent.IoK8SApiCoreV1TolerationEffect\\")
class IoK8SApiCoreV1TolerationEffect(enum.Enum):
    '''Effect indicates the taint effect to match.

    Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.

    Possible enum values:

    - \`\`\\"NoExecute\\"\`\` Evict any already-running pods that do not tolerate the taint. Currently enforced by NodeController.
    - \`\`\\"NoSchedule\\"\`\` Do not allow new pods to schedule onto the node unless they tolerate the taint, but allow all pods submitted to Kubelet without going through the scheduler to start, and allow all already-running pods to continue running. Enforced by the scheduler.
    - \`\`\\"PreferNoSchedule\\"\`\` Like TaintEffectNoSchedule, but the scheduler tries not to schedule new pods onto the node, rather than prohibiting new pods from scheduling onto the node entirely. Enforced by the scheduler.

    :schema: IoK8SApiCoreV1TolerationEffect
    '''

    NO_EXECUTE = \\"NO_EXECUTE\\"
    '''NoExecute.'''
    NO_SCHEDULE = \\"NO_SCHEDULE\\"
    '''NoSchedule.'''
    PREFER_NO_SCHEDULE = \\"PREFER_NO_SCHEDULE\\"
    '''PreferNoSchedule.'''


@jsii.enum(jsii_type=\\"lacework-agent.IoK8SApiCoreV1TolerationOperator\\")
class IoK8SApiCoreV1TolerationOperator(enum.Enum):
    '''Operator represents a key's relationship to the value.

    Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.

    Possible enum values:

    - \`\`\\"Equal\\"\`\`
    - \`\`\\"Exists\\"\`\`

    :default: Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.

    :schema: IoK8SApiCoreV1TolerationOperator
    '''

    EQUAL = \\"EQUAL\\"
    '''Equal.'''
    EXISTS = \\"EXISTS\\"
    '''Exists.'''


class LaceworkAgent(
    _constructs_77d1e7e8.Construct,
    metaclass=jsii.JSIIMeta,
    jsii_type=\\"lacework-agent.LaceworkAgent\\",
):
    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        values: typing.Union[\\"LaceworkAgentValues\\", typing.Dict[builtins.str, typing.Any]],
        helm_executable: typing.Optional[builtins.str] = None,
        helm_flags: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace: typing.Optional[builtins.str] = None,
        release_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param values: -
        :param helm_executable: -
        :param helm_flags: -
        :param namespace: -
        :param release_name: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__538ed41add4cf5a0b3aca9fc59ee30dae09743d95432eb21a3ce0b9acfbe4e21)
            check_type(argname=\\"argument scope\\", value=scope, expected_type=type_hints[\\"scope\\"])
            check_type(argname=\\"argument id\\", value=id, expected_type=type_hints[\\"id\\"])
        props = LaceworkAgentProps(
            values=values,
            helm_executable=helm_executable,
            helm_flags=helm_flags,
            namespace=namespace,
            release_name=release_name,
        )

        jsii.create(self.__class__, self, [scope, id, props])


@jsii.data_type(
    jsii_type=\\"lacework-agent.LaceworkAgentCloudservice\\",
    jsii_struct_bases=[],
    name_mapping={\\"gke\\": \\"gke\\"},
)
class LaceworkAgentCloudservice:
    def __init__(
        self,
        *,
        gke: typing.Optional[typing.Union[\\"LaceworkAgentCloudserviceGke\\", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param gke: 

        :schema: LaceworkAgentCloudservice
        '''
        if isinstance(gke, dict):
            gke = LaceworkAgentCloudserviceGke(**gke)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a00c30cb766c4ce3670ed7fa040a7194f0cc005e50f492fee71a1d7221fdbc73)
            check_type(argname=\\"argument gke\\", value=gke, expected_type=type_hints[\\"gke\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if gke is not None:
            self._values[\\"gke\\"] = gke

    @builtins.property
    def gke(self) -> typing.Optional[\\"LaceworkAgentCloudserviceGke\\"]:
        '''
        :schema: LaceworkAgentCloudservice#gke
        '''
        result = self._values.get(\\"gke\\")
        return typing.cast(typing.Optional[\\"LaceworkAgentCloudserviceGke\\"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"LaceworkAgentCloudservice(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type=\\"lacework-agent.LaceworkAgentCloudserviceGke\\",
    jsii_struct_bases=[],
    name_mapping={\\"autopilot\\": \\"autopilot\\"},
)
class LaceworkAgentCloudserviceGke:
    def __init__(self, *, autopilot: typing.Optional[builtins.bool] = None) -> None:
        '''
        :param autopilot: 

        :schema: LaceworkAgentCloudserviceGke
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a4d2ea86626ffffc816a5d7ea7ea672b7cbcee10de8e26d93325b202baa6294c)
            check_type(argname=\\"argument autopilot\\", value=autopilot, expected_type=type_hints[\\"autopilot\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if autopilot is not None:
            self._values[\\"autopilot\\"] = autopilot

    @builtins.property
    def autopilot(self) -> typing.Optional[builtins.bool]:
        '''
        :schema: LaceworkAgentCloudserviceGke#autopilot
        '''
        result = self._values.get(\\"autopilot\\")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"LaceworkAgentCloudserviceGke(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type=\\"lacework-agent.LaceworkAgentClusterAgent\\",
    jsii_struct_bases=[],
    name_mapping={
        \\"enable\\": \\"enable\\",
        \\"image\\": \\"image\\",
        \\"additional_values\\": \\"additionalValues\\",
        \\"cluster_region\\": \\"clusterRegion\\",
        \\"cluster_type\\": \\"clusterType\\",
        \\"scrape_initial_delay_mins\\": \\"scrapeInitialDelayMins\\",
        \\"scrape_interval_mins\\": \\"scrapeIntervalMins\\",
    },
)
class LaceworkAgentClusterAgent:
    def __init__(
        self,
        *,
        enable: builtins.bool,
        image: typing.Union[\\"LaceworkAgentClusterAgentImage\\", typing.Dict[builtins.str, typing.Any]],
        additional_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        cluster_region: typing.Optional[builtins.str] = None,
        cluster_type: typing.Optional[\\"LaceworkAgentClusterAgentClusterType\\"] = None,
        scrape_initial_delay_mins: typing.Optional[jsii.Number] = None,
        scrape_interval_mins: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param enable: Enable cluster agent.
        :param image: 
        :param additional_values: Values that are not available in values.schema.json will not be code generated. You can add such values to this property.
        :param cluster_region: Kubernetes cluster cloud region.
        :param cluster_type: Kubernetes cluster type.
        :param scrape_initial_delay_mins: Cluster mode agent's initial delay of cluster scraping after startup in minutes.
        :param scrape_interval_mins: Cluster mode agent's scrape interval in minutes.

        :schema: LaceworkAgentClusterAgent
        '''
        if isinstance(image, dict):
            image = LaceworkAgentClusterAgentImage(**image)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__427477360d777d212ced442a6c1a4283eae0d78b2a8c760ed72582ef9fe4964a)
            check_type(argname=\\"argument enable\\", value=enable, expected_type=type_hints[\\"enable\\"])
            check_type(argname=\\"argument image\\", value=image, expected_type=type_hints[\\"image\\"])
            check_type(argname=\\"argument additional_values\\", value=additional_values, expected_type=type_hints[\\"additional_values\\"])
            check_type(argname=\\"argument cluster_region\\", value=cluster_region, expected_type=type_hints[\\"cluster_region\\"])
            check_type(argname=\\"argument cluster_type\\", value=cluster_type, expected_type=type_hints[\\"cluster_type\\"])
            check_type(argname=\\"argument scrape_initial_delay_mins\\", value=scrape_initial_delay_mins, expected_type=type_hints[\\"scrape_initial_delay_mins\\"])
            check_type(argname=\\"argument scrape_interval_mins\\", value=scrape_interval_mins, expected_type=type_hints[\\"scrape_interval_mins\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            \\"enable\\": enable,
            \\"image\\": image,
        }
        if additional_values is not None:
            self._values[\\"additional_values\\"] = additional_values
        if cluster_region is not None:
            self._values[\\"cluster_region\\"] = cluster_region
        if cluster_type is not None:
            self._values[\\"cluster_type\\"] = cluster_type
        if scrape_initial_delay_mins is not None:
            self._values[\\"scrape_initial_delay_mins\\"] = scrape_initial_delay_mins
        if scrape_interval_mins is not None:
            self._values[\\"scrape_interval_mins\\"] = scrape_interval_mins

    @builtins.property
    def enable(self) -> builtins.bool:
        '''Enable cluster agent.

        :schema: LaceworkAgentClusterAgent#enable
        '''
        result = self._values.get(\\"enable\\")
        assert result is not None, \\"Required property 'enable' is missing\\"
        return typing.cast(builtins.bool, result)

    @builtins.property
    def image(self) -> \\"LaceworkAgentClusterAgentImage\\":
        '''
        :schema: LaceworkAgentClusterAgent#image
        '''
        result = self._values.get(\\"image\\")
        assert result is not None, \\"Required property 'image' is missing\\"
        return typing.cast(\\"LaceworkAgentClusterAgentImage\\", result)

    @builtins.property
    def additional_values(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''Values that are not available in values.schema.json will not be code generated. You can add such values to this property.

        :schema: LaceworkAgentClusterAgent#additionalValues
        '''
        result = self._values.get(\\"additional_values\\")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def cluster_region(self) -> typing.Optional[builtins.str]:
        '''Kubernetes cluster cloud region.

        :schema: LaceworkAgentClusterAgent#clusterRegion
        '''
        result = self._values.get(\\"cluster_region\\")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def cluster_type(self) -> typing.Optional[\\"LaceworkAgentClusterAgentClusterType\\"]:
        '''Kubernetes cluster type.

        :schema: LaceworkAgentClusterAgent#clusterType
        '''
        result = self._values.get(\\"cluster_type\\")
        return typing.cast(typing.Optional[\\"LaceworkAgentClusterAgentClusterType\\"], result)

    @builtins.property
    def scrape_initial_delay_mins(self) -> typing.Optional[jsii.Number]:
        '''Cluster mode agent's initial delay of cluster scraping after startup in minutes.

        :schema: LaceworkAgentClusterAgent#scrapeInitialDelayMins
        '''
        result = self._values.get(\\"scrape_initial_delay_mins\\")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def scrape_interval_mins(self) -> typing.Optional[jsii.Number]:
        '''Cluster mode agent's scrape interval in minutes.

        :schema: LaceworkAgentClusterAgent#scrapeIntervalMins
        '''
        result = self._values.get(\\"scrape_interval_mins\\")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"LaceworkAgentClusterAgent(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type=\\"lacework-agent.LaceworkAgentClusterAgentClusterType\\")
class LaceworkAgentClusterAgentClusterType(enum.Enum):
    '''Kubernetes cluster type.

    :schema: LaceworkAgentClusterAgentClusterType
    '''

    EKS = \\"EKS\\"
    '''eks.'''
    GKE = \\"GKE\\"
    '''gke.'''
    UNKNOWN = \\"UNKNOWN\\"
    '''unknown.'''


@jsii.data_type(
    jsii_type=\\"lacework-agent.LaceworkAgentClusterAgentImage\\",
    jsii_struct_bases=[],
    name_mapping={
        \\"pull_policy\\": \\"pullPolicy\\",
        \\"registry\\": \\"registry\\",
        \\"repository\\": \\"repository\\",
        \\"tag\\": \\"tag\\",
        \\"additional_values\\": \\"additionalValues\\",
        \\"image_pull_secrets\\": \\"imagePullSecrets\\",
    },
)
class LaceworkAgentClusterAgentImage:
    def __init__(
        self,
        *,
        pull_policy: \\"LaceworkAgentClusterAgentImagePullPolicy\\",
        registry: builtins.str,
        repository: builtins.str,
        tag: builtins.str,
        additional_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        image_pull_secrets: typing.Optional[typing.Sequence[typing.Union[IoK8SApiCoreV1LocalObjectReference, typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param pull_policy: Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images Possible enum values: - \`\`\\"Always\\"\`\` means that kubelet always attempts to pull the latest image. Container will fail If the pull fails. - \`\`\\"IfNotPresent\\"\`\` means that kubelet pulls if the image isn't present on disk. Container will fail if the image isn't present and the pull fails. - \`\`\\"Never\\"\`\` means that kubelet never pulls an image, but only uses a local image. Container will fail if the image isn't present Default: Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
        :param registry: 
        :param repository: 
        :param tag: 
        :param additional_values: Values that are not available in values.schema.json will not be code generated. You can add such values to this property.
        :param image_pull_secrets: ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec. If specified, these secrets will be passed to individual puller implementations for them to use. More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod

        :schema: LaceworkAgentClusterAgentImage
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1b0c01541508b3b32c7ca4979253b8778a14c281b271f717c8b3cfd5cc199c6e)
            check_type(argname=\\"argument pull_policy\\", value=pull_policy, expected_type=type_hints[\\"pull_policy\\"])
            check_type(argname=\\"argument registry\\", value=registry, expected_type=type_hints[\\"registry\\"])
            check_type(argname=\\"argument repository\\", value=repository, expected_type=type_hints[\\"repository\\"])
            check_type(argname=\\"argument tag\\", value=tag, expected_type=type_hints[\\"tag\\"])
            check_type(argname=\\"argument additional_values\\", value=additional_values, expected_type=type_hints[\\"additional_values\\"])
            check_type(argname=\\"argument image_pull_secrets\\", value=image_pull_secrets, expected_type=type_hints[\\"image_pull_secrets\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            \\"pull_policy\\": pull_policy,
            \\"registry\\": registry,
            \\"repository\\": repository,
            \\"tag\\": tag,
        }
        if additional_values is not None:
            self._values[\\"additional_values\\"] = additional_values
        if image_pull_secrets is not None:
            self._values[\\"image_pull_secrets\\"] = image_pull_secrets

    @builtins.property
    def pull_policy(self) -> \\"LaceworkAgentClusterAgentImagePullPolicy\\":
        '''Image pull policy.

        One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images

        Possible enum values:

        - \`\`\\"Always\\"\`\` means that kubelet always attempts to pull the latest image. Container will fail If the pull fails.
        - \`\`\\"IfNotPresent\\"\`\` means that kubelet pulls if the image isn't present on disk. Container will fail if the image isn't present and the pull fails.
        - \`\`\\"Never\\"\`\` means that kubelet never pulls an image, but only uses a local image. Container will fail if the image isn't present

        :default: Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images

        :schema: LaceworkAgentClusterAgentImage#pullPolicy
        '''
        result = self._values.get(\\"pull_policy\\")
        assert result is not None, \\"Required property 'pull_policy' is missing\\"
        return typing.cast(\\"LaceworkAgentClusterAgentImagePullPolicy\\", result)

    @builtins.property
    def registry(self) -> builtins.str:
        '''
        :schema: LaceworkAgentClusterAgentImage#registry
        '''
        result = self._values.get(\\"registry\\")
        assert result is not None, \\"Required property 'registry' is missing\\"
        return typing.cast(builtins.str, result)

    @builtins.property
    def repository(self) -> builtins.str:
        '''
        :schema: LaceworkAgentClusterAgentImage#repository
        '''
        result = self._values.get(\\"repository\\")
        assert result is not None, \\"Required property 'repository' is missing\\"
        return typing.cast(builtins.str, result)

    @builtins.property
    def tag(self) -> builtins.str:
        '''
        :schema: LaceworkAgentClusterAgentImage#tag
        '''
        result = self._values.get(\\"tag\\")
        assert result is not None, \\"Required property 'tag' is missing\\"
        return typing.cast(builtins.str, result)

    @builtins.property
    def additional_values(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''Values that are not available in values.schema.json will not be code generated. You can add such values to this property.

        :schema: LaceworkAgentClusterAgentImage#additionalValues
        '''
        result = self._values.get(\\"additional_values\\")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def image_pull_secrets(
        self,
    ) -> typing.Optional[typing.List[IoK8SApiCoreV1LocalObjectReference]]:
        '''ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec.

        If specified, these secrets will be passed to individual puller implementations for them to use. More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod

        :schema: LaceworkAgentClusterAgentImage#imagePullSecrets
        '''
        result = self._values.get(\\"image_pull_secrets\\")
        return typing.cast(typing.Optional[typing.List[IoK8SApiCoreV1LocalObjectReference]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"LaceworkAgentClusterAgentImage(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type=\\"lacework-agent.LaceworkAgentClusterAgentImagePullPolicy\\")
class LaceworkAgentClusterAgentImagePullPolicy(enum.Enum):
    '''Image pull policy.

    One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images

    Possible enum values:

    - \`\`\\"Always\\"\`\` means that kubelet always attempts to pull the latest image. Container will fail If the pull fails.
    - \`\`\\"IfNotPresent\\"\`\` means that kubelet pulls if the image isn't present on disk. Container will fail if the image isn't present and the pull fails.
    - \`\`\\"Never\\"\`\` means that kubelet never pulls an image, but only uses a local image. Container will fail if the image isn't present

    :default: Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images

    :schema: LaceworkAgentClusterAgentImagePullPolicy
    '''

    ALWAYS = \\"ALWAYS\\"
    '''Always.'''
    IF_NOT_PRESENT = \\"IF_NOT_PRESENT\\"
    '''IfNotPresent.'''
    NEVER = \\"NEVER\\"
    '''Never.'''


@jsii.data_type(
    jsii_type=\\"lacework-agent.LaceworkAgentDaemonset\\",
    jsii_struct_bases=[],
    name_mapping={\\"affinity\\": \\"affinity\\", \\"update_strategy\\": \\"updateStrategy\\"},
)
class LaceworkAgentDaemonset:
    def __init__(
        self,
        *,
        affinity: typing.Union[IoK8SApiCoreV1Affinity, typing.Dict[builtins.str, typing.Any]],
        update_strategy: typing.Union[IoK8SApiCoreV1DaemonSetUpdateStrategy, typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''
        :param affinity: If specified, the pod's scheduling constraints.
        :param update_strategy: An update strategy to replace existing DaemonSet pods with new pods.

        :schema: LaceworkAgentDaemonset
        '''
        if isinstance(affinity, dict):
            affinity = IoK8SApiCoreV1Affinity(**affinity)
        if isinstance(update_strategy, dict):
            update_strategy = IoK8SApiCoreV1DaemonSetUpdateStrategy(**update_strategy)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8865f58784f4c0cc708c5b4fff21b85d0aa02c8830ebe0c003e678386afd20c6)
            check_type(argname=\\"argument affinity\\", value=affinity, expected_type=type_hints[\\"affinity\\"])
            check_type(argname=\\"argument update_strategy\\", value=update_strategy, expected_type=type_hints[\\"update_strategy\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            \\"affinity\\": affinity,
            \\"update_strategy\\": update_strategy,
        }

    @builtins.property
    def affinity(self) -> IoK8SApiCoreV1Affinity:
        '''If specified, the pod's scheduling constraints.

        :schema: LaceworkAgentDaemonset#affinity
        '''
        result = self._values.get(\\"affinity\\")
        assert result is not None, \\"Required property 'affinity' is missing\\"
        return typing.cast(IoK8SApiCoreV1Affinity, result)

    @builtins.property
    def update_strategy(self) -> IoK8SApiCoreV1DaemonSetUpdateStrategy:
        '''An update strategy to replace existing DaemonSet pods with new pods.

        :schema: LaceworkAgentDaemonset#updateStrategy
        '''
        result = self._values.get(\\"update_strategy\\")
        assert result is not None, \\"Required property 'update_strategy' is missing\\"
        return typing.cast(IoK8SApiCoreV1DaemonSetUpdateStrategy, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"LaceworkAgentDaemonset(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type=\\"lacework-agent.LaceworkAgentDatacollector\\",
    jsii_struct_bases=[],
    name_mapping={\\"additional_values\\": \\"additionalValues\\", \\"enable\\": \\"enable\\"},
)
class LaceworkAgentDatacollector:
    def __init__(
        self,
        *,
        additional_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        enable: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param additional_values: Values that are not available in values.schema.json will not be code generated. You can add such values to this property.
        :param enable: Enable lacework datacollector.

        :schema: LaceworkAgentDatacollector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f6147c05aec3384656fc31bffde0dfd4f7b09aec7c5989879df33bfa5a918a27)
            check_type(argname=\\"argument additional_values\\", value=additional_values, expected_type=type_hints[\\"additional_values\\"])
            check_type(argname=\\"argument enable\\", value=enable, expected_type=type_hints[\\"enable\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if additional_values is not None:
            self._values[\\"additional_values\\"] = additional_values
        if enable is not None:
            self._values[\\"enable\\"] = enable

    @builtins.property
    def additional_values(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''Values that are not available in values.schema.json will not be code generated. You can add such values to this property.

        :schema: LaceworkAgentDatacollector#additionalValues
        '''
        result = self._values.get(\\"additional_values\\")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def enable(self) -> typing.Optional[builtins.bool]:
        '''Enable lacework datacollector.

        :schema: LaceworkAgentDatacollector#enable
        '''
        result = self._values.get(\\"enable\\")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"LaceworkAgentDatacollector(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type=\\"lacework-agent.LaceworkAgentDeployment\\",
    jsii_struct_bases=[],
    name_mapping={
        \\"affinity\\": \\"affinity\\",
        \\"update_strategy\\": \\"updateStrategy\\",
        \\"priority_class_create\\": \\"priorityClassCreate\\",
        \\"priority_class_name\\": \\"priorityClassName\\",
        \\"priority_class_preemption_policy\\": \\"priorityClassPreemptionPolicy\\",
        \\"priority_class_value\\": \\"priorityClassValue\\",
        \\"resources\\": \\"resources\\",
        \\"tolerations\\": \\"tolerations\\",
    },
)
class LaceworkAgentDeployment:
    def __init__(
        self,
        *,
        affinity: typing.Union[IoK8SApiCoreV1Affinity, typing.Dict[builtins.str, typing.Any]],
        update_strategy: typing.Union[IoK8SApiCoreV1DaemonSetUpdateStrategy, typing.Dict[builtins.str, typing.Any]],
        priority_class_create: typing.Optional[builtins.bool] = None,
        priority_class_name: typing.Optional[builtins.str] = None,
        priority_class_preemption_policy: typing.Optional[builtins.str] = None,
        priority_class_value: typing.Optional[jsii.Number] = None,
        resources: typing.Optional[typing.Union[IoK8SApiCoreV1ResourceRequirements, typing.Dict[builtins.str, typing.Any]]] = None,
        tolerations: typing.Optional[typing.Sequence[typing.Union[IoK8SApiCoreV1Toleration, typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param affinity: If specified, the pod's scheduling constraints.
        :param update_strategy: An update strategy to replace existing DaemonSet pods with new pods.
        :param priority_class_create: If specified, a priority class is created and used to deploy agent.
        :param priority_class_name: If specified, indicates the pod's priority. \\"system-node-critical\\" and \\"system-cluster-critical\\" are two special keywords which indicate the highest priorities with the former being the highest priority. Any other name must be defined by creating a PriorityClass object with that name. If not specified, the pod priority will be default or zero if there is no default.
        :param priority_class_preemption_policy: If specified, it determines if agent pod can preempt a pod with a lower a priority.
        :param priority_class_value: If specified, it represents the priority class value to use.
        :param resources: Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
        :param tolerations: If specified, the pod's tolerations.

        :schema: LaceworkAgentDeployment
        '''
        if isinstance(affinity, dict):
            affinity = IoK8SApiCoreV1Affinity(**affinity)
        if isinstance(update_strategy, dict):
            update_strategy = IoK8SApiCoreV1DaemonSetUpdateStrategy(**update_strategy)
        if isinstance(resources, dict):
            resources = IoK8SApiCoreV1ResourceRequirements(**resources)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__787d1f6f42b54e0d6cad91b099f0e65026246f3e2b10b3a1f8add1f3ea9b4637)
            check_type(argname=\\"argument affinity\\", value=affinity, expected_type=type_hints[\\"affinity\\"])
            check_type(argname=\\"argument update_strategy\\", value=update_strategy, expected_type=type_hints[\\"update_strategy\\"])
            check_type(argname=\\"argument priority_class_create\\", value=priority_class_create, expected_type=type_hints[\\"priority_class_create\\"])
            check_type(argname=\\"argument priority_class_name\\", value=priority_class_name, expected_type=type_hints[\\"priority_class_name\\"])
            check_type(argname=\\"argument priority_class_preemption_policy\\", value=priority_class_preemption_policy, expected_type=type_hints[\\"priority_class_preemption_policy\\"])
            check_type(argname=\\"argument priority_class_value\\", value=priority_class_value, expected_type=type_hints[\\"priority_class_value\\"])
            check_type(argname=\\"argument resources\\", value=resources, expected_type=type_hints[\\"resources\\"])
            check_type(argname=\\"argument tolerations\\", value=tolerations, expected_type=type_hints[\\"tolerations\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            \\"affinity\\": affinity,
            \\"update_strategy\\": update_strategy,
        }
        if priority_class_create is not None:
            self._values[\\"priority_class_create\\"] = priority_class_create
        if priority_class_name is not None:
            self._values[\\"priority_class_name\\"] = priority_class_name
        if priority_class_preemption_policy is not None:
            self._values[\\"priority_class_preemption_policy\\"] = priority_class_preemption_policy
        if priority_class_value is not None:
            self._values[\\"priority_class_value\\"] = priority_class_value
        if resources is not None:
            self._values[\\"resources\\"] = resources
        if tolerations is not None:
            self._values[\\"tolerations\\"] = tolerations

    @builtins.property
    def affinity(self) -> IoK8SApiCoreV1Affinity:
        '''If specified, the pod's scheduling constraints.

        :schema: LaceworkAgentDeployment#affinity
        '''
        result = self._values.get(\\"affinity\\")
        assert result is not None, \\"Required property 'affinity' is missing\\"
        return typing.cast(IoK8SApiCoreV1Affinity, result)

    @builtins.property
    def update_strategy(self) -> IoK8SApiCoreV1DaemonSetUpdateStrategy:
        '''An update strategy to replace existing DaemonSet pods with new pods.

        :schema: LaceworkAgentDeployment#updateStrategy
        '''
        result = self._values.get(\\"update_strategy\\")
        assert result is not None, \\"Required property 'update_strategy' is missing\\"
        return typing.cast(IoK8SApiCoreV1DaemonSetUpdateStrategy, result)

    @builtins.property
    def priority_class_create(self) -> typing.Optional[builtins.bool]:
        '''If specified, a priority class is created and used to deploy agent.

        :schema: LaceworkAgentDeployment#priorityClassCreate
        '''
        result = self._values.get(\\"priority_class_create\\")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def priority_class_name(self) -> typing.Optional[builtins.str]:
        '''If specified, indicates the pod's priority.

        \\"system-node-critical\\" and \\"system-cluster-critical\\" are two special keywords which indicate the highest priorities with the former being the highest priority. Any other name must be defined by creating a PriorityClass object with that name. If not specified, the pod priority will be default or zero if there is no default.

        :schema: LaceworkAgentDeployment#priorityClassName
        '''
        result = self._values.get(\\"priority_class_name\\")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def priority_class_preemption_policy(self) -> typing.Optional[builtins.str]:
        '''If specified, it determines if agent pod can preempt a pod with a lower a priority.

        :schema: LaceworkAgentDeployment#priorityClassPreemptionPolicy
        '''
        result = self._values.get(\\"priority_class_preemption_policy\\")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def priority_class_value(self) -> typing.Optional[jsii.Number]:
        '''If specified, it represents the priority class value to use.

        :schema: LaceworkAgentDeployment#priorityClassValue
        '''
        result = self._values.get(\\"priority_class_value\\")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def resources(self) -> typing.Optional[IoK8SApiCoreV1ResourceRequirements]:
        '''Compute Resources required by this container.

        Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/

        :schema: LaceworkAgentDeployment#resources
        '''
        result = self._values.get(\\"resources\\")
        return typing.cast(typing.Optional[IoK8SApiCoreV1ResourceRequirements], result)

    @builtins.property
    def tolerations(self) -> typing.Optional[typing.List[IoK8SApiCoreV1Toleration]]:
        '''If specified, the pod's tolerations.

        :schema: LaceworkAgentDeployment#tolerations
        '''
        result = self._values.get(\\"tolerations\\")
        return typing.cast(typing.Optional[typing.List[IoK8SApiCoreV1Toleration]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"LaceworkAgentDeployment(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type=\\"lacework-agent.LaceworkAgentImage\\",
    jsii_struct_bases=[],
    name_mapping={
        \\"pull_policy\\": \\"pullPolicy\\",
        \\"registry\\": \\"registry\\",
        \\"repository\\": \\"repository\\",
        \\"tag\\": \\"tag\\",
        \\"additional_values\\": \\"additionalValues\\",
        \\"image_pull_secrets\\": \\"imagePullSecrets\\",
        \\"override_value\\": \\"overrideValue\\",
    },
)
class LaceworkAgentImage:
    def __init__(
        self,
        *,
        pull_policy: \\"LaceworkAgentImagePullPolicy\\",
        registry: builtins.str,
        repository: builtins.str,
        tag: builtins.str,
        additional_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        image_pull_secrets: typing.Optional[typing.Sequence[typing.Union[IoK8SApiCoreV1LocalObjectReference, typing.Dict[builtins.str, typing.Any]]]] = None,
        override_value: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param pull_policy: Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images Possible enum values: - \`\`\\"Always\\"\`\` means that kubelet always attempts to pull the latest image. Container will fail If the pull fails. - \`\`\\"IfNotPresent\\"\`\` means that kubelet pulls if the image isn't present on disk. Container will fail if the image isn't present and the pull fails. - \`\`\\"Never\\"\`\` means that kubelet never pulls an image, but only uses a local image. Container will fail if the image isn't present Default: Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
        :param registry: 
        :param repository: 
        :param tag: 
        :param additional_values: Values that are not available in values.schema.json will not be code generated. You can add such values to this property.
        :param image_pull_secrets: ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec. If specified, these secrets will be passed to individual puller implementations for them to use. More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod
        :param override_value: 

        :schema: LaceworkAgentImage
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4c0a83a494e348ea80a80280a82eb843acacd28d70ef2adf7d118c45b12ca124)
            check_type(argname=\\"argument pull_policy\\", value=pull_policy, expected_type=type_hints[\\"pull_policy\\"])
            check_type(argname=\\"argument registry\\", value=registry, expected_type=type_hints[\\"registry\\"])
            check_type(argname=\\"argument repository\\", value=repository, expected_type=type_hints[\\"repository\\"])
            check_type(argname=\\"argument tag\\", value=tag, expected_type=type_hints[\\"tag\\"])
            check_type(argname=\\"argument additional_values\\", value=additional_values, expected_type=type_hints[\\"additional_values\\"])
            check_type(argname=\\"argument image_pull_secrets\\", value=image_pull_secrets, expected_type=type_hints[\\"image_pull_secrets\\"])
            check_type(argname=\\"argument override_value\\", value=override_value, expected_type=type_hints[\\"override_value\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            \\"pull_policy\\": pull_policy,
            \\"registry\\": registry,
            \\"repository\\": repository,
            \\"tag\\": tag,
        }
        if additional_values is not None:
            self._values[\\"additional_values\\"] = additional_values
        if image_pull_secrets is not None:
            self._values[\\"image_pull_secrets\\"] = image_pull_secrets
        if override_value is not None:
            self._values[\\"override_value\\"] = override_value

    @builtins.property
    def pull_policy(self) -> \\"LaceworkAgentImagePullPolicy\\":
        '''Image pull policy.

        One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images

        Possible enum values:

        - \`\`\\"Always\\"\`\` means that kubelet always attempts to pull the latest image. Container will fail If the pull fails.
        - \`\`\\"IfNotPresent\\"\`\` means that kubelet pulls if the image isn't present on disk. Container will fail if the image isn't present and the pull fails.
        - \`\`\\"Never\\"\`\` means that kubelet never pulls an image, but only uses a local image. Container will fail if the image isn't present

        :default: Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images

        :schema: LaceworkAgentImage#pullPolicy
        '''
        result = self._values.get(\\"pull_policy\\")
        assert result is not None, \\"Required property 'pull_policy' is missing\\"
        return typing.cast(\\"LaceworkAgentImagePullPolicy\\", result)

    @builtins.property
    def registry(self) -> builtins.str:
        '''
        :schema: LaceworkAgentImage#registry
        '''
        result = self._values.get(\\"registry\\")
        assert result is not None, \\"Required property 'registry' is missing\\"
        return typing.cast(builtins.str, result)

    @builtins.property
    def repository(self) -> builtins.str:
        '''
        :schema: LaceworkAgentImage#repository
        '''
        result = self._values.get(\\"repository\\")
        assert result is not None, \\"Required property 'repository' is missing\\"
        return typing.cast(builtins.str, result)

    @builtins.property
    def tag(self) -> builtins.str:
        '''
        :schema: LaceworkAgentImage#tag
        '''
        result = self._values.get(\\"tag\\")
        assert result is not None, \\"Required property 'tag' is missing\\"
        return typing.cast(builtins.str, result)

    @builtins.property
    def additional_values(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''Values that are not available in values.schema.json will not be code generated. You can add such values to this property.

        :schema: LaceworkAgentImage#additionalValues
        '''
        result = self._values.get(\\"additional_values\\")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def image_pull_secrets(
        self,
    ) -> typing.Optional[typing.List[IoK8SApiCoreV1LocalObjectReference]]:
        '''ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec.

        If specified, these secrets will be passed to individual puller implementations for them to use. More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod

        :schema: LaceworkAgentImage#imagePullSecrets
        '''
        result = self._values.get(\\"image_pull_secrets\\")
        return typing.cast(typing.Optional[typing.List[IoK8SApiCoreV1LocalObjectReference]], result)

    @builtins.property
    def override_value(self) -> typing.Optional[builtins.str]:
        '''
        :schema: LaceworkAgentImage#overrideValue
        '''
        result = self._values.get(\\"override_value\\")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"LaceworkAgentImage(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type=\\"lacework-agent.LaceworkAgentImagePullPolicy\\")
class LaceworkAgentImagePullPolicy(enum.Enum):
    '''Image pull policy.

    One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images

    Possible enum values:

    - \`\`\\"Always\\"\`\` means that kubelet always attempts to pull the latest image. Container will fail If the pull fails.
    - \`\`\\"IfNotPresent\\"\`\` means that kubelet pulls if the image isn't present on disk. Container will fail if the image isn't present and the pull fails.
    - \`\`\\"Never\\"\`\` means that kubelet never pulls an image, but only uses a local image. Container will fail if the image isn't present

    :default: Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images

    :schema: LaceworkAgentImagePullPolicy
    '''

    ALWAYS = \\"ALWAYS\\"
    '''Always.'''
    IF_NOT_PRESENT = \\"IF_NOT_PRESENT\\"
    '''IfNotPresent.'''
    NEVER = \\"NEVER\\"
    '''Never.'''


@jsii.data_type(
    jsii_type=\\"lacework-agent.LaceworkAgentLaceworkConfig\\",
    jsii_struct_bases=[],
    name_mapping={
        \\"access_token\\": \\"accessToken\\",
        \\"additional_values\\": \\"additionalValues\\",
        \\"annotations\\": \\"annotations\\",
        \\"anonymize_incoming\\": \\"anonymizeIncoming\\",
        \\"auto_upgrade\\": \\"autoUpgrade\\",
        \\"cmdlinefilter\\": \\"cmdlinefilter\\",
        \\"codeaware\\": \\"codeaware\\",
        \\"container_engine_endpoint\\": \\"containerEngineEndpoint\\",
        \\"container_runtime\\": \\"containerRuntime\\",
        \\"datacollector\\": \\"datacollector\\",
        \\"env\\": \\"env\\",
        \\"fim\\": \\"fim\\",
        \\"k8_s_node_scrape_interval_mins\\": \\"k8SNodeScrapeIntervalMins\\",
        \\"kubernetes_cluster\\": \\"kubernetesCluster\\",
        \\"labels\\": \\"labels\\",
        \\"metadata_request_interval\\": \\"metadataRequestInterval\\",
        \\"packagescan\\": \\"packagescan\\",
        \\"perfmode\\": \\"perfmode\\",
        \\"procscan\\": \\"procscan\\",
        \\"proxy_url\\": \\"proxyUrl\\",
        \\"server_url\\": \\"serverUrl\\",
        \\"service_account_name\\": \\"serviceAccountName\\",
        \\"stdout_logging\\": \\"stdoutLogging\\",
        \\"tags\\": \\"tags\\",
    },
)
class LaceworkAgentLaceworkConfig:
    def __init__(
        self,
        *,
        access_token: typing.Any,
        additional_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        annotations: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        anonymize_incoming: typing.Optional[typing.Union[\\"LaceworkAgentLaceworkConfigAnonymizeIncoming\\", typing.Dict[builtins.str, typing.Any]]] = None,
        auto_upgrade: typing.Optional[\\"LaceworkAgentLaceworkConfigAutoUpgrade\\"] = None,
        cmdlinefilter: typing.Optional[typing.Union[\\"LaceworkAgentLaceworkConfigCmdlinefilter\\", typing.Dict[builtins.str, typing.Any]]] = None,
        codeaware: typing.Optional[typing.Union[\\"LaceworkAgentLaceworkConfigCodeaware\\", typing.Dict[builtins.str, typing.Any]]] = None,
        container_engine_endpoint: typing.Optional[builtins.str] = None,
        container_runtime: typing.Optional[\\"LaceworkAgentLaceworkConfigContainerRuntime\\"] = None,
        datacollector: typing.Optional[\\"LaceworkAgentLaceworkConfigDatacollector\\"] = None,
        env: typing.Optional[builtins.str] = None,
        fim: typing.Optional[typing.Union[\\"LaceworkAgentLaceworkConfigFim\\", typing.Dict[builtins.str, typing.Any]]] = None,
        k8_s_node_scrape_interval_mins: typing.Optional[jsii.Number] = None,
        kubernetes_cluster: typing.Optional[builtins.str] = None,
        labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        metadata_request_interval: typing.Optional[builtins.str] = None,
        packagescan: typing.Optional[typing.Union[\\"LaceworkAgentLaceworkConfigPackagescan\\", typing.Dict[builtins.str, typing.Any]]] = None,
        perfmode: typing.Optional[\\"LaceworkAgentLaceworkConfigPerfmode\\"] = None,
        procscan: typing.Optional[typing.Union[\\"LaceworkAgentLaceworkConfigProcscan\\", typing.Dict[builtins.str, typing.Any]]] = None,
        proxy_url: typing.Optional[builtins.str] = None,
        server_url: typing.Optional[builtins.str] = None,
        service_account_name: typing.Optional[builtins.str] = None,
        stdout_logging: typing.Optional[builtins.bool] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''
        :param access_token: 
        :param additional_values: Values that are not available in values.schema.json will not be code generated. You can add such values to this property.
        :param annotations: Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
        :param anonymize_incoming: 
        :param auto_upgrade: 
        :param cmdlinefilter: 
        :param codeaware: 
        :param container_engine_endpoint: 
        :param container_runtime: 
        :param datacollector: 
        :param env: 
        :param fim: 
        :param k8_s_node_scrape_interval_mins: Kubernetes node's scrape interval in minutes.
        :param kubernetes_cluster: 
        :param labels: Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
        :param metadata_request_interval: 
        :param packagescan: 
        :param perfmode: 
        :param procscan: 
        :param proxy_url: 
        :param server_url: 
        :param service_account_name: 
        :param stdout_logging: 
        :param tags: 

        :schema: LaceworkAgentLaceworkConfig
        '''
        if isinstance(anonymize_incoming, dict):
            anonymize_incoming = LaceworkAgentLaceworkConfigAnonymizeIncoming(**anonymize_incoming)
        if isinstance(cmdlinefilter, dict):
            cmdlinefilter = LaceworkAgentLaceworkConfigCmdlinefilter(**cmdlinefilter)
        if isinstance(codeaware, dict):
            codeaware = LaceworkAgentLaceworkConfigCodeaware(**codeaware)
        if isinstance(fim, dict):
            fim = LaceworkAgentLaceworkConfigFim(**fim)
        if isinstance(packagescan, dict):
            packagescan = LaceworkAgentLaceworkConfigPackagescan(**packagescan)
        if isinstance(procscan, dict):
            procscan = LaceworkAgentLaceworkConfigProcscan(**procscan)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__137ccaec2780b925802b147c3602013773aba0adcc89e414986c5d5a31ac1a52)
            check_type(argname=\\"argument access_token\\", value=access_token, expected_type=type_hints[\\"access_token\\"])
            check_type(argname=\\"argument additional_values\\", value=additional_values, expected_type=type_hints[\\"additional_values\\"])
            check_type(argname=\\"argument annotations\\", value=annotations, expected_type=type_hints[\\"annotations\\"])
            check_type(argname=\\"argument anonymize_incoming\\", value=anonymize_incoming, expected_type=type_hints[\\"anonymize_incoming\\"])
            check_type(argname=\\"argument auto_upgrade\\", value=auto_upgrade, expected_type=type_hints[\\"auto_upgrade\\"])
            check_type(argname=\\"argument cmdlinefilter\\", value=cmdlinefilter, expected_type=type_hints[\\"cmdlinefilter\\"])
            check_type(argname=\\"argument codeaware\\", value=codeaware, expected_type=type_hints[\\"codeaware\\"])
            check_type(argname=\\"argument container_engine_endpoint\\", value=container_engine_endpoint, expected_type=type_hints[\\"container_engine_endpoint\\"])
            check_type(argname=\\"argument container_runtime\\", value=container_runtime, expected_type=type_hints[\\"container_runtime\\"])
            check_type(argname=\\"argument datacollector\\", value=datacollector, expected_type=type_hints[\\"datacollector\\"])
            check_type(argname=\\"argument env\\", value=env, expected_type=type_hints[\\"env\\"])
            check_type(argname=\\"argument fim\\", value=fim, expected_type=type_hints[\\"fim\\"])
            check_type(argname=\\"argument k8_s_node_scrape_interval_mins\\", value=k8_s_node_scrape_interval_mins, expected_type=type_hints[\\"k8_s_node_scrape_interval_mins\\"])
            check_type(argname=\\"argument kubernetes_cluster\\", value=kubernetes_cluster, expected_type=type_hints[\\"kubernetes_cluster\\"])
            check_type(argname=\\"argument labels\\", value=labels, expected_type=type_hints[\\"labels\\"])
            check_type(argname=\\"argument metadata_request_interval\\", value=metadata_request_interval, expected_type=type_hints[\\"metadata_request_interval\\"])
            check_type(argname=\\"argument packagescan\\", value=packagescan, expected_type=type_hints[\\"packagescan\\"])
            check_type(argname=\\"argument perfmode\\", value=perfmode, expected_type=type_hints[\\"perfmode\\"])
            check_type(argname=\\"argument procscan\\", value=procscan, expected_type=type_hints[\\"procscan\\"])
            check_type(argname=\\"argument proxy_url\\", value=proxy_url, expected_type=type_hints[\\"proxy_url\\"])
            check_type(argname=\\"argument server_url\\", value=server_url, expected_type=type_hints[\\"server_url\\"])
            check_type(argname=\\"argument service_account_name\\", value=service_account_name, expected_type=type_hints[\\"service_account_name\\"])
            check_type(argname=\\"argument stdout_logging\\", value=stdout_logging, expected_type=type_hints[\\"stdout_logging\\"])
            check_type(argname=\\"argument tags\\", value=tags, expected_type=type_hints[\\"tags\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            \\"access_token\\": access_token,
        }
        if additional_values is not None:
            self._values[\\"additional_values\\"] = additional_values
        if annotations is not None:
            self._values[\\"annotations\\"] = annotations
        if anonymize_incoming is not None:
            self._values[\\"anonymize_incoming\\"] = anonymize_incoming
        if auto_upgrade is not None:
            self._values[\\"auto_upgrade\\"] = auto_upgrade
        if cmdlinefilter is not None:
            self._values[\\"cmdlinefilter\\"] = cmdlinefilter
        if codeaware is not None:
            self._values[\\"codeaware\\"] = codeaware
        if container_engine_endpoint is not None:
            self._values[\\"container_engine_endpoint\\"] = container_engine_endpoint
        if container_runtime is not None:
            self._values[\\"container_runtime\\"] = container_runtime
        if datacollector is not None:
            self._values[\\"datacollector\\"] = datacollector
        if env is not None:
            self._values[\\"env\\"] = env
        if fim is not None:
            self._values[\\"fim\\"] = fim
        if k8_s_node_scrape_interval_mins is not None:
            self._values[\\"k8_s_node_scrape_interval_mins\\"] = k8_s_node_scrape_interval_mins
        if kubernetes_cluster is not None:
            self._values[\\"kubernetes_cluster\\"] = kubernetes_cluster
        if labels is not None:
            self._values[\\"labels\\"] = labels
        if metadata_request_interval is not None:
            self._values[\\"metadata_request_interval\\"] = metadata_request_interval
        if packagescan is not None:
            self._values[\\"packagescan\\"] = packagescan
        if perfmode is not None:
            self._values[\\"perfmode\\"] = perfmode
        if procscan is not None:
            self._values[\\"procscan\\"] = procscan
        if proxy_url is not None:
            self._values[\\"proxy_url\\"] = proxy_url
        if server_url is not None:
            self._values[\\"server_url\\"] = server_url
        if service_account_name is not None:
            self._values[\\"service_account_name\\"] = service_account_name
        if stdout_logging is not None:
            self._values[\\"stdout_logging\\"] = stdout_logging
        if tags is not None:
            self._values[\\"tags\\"] = tags

    @builtins.property
    def access_token(self) -> typing.Any:
        '''
        :schema: LaceworkAgentLaceworkConfig#accessToken
        '''
        result = self._values.get(\\"access_token\\")
        assert result is not None, \\"Required property 'access_token' is missing\\"
        return typing.cast(typing.Any, result)

    @builtins.property
    def additional_values(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''Values that are not available in values.schema.json will not be code generated. You can add such values to this property.

        :schema: LaceworkAgentLaceworkConfig#additionalValues
        '''
        result = self._values.get(\\"additional_values\\")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def annotations(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata.

        They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations

        :schema: LaceworkAgentLaceworkConfig#annotations
        '''
        result = self._values.get(\\"annotations\\")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def anonymize_incoming(
        self,
    ) -> typing.Optional[\\"LaceworkAgentLaceworkConfigAnonymizeIncoming\\"]:
        '''
        :schema: LaceworkAgentLaceworkConfig#anonymizeIncoming
        '''
        result = self._values.get(\\"anonymize_incoming\\")
        return typing.cast(typing.Optional[\\"LaceworkAgentLaceworkConfigAnonymizeIncoming\\"], result)

    @builtins.property
    def auto_upgrade(self) -> typing.Optional[\\"LaceworkAgentLaceworkConfigAutoUpgrade\\"]:
        '''
        :schema: LaceworkAgentLaceworkConfig#autoUpgrade
        '''
        result = self._values.get(\\"auto_upgrade\\")
        return typing.cast(typing.Optional[\\"LaceworkAgentLaceworkConfigAutoUpgrade\\"], result)

    @builtins.property
    def cmdlinefilter(
        self,
    ) -> typing.Optional[\\"LaceworkAgentLaceworkConfigCmdlinefilter\\"]:
        '''
        :schema: LaceworkAgentLaceworkConfig#cmdlinefilter
        '''
        result = self._values.get(\\"cmdlinefilter\\")
        return typing.cast(typing.Optional[\\"LaceworkAgentLaceworkConfigCmdlinefilter\\"], result)

    @builtins.property
    def codeaware(self) -> typing.Optional[\\"LaceworkAgentLaceworkConfigCodeaware\\"]:
        '''
        :schema: LaceworkAgentLaceworkConfig#codeaware
        '''
        result = self._values.get(\\"codeaware\\")
        return typing.cast(typing.Optional[\\"LaceworkAgentLaceworkConfigCodeaware\\"], result)

    @builtins.property
    def container_engine_endpoint(self) -> typing.Optional[builtins.str]:
        '''
        :schema: LaceworkAgentLaceworkConfig#containerEngineEndpoint
        '''
        result = self._values.get(\\"container_engine_endpoint\\")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def container_runtime(
        self,
    ) -> typing.Optional[\\"LaceworkAgentLaceworkConfigContainerRuntime\\"]:
        '''
        :schema: LaceworkAgentLaceworkConfig#containerRuntime
        '''
        result = self._values.get(\\"container_runtime\\")
        return typing.cast(typing.Optional[\\"LaceworkAgentLaceworkConfigContainerRuntime\\"], result)

    @builtins.property
    def datacollector(
        self,
    ) -> typing.Optional[\\"LaceworkAgentLaceworkConfigDatacollector\\"]:
        '''
        :schema: LaceworkAgentLaceworkConfig#datacollector
        '''
        result = self._values.get(\\"datacollector\\")
        return typing.cast(typing.Optional[\\"LaceworkAgentLaceworkConfigDatacollector\\"], result)

    @builtins.property
    def env(self) -> typing.Optional[builtins.str]:
        '''
        :schema: LaceworkAgentLaceworkConfig#env
        '''
        result = self._values.get(\\"env\\")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def fim(self) -> typing.Optional[\\"LaceworkAgentLaceworkConfigFim\\"]:
        '''
        :schema: LaceworkAgentLaceworkConfig#fim
        '''
        result = self._values.get(\\"fim\\")
        return typing.cast(typing.Optional[\\"LaceworkAgentLaceworkConfigFim\\"], result)

    @builtins.property
    def k8_s_node_scrape_interval_mins(self) -> typing.Optional[jsii.Number]:
        '''Kubernetes node's scrape interval in minutes.

        :schema: LaceworkAgentLaceworkConfig#k8sNodeScrapeIntervalMins
        '''
        result = self._values.get(\\"k8_s_node_scrape_interval_mins\\")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def kubernetes_cluster(self) -> typing.Optional[builtins.str]:
        '''
        :schema: LaceworkAgentLaceworkConfig#kubernetesCluster
        '''
        result = self._values.get(\\"kubernetes_cluster\\")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def labels(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Map of string keys and values that can be used to organize and categorize (scope and select) objects.

        May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels

        :schema: LaceworkAgentLaceworkConfig#labels
        '''
        result = self._values.get(\\"labels\\")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def metadata_request_interval(self) -> typing.Optional[builtins.str]:
        '''
        :schema: LaceworkAgentLaceworkConfig#metadataRequestInterval
        '''
        result = self._values.get(\\"metadata_request_interval\\")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def packagescan(self) -> typing.Optional[\\"LaceworkAgentLaceworkConfigPackagescan\\"]:
        '''
        :schema: LaceworkAgentLaceworkConfig#packagescan
        '''
        result = self._values.get(\\"packagescan\\")
        return typing.cast(typing.Optional[\\"LaceworkAgentLaceworkConfigPackagescan\\"], result)

    @builtins.property
    def perfmode(self) -> typing.Optional[\\"LaceworkAgentLaceworkConfigPerfmode\\"]:
        '''
        :schema: LaceworkAgentLaceworkConfig#perfmode
        '''
        result = self._values.get(\\"perfmode\\")
        return typing.cast(typing.Optional[\\"LaceworkAgentLaceworkConfigPerfmode\\"], result)

    @builtins.property
    def procscan(self) -> typing.Optional[\\"LaceworkAgentLaceworkConfigProcscan\\"]:
        '''
        :schema: LaceworkAgentLaceworkConfig#procscan
        '''
        result = self._values.get(\\"procscan\\")
        return typing.cast(typing.Optional[\\"LaceworkAgentLaceworkConfigProcscan\\"], result)

    @builtins.property
    def proxy_url(self) -> typing.Optional[builtins.str]:
        '''
        :schema: LaceworkAgentLaceworkConfig#proxyUrl
        '''
        result = self._values.get(\\"proxy_url\\")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def server_url(self) -> typing.Optional[builtins.str]:
        '''
        :schema: LaceworkAgentLaceworkConfig#serverUrl
        '''
        result = self._values.get(\\"server_url\\")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def service_account_name(self) -> typing.Optional[builtins.str]:
        '''
        :schema: LaceworkAgentLaceworkConfig#serviceAccountName
        '''
        result = self._values.get(\\"service_account_name\\")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def stdout_logging(self) -> typing.Optional[builtins.bool]:
        '''
        :schema: LaceworkAgentLaceworkConfig#stdoutLogging
        '''
        result = self._values.get(\\"stdout_logging\\")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :schema: LaceworkAgentLaceworkConfig#tags
        '''
        result = self._values.get(\\"tags\\")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"LaceworkAgentLaceworkConfig(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type=\\"lacework-agent.LaceworkAgentLaceworkConfigAnonymizeIncoming\\",
    jsii_struct_bases=[],
    name_mapping={\\"additional_values\\": \\"additionalValues\\", \\"netmask\\": \\"netmask\\"},
)
class LaceworkAgentLaceworkConfigAnonymizeIncoming:
    def __init__(
        self,
        *,
        additional_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        netmask: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param additional_values: Values that are not available in values.schema.json will not be code generated. You can add such values to this property.
        :param netmask: 

        :schema: LaceworkAgentLaceworkConfigAnonymizeIncoming
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cae19ba49ffeb3756e422ae55a616d552a7b1a48e805ed6342cdcedeb898252d)
            check_type(argname=\\"argument additional_values\\", value=additional_values, expected_type=type_hints[\\"additional_values\\"])
            check_type(argname=\\"argument netmask\\", value=netmask, expected_type=type_hints[\\"netmask\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if additional_values is not None:
            self._values[\\"additional_values\\"] = additional_values
        if netmask is not None:
            self._values[\\"netmask\\"] = netmask

    @builtins.property
    def additional_values(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''Values that are not available in values.schema.json will not be code generated. You can add such values to this property.

        :schema: LaceworkAgentLaceworkConfigAnonymizeIncoming#additionalValues
        '''
        result = self._values.get(\\"additional_values\\")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def netmask(self) -> typing.Optional[builtins.str]:
        '''
        :schema: LaceworkAgentLaceworkConfigAnonymizeIncoming#netmask
        '''
        result = self._values.get(\\"netmask\\")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"LaceworkAgentLaceworkConfigAnonymizeIncoming(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type=\\"lacework-agent.LaceworkAgentLaceworkConfigAutoUpgrade\\")
class LaceworkAgentLaceworkConfigAutoUpgrade(enum.Enum):
    '''
    :schema: LaceworkAgentLaceworkConfigAutoUpgrade
    '''

    DISABLE = \\"DISABLE\\"
    '''disable.'''
    ENABLE = \\"ENABLE\\"
    '''enable.'''


@jsii.data_type(
    jsii_type=\\"lacework-agent.LaceworkAgentLaceworkConfigCmdlinefilter\\",
    jsii_struct_bases=[],
    name_mapping={\\"allow\\": \\"allow\\", \\"disallow\\": \\"disallow\\"},
)
class LaceworkAgentLaceworkConfigCmdlinefilter:
    def __init__(
        self,
        *,
        allow: typing.Optional[builtins.str] = None,
        disallow: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param allow: 
        :param disallow: 

        :schema: LaceworkAgentLaceworkConfigCmdlinefilter
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d49626aa144236418ebd376e1f10ea94398ba5fc8167c20717e1b2e7d5629eb9)
            check_type(argname=\\"argument allow\\", value=allow, expected_type=type_hints[\\"allow\\"])
            check_type(argname=\\"argument disallow\\", value=disallow, expected_type=type_hints[\\"disallow\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if allow is not None:
            self._values[\\"allow\\"] = allow
        if disallow is not None:
            self._values[\\"disallow\\"] = disallow

    @builtins.property
    def allow(self) -> typing.Optional[builtins.str]:
        '''
        :schema: LaceworkAgentLaceworkConfigCmdlinefilter#allow
        '''
        result = self._values.get(\\"allow\\")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def disallow(self) -> typing.Optional[builtins.str]:
        '''
        :schema: LaceworkAgentLaceworkConfigCmdlinefilter#disallow
        '''
        result = self._values.get(\\"disallow\\")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"LaceworkAgentLaceworkConfigCmdlinefilter(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type=\\"lacework-agent.LaceworkAgentLaceworkConfigCodeaware\\",
    jsii_struct_bases=[],
    name_mapping={\\"enable\\": \\"enable\\"},
)
class LaceworkAgentLaceworkConfigCodeaware:
    def __init__(self, *, enable: typing.Optional[builtins.bool] = None) -> None:
        '''
        :param enable: 

        :schema: LaceworkAgentLaceworkConfigCodeaware
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5882a8edec8095b7334e91a883a0e95f3d4d4a8f83a44c6e4483316a2267bf63)
            check_type(argname=\\"argument enable\\", value=enable, expected_type=type_hints[\\"enable\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if enable is not None:
            self._values[\\"enable\\"] = enable

    @builtins.property
    def enable(self) -> typing.Optional[builtins.bool]:
        '''
        :schema: LaceworkAgentLaceworkConfigCodeaware#enable
        '''
        result = self._values.get(\\"enable\\")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"LaceworkAgentLaceworkConfigCodeaware(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type=\\"lacework-agent.LaceworkAgentLaceworkConfigContainerRuntime\\")
class LaceworkAgentLaceworkConfigContainerRuntime(enum.Enum):
    '''
    :schema: LaceworkAgentLaceworkConfigContainerRuntime
    '''

    CONTAINERD = \\"CONTAINERD\\"
    '''containerd.'''
    CRI_HYPHEN_O = \\"CRI_HYPHEN_O\\"
    '''cri-o.'''
    DOCKER = \\"DOCKER\\"
    '''docker.'''


@jsii.enum(jsii_type=\\"lacework-agent.LaceworkAgentLaceworkConfigDatacollector\\")
class LaceworkAgentLaceworkConfigDatacollector(enum.Enum):
    '''
    :schema: LaceworkAgentLaceworkConfigDatacollector
    '''

    DISABLE = \\"DISABLE\\"
    '''disable.'''
    ENABLE = \\"ENABLE\\"
    '''enable.'''


@jsii.data_type(
    jsii_type=\\"lacework-agent.LaceworkAgentLaceworkConfigFim\\",
    jsii_struct_bases=[],
    name_mapping={
        \\"enable\\": \\"enable\\",
        \\"file_ignore\\": \\"fileIgnore\\",
        \\"file_path\\": \\"filePath\\",
        \\"additional_values\\": \\"additionalValues\\",
        \\"cooling_period\\": \\"coolingPeriod\\",
        \\"crawl_interval\\": \\"crawlInterval\\",
        \\"no_atime\\": \\"noAtime\\",
        \\"run_at\\": \\"runAt\\",
    },
)
class LaceworkAgentLaceworkConfigFim:
    def __init__(
        self,
        *,
        enable: builtins.bool,
        file_ignore: typing.Sequence[builtins.str],
        file_path: typing.Sequence[builtins.str],
        additional_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        cooling_period: typing.Optional[jsii.Number] = None,
        crawl_interval: typing.Optional[jsii.Number] = None,
        no_atime: typing.Optional[builtins.bool] = None,
        run_at: typing.Any = None,
    ) -> None:
        '''
        :param enable: 
        :param file_ignore: 
        :param file_path: 
        :param additional_values: Values that are not available in values.schema.json will not be code generated. You can add such values to this property.
        :param cooling_period: 
        :param crawl_interval: 
        :param no_atime: 
        :param run_at: 

        :schema: LaceworkAgentLaceworkConfigFim
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3a82613c3b10f84fd3c85552b1bf3d3eb0de5e479e129b12fa8986455f413ed2)
            check_type(argname=\\"argument enable\\", value=enable, expected_type=type_hints[\\"enable\\"])
            check_type(argname=\\"argument file_ignore\\", value=file_ignore, expected_type=type_hints[\\"file_ignore\\"])
            check_type(argname=\\"argument file_path\\", value=file_path, expected_type=type_hints[\\"file_path\\"])
            check_type(argname=\\"argument additional_values\\", value=additional_values, expected_type=type_hints[\\"additional_values\\"])
            check_type(argname=\\"argument cooling_period\\", value=cooling_period, expected_type=type_hints[\\"cooling_period\\"])
            check_type(argname=\\"argument crawl_interval\\", value=crawl_interval, expected_type=type_hints[\\"crawl_interval\\"])
            check_type(argname=\\"argument no_atime\\", value=no_atime, expected_type=type_hints[\\"no_atime\\"])
            check_type(argname=\\"argument run_at\\", value=run_at, expected_type=type_hints[\\"run_at\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            \\"enable\\": enable,
            \\"file_ignore\\": file_ignore,
            \\"file_path\\": file_path,
        }
        if additional_values is not None:
            self._values[\\"additional_values\\"] = additional_values
        if cooling_period is not None:
            self._values[\\"cooling_period\\"] = cooling_period
        if crawl_interval is not None:
            self._values[\\"crawl_interval\\"] = crawl_interval
        if no_atime is not None:
            self._values[\\"no_atime\\"] = no_atime
        if run_at is not None:
            self._values[\\"run_at\\"] = run_at

    @builtins.property
    def enable(self) -> builtins.bool:
        '''
        :schema: LaceworkAgentLaceworkConfigFim#enable
        '''
        result = self._values.get(\\"enable\\")
        assert result is not None, \\"Required property 'enable' is missing\\"
        return typing.cast(builtins.bool, result)

    @builtins.property
    def file_ignore(self) -> typing.List[builtins.str]:
        '''
        :schema: LaceworkAgentLaceworkConfigFim#fileIgnore
        '''
        result = self._values.get(\\"file_ignore\\")
        assert result is not None, \\"Required property 'file_ignore' is missing\\"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def file_path(self) -> typing.List[builtins.str]:
        '''
        :schema: LaceworkAgentLaceworkConfigFim#filePath
        '''
        result = self._values.get(\\"file_path\\")
        assert result is not None, \\"Required property 'file_path' is missing\\"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def additional_values(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''Values that are not available in values.schema.json will not be code generated. You can add such values to this property.

        :schema: LaceworkAgentLaceworkConfigFim#additionalValues
        '''
        result = self._values.get(\\"additional_values\\")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def cooling_period(self) -> typing.Optional[jsii.Number]:
        '''
        :schema: LaceworkAgentLaceworkConfigFim#coolingPeriod
        '''
        result = self._values.get(\\"cooling_period\\")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def crawl_interval(self) -> typing.Optional[jsii.Number]:
        '''
        :schema: LaceworkAgentLaceworkConfigFim#crawlInterval
        '''
        result = self._values.get(\\"crawl_interval\\")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def no_atime(self) -> typing.Optional[builtins.bool]:
        '''
        :schema: LaceworkAgentLaceworkConfigFim#noAtime
        '''
        result = self._values.get(\\"no_atime\\")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def run_at(self) -> typing.Any:
        '''
        :schema: LaceworkAgentLaceworkConfigFim#runAt
        '''
        result = self._values.get(\\"run_at\\")
        return typing.cast(typing.Any, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"LaceworkAgentLaceworkConfigFim(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type=\\"lacework-agent.LaceworkAgentLaceworkConfigPackagescan\\",
    jsii_struct_bases=[],
    name_mapping={\\"enable\\": \\"enable\\", \\"interval\\": \\"interval\\"},
)
class LaceworkAgentLaceworkConfigPackagescan:
    def __init__(
        self,
        *,
        enable: typing.Optional[builtins.bool] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param enable: 
        :param interval: 

        :schema: LaceworkAgentLaceworkConfigPackagescan
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7a28ae402580638d4ca326df3f41bd0b2997d028ee2ad046ae4834bceb9580ee)
            check_type(argname=\\"argument enable\\", value=enable, expected_type=type_hints[\\"enable\\"])
            check_type(argname=\\"argument interval\\", value=interval, expected_type=type_hints[\\"interval\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if enable is not None:
            self._values[\\"enable\\"] = enable
        if interval is not None:
            self._values[\\"interval\\"] = interval

    @builtins.property
    def enable(self) -> typing.Optional[builtins.bool]:
        '''
        :schema: LaceworkAgentLaceworkConfigPackagescan#enable
        '''
        result = self._values.get(\\"enable\\")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''
        :schema: LaceworkAgentLaceworkConfigPackagescan#interval
        '''
        result = self._values.get(\\"interval\\")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"LaceworkAgentLaceworkConfigPackagescan(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type=\\"lacework-agent.LaceworkAgentLaceworkConfigPerfmode\\")
class LaceworkAgentLaceworkConfigPerfmode(enum.Enum):
    '''
    :schema: LaceworkAgentLaceworkConfigPerfmode
    '''

    LITE = \\"LITE\\"
    '''lite.'''
    SCAN = \\"SCAN\\"
    '''scan.'''
    EBPFLITE = \\"EBPFLITE\\"
    '''ebpflite.'''


@jsii.data_type(
    jsii_type=\\"lacework-agent.LaceworkAgentLaceworkConfigProcscan\\",
    jsii_struct_bases=[],
    name_mapping={\\"enable\\": \\"enable\\", \\"interval\\": \\"interval\\"},
)
class LaceworkAgentLaceworkConfigProcscan:
    def __init__(
        self,
        *,
        enable: typing.Optional[builtins.bool] = None,
        interval: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param enable: 
        :param interval: 

        :schema: LaceworkAgentLaceworkConfigProcscan
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__574fdc26e474c6dcbd22d3b5de880518aa899c6e4ac43317fce728e591c17e31)
            check_type(argname=\\"argument enable\\", value=enable, expected_type=type_hints[\\"enable\\"])
            check_type(argname=\\"argument interval\\", value=interval, expected_type=type_hints[\\"interval\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if enable is not None:
            self._values[\\"enable\\"] = enable
        if interval is not None:
            self._values[\\"interval\\"] = interval

    @builtins.property
    def enable(self) -> typing.Optional[builtins.bool]:
        '''
        :schema: LaceworkAgentLaceworkConfigProcscan#enable
        '''
        result = self._values.get(\\"enable\\")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def interval(self) -> typing.Optional[jsii.Number]:
        '''
        :schema: LaceworkAgentLaceworkConfigProcscan#interval
        '''
        result = self._values.get(\\"interval\\")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"LaceworkAgentLaceworkConfigProcscan(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type=\\"lacework-agent.LaceworkAgentProps\\",
    jsii_struct_bases=[],
    name_mapping={
        \\"values\\": \\"values\\",
        \\"helm_executable\\": \\"helmExecutable\\",
        \\"helm_flags\\": \\"helmFlags\\",
        \\"namespace\\": \\"namespace\\",
        \\"release_name\\": \\"releaseName\\",
    },
)
class LaceworkAgentProps:
    def __init__(
        self,
        *,
        values: typing.Union[\\"LaceworkAgentValues\\", typing.Dict[builtins.str, typing.Any]],
        helm_executable: typing.Optional[builtins.str] = None,
        helm_flags: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace: typing.Optional[builtins.str] = None,
        release_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param values: -
        :param helm_executable: -
        :param helm_flags: -
        :param namespace: -
        :param release_name: -
        '''
        if isinstance(values, dict):
            values = LaceworkAgentValues(**values)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ea49c8097c79e425efc522f130af588a0f59b5954b4b8e97db8870d745183bad)
            check_type(argname=\\"argument values\\", value=values, expected_type=type_hints[\\"values\\"])
            check_type(argname=\\"argument helm_executable\\", value=helm_executable, expected_type=type_hints[\\"helm_executable\\"])
            check_type(argname=\\"argument helm_flags\\", value=helm_flags, expected_type=type_hints[\\"helm_flags\\"])
            check_type(argname=\\"argument namespace\\", value=namespace, expected_type=type_hints[\\"namespace\\"])
            check_type(argname=\\"argument release_name\\", value=release_name, expected_type=type_hints[\\"release_name\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            \\"values\\": values,
        }
        if helm_executable is not None:
            self._values[\\"helm_executable\\"] = helm_executable
        if helm_flags is not None:
            self._values[\\"helm_flags\\"] = helm_flags
        if namespace is not None:
            self._values[\\"namespace\\"] = namespace
        if release_name is not None:
            self._values[\\"release_name\\"] = release_name

    @builtins.property
    def values(self) -> \\"LaceworkAgentValues\\":
        result = self._values.get(\\"values\\")
        assert result is not None, \\"Required property 'values' is missing\\"
        return typing.cast(\\"LaceworkAgentValues\\", result)

    @builtins.property
    def helm_executable(self) -> typing.Optional[builtins.str]:
        result = self._values.get(\\"helm_executable\\")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def helm_flags(self) -> typing.Optional[typing.List[builtins.str]]:
        result = self._values.get(\\"helm_flags\\")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        result = self._values.get(\\"namespace\\")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def release_name(self) -> typing.Optional[builtins.str]:
        result = self._values.get(\\"release_name\\")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"LaceworkAgentProps(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type=\\"lacework-agent.LaceworkAgentValues\\",
    jsii_struct_bases=[],
    name_mapping={
        \\"lacework_config\\": \\"laceworkConfig\\",
        \\"additional_values\\": \\"additionalValues\\",
        \\"cloudservice\\": \\"cloudservice\\",
        \\"cluster_agent\\": \\"clusterAgent\\",
        \\"daemonset\\": \\"daemonset\\",
        \\"datacollector\\": \\"datacollector\\",
        \\"deployment\\": \\"deployment\\",
        \\"global_\\": \\"global\\",
        \\"image\\": \\"image\\",
        \\"priority_class_create\\": \\"priorityClassCreate\\",
        \\"priority_class_name\\": \\"priorityClassName\\",
        \\"priority_class_preemption_policy\\": \\"priorityClassPreemptionPolicy\\",
        \\"priority_class_value\\": \\"priorityClassValue\\",
        \\"resources\\": \\"resources\\",
        \\"tolerations\\": \\"tolerations\\",
    },
)
class LaceworkAgentValues:
    def __init__(
        self,
        *,
        lacework_config: typing.Union[LaceworkAgentLaceworkConfig, typing.Dict[builtins.str, typing.Any]],
        additional_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        cloudservice: typing.Optional[typing.Union[LaceworkAgentCloudservice, typing.Dict[builtins.str, typing.Any]]] = None,
        cluster_agent: typing.Optional[typing.Union[LaceworkAgentClusterAgent, typing.Dict[builtins.str, typing.Any]]] = None,
        daemonset: typing.Optional[typing.Union[LaceworkAgentDaemonset, typing.Dict[builtins.str, typing.Any]]] = None,
        datacollector: typing.Optional[typing.Union[LaceworkAgentDatacollector, typing.Dict[builtins.str, typing.Any]]] = None,
        deployment: typing.Optional[typing.Union[LaceworkAgentDeployment, typing.Dict[builtins.str, typing.Any]]] = None,
        global_: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        image: typing.Optional[typing.Union[LaceworkAgentImage, typing.Dict[builtins.str, typing.Any]]] = None,
        priority_class_create: typing.Optional[builtins.bool] = None,
        priority_class_name: typing.Optional[builtins.str] = None,
        priority_class_preemption_policy: typing.Optional[builtins.str] = None,
        priority_class_value: typing.Optional[jsii.Number] = None,
        resources: typing.Optional[typing.Union[IoK8SApiCoreV1ResourceRequirements, typing.Dict[builtins.str, typing.Any]]] = None,
        tolerations: typing.Optional[typing.Sequence[typing.Union[IoK8SApiCoreV1Toleration, typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param lacework_config: 
        :param additional_values: Values that are not available in values.schema.json will not be code generated. You can add such values to this property.
        :param cloudservice: 
        :param cluster_agent: 
        :param daemonset: 
        :param datacollector: 
        :param deployment: 
        :param global_: 
        :param image: 
        :param priority_class_create: If specified, a priority class is created and used to deploy agent.
        :param priority_class_name: If specified, indicates the pod's priority. \\"system-node-critical\\" and \\"system-cluster-critical\\" are two special keywords which indicate the highest priorities with the former being the highest priority. Any other name must be defined by creating a PriorityClass object with that name. If not specified, the pod priority will be default or zero if there is no default.
        :param priority_class_preemption_policy: If specified, it determines if agent pod can preempt a pod with a lower a priority.
        :param priority_class_value: If specified, it represents the priority class value to use.
        :param resources: Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
        :param tolerations: If specified, the pod's tolerations.

        :schema: lacework-agent
        '''
        if isinstance(lacework_config, dict):
            lacework_config = LaceworkAgentLaceworkConfig(**lacework_config)
        if isinstance(cloudservice, dict):
            cloudservice = LaceworkAgentCloudservice(**cloudservice)
        if isinstance(cluster_agent, dict):
            cluster_agent = LaceworkAgentClusterAgent(**cluster_agent)
        if isinstance(daemonset, dict):
            daemonset = LaceworkAgentDaemonset(**daemonset)
        if isinstance(datacollector, dict):
            datacollector = LaceworkAgentDatacollector(**datacollector)
        if isinstance(deployment, dict):
            deployment = LaceworkAgentDeployment(**deployment)
        if isinstance(image, dict):
            image = LaceworkAgentImage(**image)
        if isinstance(resources, dict):
            resources = IoK8SApiCoreV1ResourceRequirements(**resources)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8e0e9f6d5d81f49593ed890c033cf700aa6b75418e1ea88ea8696f534add6024)
            check_type(argname=\\"argument lacework_config\\", value=lacework_config, expected_type=type_hints[\\"lacework_config\\"])
            check_type(argname=\\"argument additional_values\\", value=additional_values, expected_type=type_hints[\\"additional_values\\"])
            check_type(argname=\\"argument cloudservice\\", value=cloudservice, expected_type=type_hints[\\"cloudservice\\"])
            check_type(argname=\\"argument cluster_agent\\", value=cluster_agent, expected_type=type_hints[\\"cluster_agent\\"])
            check_type(argname=\\"argument daemonset\\", value=daemonset, expected_type=type_hints[\\"daemonset\\"])
            check_type(argname=\\"argument datacollector\\", value=datacollector, expected_type=type_hints[\\"datacollector\\"])
            check_type(argname=\\"argument deployment\\", value=deployment, expected_type=type_hints[\\"deployment\\"])
            check_type(argname=\\"argument global_\\", value=global_, expected_type=type_hints[\\"global_\\"])
            check_type(argname=\\"argument image\\", value=image, expected_type=type_hints[\\"image\\"])
            check_type(argname=\\"argument priority_class_create\\", value=priority_class_create, expected_type=type_hints[\\"priority_class_create\\"])
            check_type(argname=\\"argument priority_class_name\\", value=priority_class_name, expected_type=type_hints[\\"priority_class_name\\"])
            check_type(argname=\\"argument priority_class_preemption_policy\\", value=priority_class_preemption_policy, expected_type=type_hints[\\"priority_class_preemption_policy\\"])
            check_type(argname=\\"argument priority_class_value\\", value=priority_class_value, expected_type=type_hints[\\"priority_class_value\\"])
            check_type(argname=\\"argument resources\\", value=resources, expected_type=type_hints[\\"resources\\"])
            check_type(argname=\\"argument tolerations\\", value=tolerations, expected_type=type_hints[\\"tolerations\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            \\"lacework_config\\": lacework_config,
        }
        if additional_values is not None:
            self._values[\\"additional_values\\"] = additional_values
        if cloudservice is not None:
            self._values[\\"cloudservice\\"] = cloudservice
        if cluster_agent is not None:
            self._values[\\"cluster_agent\\"] = cluster_agent
        if daemonset is not None:
            self._values[\\"daemonset\\"] = daemonset
        if datacollector is not None:
            self._values[\\"datacollector\\"] = datacollector
        if deployment is not None:
            self._values[\\"deployment\\"] = deployment
        if global_ is not None:
            self._values[\\"global_\\"] = global_
        if image is not None:
            self._values[\\"image\\"] = image
        if priority_class_create is not None:
            self._values[\\"priority_class_create\\"] = priority_class_create
        if priority_class_name is not None:
            self._values[\\"priority_class_name\\"] = priority_class_name
        if priority_class_preemption_policy is not None:
            self._values[\\"priority_class_preemption_policy\\"] = priority_class_preemption_policy
        if priority_class_value is not None:
            self._values[\\"priority_class_value\\"] = priority_class_value
        if resources is not None:
            self._values[\\"resources\\"] = resources
        if tolerations is not None:
            self._values[\\"tolerations\\"] = tolerations

    @builtins.property
    def lacework_config(self) -> LaceworkAgentLaceworkConfig:
        '''
        :schema: lacework-agent#laceworkConfig
        '''
        result = self._values.get(\\"lacework_config\\")
        assert result is not None, \\"Required property 'lacework_config' is missing\\"
        return typing.cast(LaceworkAgentLaceworkConfig, result)

    @builtins.property
    def additional_values(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''Values that are not available in values.schema.json will not be code generated. You can add such values to this property.

        :schema: lacework-agent#additionalValues
        '''
        result = self._values.get(\\"additional_values\\")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def cloudservice(self) -> typing.Optional[LaceworkAgentCloudservice]:
        '''
        :schema: lacework-agent#cloudservice
        '''
        result = self._values.get(\\"cloudservice\\")
        return typing.cast(typing.Optional[LaceworkAgentCloudservice], result)

    @builtins.property
    def cluster_agent(self) -> typing.Optional[LaceworkAgentClusterAgent]:
        '''
        :schema: lacework-agent#clusterAgent
        '''
        result = self._values.get(\\"cluster_agent\\")
        return typing.cast(typing.Optional[LaceworkAgentClusterAgent], result)

    @builtins.property
    def daemonset(self) -> typing.Optional[LaceworkAgentDaemonset]:
        '''
        :schema: lacework-agent#daemonset
        '''
        result = self._values.get(\\"daemonset\\")
        return typing.cast(typing.Optional[LaceworkAgentDaemonset], result)

    @builtins.property
    def datacollector(self) -> typing.Optional[LaceworkAgentDatacollector]:
        '''
        :schema: lacework-agent#datacollector
        '''
        result = self._values.get(\\"datacollector\\")
        return typing.cast(typing.Optional[LaceworkAgentDatacollector], result)

    @builtins.property
    def deployment(self) -> typing.Optional[LaceworkAgentDeployment]:
        '''
        :schema: lacework-agent#deployment
        '''
        result = self._values.get(\\"deployment\\")
        return typing.cast(typing.Optional[LaceworkAgentDeployment], result)

    @builtins.property
    def global_(self) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''
        :schema: lacework-agent#global
        '''
        result = self._values.get(\\"global_\\")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def image(self) -> typing.Optional[LaceworkAgentImage]:
        '''
        :schema: lacework-agent#image
        '''
        result = self._values.get(\\"image\\")
        return typing.cast(typing.Optional[LaceworkAgentImage], result)

    @builtins.property
    def priority_class_create(self) -> typing.Optional[builtins.bool]:
        '''If specified, a priority class is created and used to deploy agent.

        :schema: lacework-agent#priorityClassCreate
        '''
        result = self._values.get(\\"priority_class_create\\")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def priority_class_name(self) -> typing.Optional[builtins.str]:
        '''If specified, indicates the pod's priority.

        \\"system-node-critical\\" and \\"system-cluster-critical\\" are two special keywords which indicate the highest priorities with the former being the highest priority. Any other name must be defined by creating a PriorityClass object with that name. If not specified, the pod priority will be default or zero if there is no default.

        :schema: lacework-agent#priorityClassName
        '''
        result = self._values.get(\\"priority_class_name\\")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def priority_class_preemption_policy(self) -> typing.Optional[builtins.str]:
        '''If specified, it determines if agent pod can preempt a pod with a lower a priority.

        :schema: lacework-agent#priorityClassPreemptionPolicy
        '''
        result = self._values.get(\\"priority_class_preemption_policy\\")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def priority_class_value(self) -> typing.Optional[jsii.Number]:
        '''If specified, it represents the priority class value to use.

        :schema: lacework-agent#priorityClassValue
        '''
        result = self._values.get(\\"priority_class_value\\")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def resources(self) -> typing.Optional[IoK8SApiCoreV1ResourceRequirements]:
        '''Compute Resources required by this container.

        Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/

        :schema: lacework-agent#resources
        '''
        result = self._values.get(\\"resources\\")
        return typing.cast(typing.Optional[IoK8SApiCoreV1ResourceRequirements], result)

    @builtins.property
    def tolerations(self) -> typing.Optional[typing.List[IoK8SApiCoreV1Toleration]]:
        '''If specified, the pod's tolerations.

        :schema: lacework-agent#tolerations
        '''
        result = self._values.get(\\"tolerations\\")
        return typing.cast(typing.Optional[typing.List[IoK8SApiCoreV1Toleration]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"LaceworkAgentValues(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


__all__ = [
    \\"IoK8SApiCoreV1Affinity\\",
    \\"IoK8SApiCoreV1AffinityNodeAffinity\\",
    \\"IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution\\",
    \\"IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference\\",
    \\"IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions\\",
    \\"IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOperator\\",
    \\"IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields\\",
    \\"IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOperator\\",
    \\"IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution\\",
    \\"IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms\\",
    \\"IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions\\",
    \\"IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOperator\\",
    \\"IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields\\",
    \\"IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOperator\\",
    \\"IoK8SApiCoreV1AffinityPodAffinity\\",
    \\"IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution\\",
    \\"IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm\\",
    \\"IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector\\",
    \\"IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions\\",
    \\"IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector\\",
    \\"IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions\\",
    \\"IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution\\",
    \\"IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector\\",
    \\"IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions\\",
    \\"IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector\\",
    \\"IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions\\",
    \\"IoK8SApiCoreV1AffinityPodAntiAffinity\\",
    \\"IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution\\",
    \\"IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm\\",
    \\"IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector\\",
    \\"IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions\\",
    \\"IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector\\",
    \\"IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions\\",
    \\"IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution\\",
    \\"IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector\\",
    \\"IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions\\",
    \\"IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector\\",
    \\"IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions\\",
    \\"IoK8SApiCoreV1DaemonSetUpdateStrategy\\",
    \\"IoK8SApiCoreV1DaemonSetUpdateStrategyRollingUpdate\\",
    \\"IoK8SApiCoreV1DaemonSetUpdateStrategyType\\",
    \\"IoK8SApiCoreV1LocalObjectReference\\",
    \\"IoK8SApiCoreV1ResourceRequirements\\",
    \\"IoK8SApiCoreV1Toleration\\",
    \\"IoK8SApiCoreV1TolerationEffect\\",
    \\"IoK8SApiCoreV1TolerationOperator\\",
    \\"LaceworkAgent\\",
    \\"LaceworkAgentCloudservice\\",
    \\"LaceworkAgentCloudserviceGke\\",
    \\"LaceworkAgentClusterAgent\\",
    \\"LaceworkAgentClusterAgentClusterType\\",
    \\"LaceworkAgentClusterAgentImage\\",
    \\"LaceworkAgentClusterAgentImagePullPolicy\\",
    \\"LaceworkAgentDaemonset\\",
    \\"LaceworkAgentDatacollector\\",
    \\"LaceworkAgentDeployment\\",
    \\"LaceworkAgentImage\\",
    \\"LaceworkAgentImagePullPolicy\\",
    \\"LaceworkAgentLaceworkConfig\\",
    \\"LaceworkAgentLaceworkConfigAnonymizeIncoming\\",
    \\"LaceworkAgentLaceworkConfigAutoUpgrade\\",
    \\"LaceworkAgentLaceworkConfigCmdlinefilter\\",
    \\"LaceworkAgentLaceworkConfigCodeaware\\",
    \\"LaceworkAgentLaceworkConfigContainerRuntime\\",
    \\"LaceworkAgentLaceworkConfigDatacollector\\",
    \\"LaceworkAgentLaceworkConfigFim\\",
    \\"LaceworkAgentLaceworkConfigPackagescan\\",
    \\"LaceworkAgentLaceworkConfigPerfmode\\",
    \\"LaceworkAgentLaceworkConfigProcscan\\",
    \\"LaceworkAgentProps\\",
    \\"LaceworkAgentValues\\",
]

publication.publish()

def _typecheckingstub__dcbd3c1d64c57915cdfe4d3e9c252dc593c38b7af2c271606308ad2dd0688fca(
    *,
    node_affinity: typing.Optional[typing.Union[IoK8SApiCoreV1AffinityNodeAffinity, typing.Dict[builtins.str, typing.Any]]] = None,
    pod_affinity: typing.Optional[typing.Union[IoK8SApiCoreV1AffinityPodAffinity, typing.Dict[builtins.str, typing.Any]]] = None,
    pod_anti_affinity: typing.Optional[typing.Union[IoK8SApiCoreV1AffinityPodAntiAffinity, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__83fb7082ba953b5b9e787cc0ee59a9bef2197db6a48b11240fdf117606315a5a(
    *,
    preferred_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union[IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution, typing.Dict[builtins.str, typing.Any]]]] = None,
    required_during_scheduling_ignored_during_execution: typing.Optional[typing.Union[IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__3bc3a7ad7604790369045dfb4698addef29a8a8a6153811d9f7dd8f99e3ee359(
    *,
    preference: typing.Optional[typing.Union[IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference, typing.Dict[builtins.str, typing.Any]]] = None,
    weight: typing.Optional[jsii.Number] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__41dee617dee988ead026c7bad2ebb4fae531007cc7f48f0db25cfa20dca41762(
    *,
    match_expressions: typing.Optional[typing.Sequence[typing.Union[IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions, typing.Dict[builtins.str, typing.Any]]]] = None,
    match_fields: typing.Optional[typing.Sequence[typing.Union[IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__3730cdd540fb8e7d48cf1be08570870a521033bbdb76cecc74c8fb287aebc010(
    *,
    key: typing.Optional[builtins.str] = None,
    operator: typing.Optional[IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOperator] = None,
    values: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__7b9dade3151f99e1afdce33c41e3c8dd8d3c83a16e10b28ddaf5ea28a3e22ada(
    *,
    key: typing.Optional[builtins.str] = None,
    operator: typing.Optional[IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOperator] = None,
    values: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__9acfa843b7229c0e9ad74630682849efa291d2c9468e4afb8a72503609d4a5d6(
    *,
    node_selector_terms: typing.Optional[typing.Sequence[typing.Union[IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__2985f1fb46d7d123a1304f37a4bdd1cb669f518ddebf14def78cd809166f7135(
    *,
    match_expressions: typing.Optional[typing.Sequence[typing.Union[IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions, typing.Dict[builtins.str, typing.Any]]]] = None,
    match_fields: typing.Optional[typing.Sequence[typing.Union[IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__2eef7443ccd6b5aaac15c30182a3aaae735d74ec9a15de2a348964115b0f1bad(
    *,
    key: typing.Optional[builtins.str] = None,
    operator: typing.Optional[IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOperator] = None,
    values: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__9ec67c499846b6a293071ecb3ec3a0f941758830e6820225b2170274524e6b3a(
    *,
    key: typing.Optional[builtins.str] = None,
    operator: typing.Optional[IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOperator] = None,
    values: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__ecd2363c495f3d762f767f20f3b220c8eb4d1138684a8c2cf0ffa57e67d7aeeb(
    *,
    preferred_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union[IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution, typing.Dict[builtins.str, typing.Any]]]] = None,
    required_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union[IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__73fb8396890742e720d837189aebf4ac5e0bc16c2f01edcaf5364c545a74c0a1(
    *,
    pod_affinity_term: typing.Optional[typing.Union[IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm, typing.Dict[builtins.str, typing.Any]]] = None,
    weight: typing.Optional[jsii.Number] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__b8dcc9ff575d6ba789f0a4bf1a9431102f18c195a13405596170979aca3a6cb2(
    *,
    topology_key: builtins.str,
    label_selector: typing.Optional[typing.Union[IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector, typing.Dict[builtins.str, typing.Any]]] = None,
    namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespace_selector: typing.Optional[typing.Union[IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__40cfaac301cd989c2a2863d9bcefa06dbd6fbab7916f86ca78ccf892347ffafb(
    *,
    match_expressions: typing.Optional[typing.Sequence[typing.Union[IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions, typing.Dict[builtins.str, typing.Any]]]] = None,
    match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__2b198777efafa2bcf798a86663d42e7d69dea513909618f4a7ba62c47966529f(
    *,
    key: typing.Optional[builtins.str] = None,
    operator: typing.Optional[builtins.str] = None,
    values: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__1d7a88051a5ab512c4e0d9b5fbed96bb1f36fd6ae3201420ace8e2be23a019b2(
    *,
    match_expressions: typing.Optional[typing.Sequence[typing.Union[IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions, typing.Dict[builtins.str, typing.Any]]]] = None,
    match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__bbd3a72a8cffc689f71da929f6797f32d6f852fa2e1e9d97277ed0eddeaad132(
    *,
    key: typing.Optional[builtins.str] = None,
    operator: typing.Optional[builtins.str] = None,
    values: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__2a6d00d95d2d04eea9613de1c7903d2e66e53fac220751130ed1b8dc64a5e972(
    *,
    label_selector: typing.Optional[typing.Union[IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector, typing.Dict[builtins.str, typing.Any]]] = None,
    namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespace_selector: typing.Optional[typing.Union[IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector, typing.Dict[builtins.str, typing.Any]]] = None,
    topology_key: typing.Optional[builtins.str] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__94286539963b88ed2abd60f58ddf76d754b62bbca1e65881e343f4dc1a75ecae(
    *,
    match_expressions: typing.Optional[typing.Sequence[typing.Union[IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions, typing.Dict[builtins.str, typing.Any]]]] = None,
    match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__de7b755055a8d366bf9836a2f930f13b4b5936266e2bf73587ed60ba8b4b2a8c(
    *,
    key: typing.Optional[builtins.str] = None,
    operator: typing.Optional[builtins.str] = None,
    values: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__216dabe6923643276c2131b29326ded426ee439ab42adc975360c3f53dea4682(
    *,
    match_expressions: typing.Optional[typing.Sequence[typing.Union[IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions, typing.Dict[builtins.str, typing.Any]]]] = None,
    match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__3ea0d99f7344162148befe0c73dc109ce6af186931d8630c3aab4a07df5a590a(
    *,
    key: typing.Optional[builtins.str] = None,
    operator: typing.Optional[builtins.str] = None,
    values: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__b88eace380f44c65d21d90d3a959666edb3c888eb5a8b0fe785c3aaa22d86421(
    *,
    preferred_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union[IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution, typing.Dict[builtins.str, typing.Any]]]] = None,
    required_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union[IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__3b5279544107027f249afe15ae53a3f9fc003336039ae784915c7894311253c0(
    *,
    pod_affinity_term: typing.Optional[typing.Union[IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm, typing.Dict[builtins.str, typing.Any]]] = None,
    weight: typing.Optional[jsii.Number] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__d6879ad10b0b3bf32416b947889ea0fafb9697033bd98f9280aa3d9dac126887(
    *,
    topology_key: builtins.str,
    label_selector: typing.Optional[typing.Union[IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector, typing.Dict[builtins.str, typing.Any]]] = None,
    namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespace_selector: typing.Optional[typing.Union[IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__779e9109822ded6fb329c314168503867d9f0a2da63eb380b58847710fc7c54c(
    *,
    match_expressions: typing.Optional[typing.Sequence[typing.Union[IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions, typing.Dict[builtins.str, typing.Any]]]] = None,
    match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__fbe1868dfaa4ea324e7b51741dc160ac660e7aead3d6ad63309f8527b880a9ee(
    *,
    key: typing.Optional[builtins.str] = None,
    operator: typing.Optional[builtins.str] = None,
    values: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__68e47b2143b4877a3368c835d90e670218ba9b3c952ba8824d9a815404577149(
    *,
    match_expressions: typing.Optional[typing.Sequence[typing.Union[IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions, typing.Dict[builtins.str, typing.Any]]]] = None,
    match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__22b27419d7799ad450b94ff5f87bc58d4744c4e0c666e3767b396de0204de11a(
    *,
    key: typing.Optional[builtins.str] = None,
    operator: typing.Optional[builtins.str] = None,
    values: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__63f8c333243eb40563cc7d45ef1b7e6e5b9d38ad721d1418adf58e94b7bf4acb(
    *,
    label_selector: typing.Optional[typing.Union[IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector, typing.Dict[builtins.str, typing.Any]]] = None,
    namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespace_selector: typing.Optional[typing.Union[IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector, typing.Dict[builtins.str, typing.Any]]] = None,
    topology_key: typing.Optional[builtins.str] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__0fc9c7df6b2de294ab5354d9cf7c44bbfcc94265b47418f00cafe7ecdf36144c(
    *,
    match_expressions: typing.Optional[typing.Sequence[typing.Union[IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions, typing.Dict[builtins.str, typing.Any]]]] = None,
    match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__ed3918916c6e7886791cf2a5252525faa2413def1916ebb4df746a8a27cbb1e7(
    *,
    key: typing.Optional[builtins.str] = None,
    operator: typing.Optional[builtins.str] = None,
    values: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__385d6e39815cb32272bda30489d64561dda13ec9946858d27fc65a0802694108(
    *,
    match_expressions: typing.Optional[typing.Sequence[typing.Union[IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions, typing.Dict[builtins.str, typing.Any]]]] = None,
    match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__9fdfe8df35f946a45e968b4b38d69b1382d866a3449f1eda5f75ff5a6ac17808(
    *,
    key: typing.Optional[builtins.str] = None,
    operator: typing.Optional[builtins.str] = None,
    values: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__691cf1c6250365dd9cb33a494eefd1c10935548095a168d5ef395a7441862256(
    *,
    rolling_update: typing.Optional[typing.Union[IoK8SApiCoreV1DaemonSetUpdateStrategyRollingUpdate, typing.Dict[builtins.str, typing.Any]]] = None,
    type: typing.Optional[IoK8SApiCoreV1DaemonSetUpdateStrategyType] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__bcbe1e4525c8ae8dac04633b9fd41a3cdc32975e54777d9b5669373b2f18141c(
    *,
    max_surge: typing.Any = None,
    max_unavailable: typing.Any = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__aad31b07aae14ea370a8ca13338d399e64c240651525bbc3a724ea48937a61e8(
    *,
    name: typing.Optional[builtins.str] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__b0cfae6cb4aad42921bb69bfe68fccfe027731b98cff20327e29d9b23d764e1a(
    *,
    limits: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    requests: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__8961b249a3bd11e4645f57459dc73620f46a774c6a01af2d7b27f6d837bf44ea(
    *,
    effect: typing.Optional[IoK8SApiCoreV1TolerationEffect] = None,
    key: typing.Optional[builtins.str] = None,
    operator: typing.Optional[IoK8SApiCoreV1TolerationOperator] = None,
    toleration_seconds: typing.Optional[jsii.Number] = None,
    value: typing.Optional[builtins.str] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__538ed41add4cf5a0b3aca9fc59ee30dae09743d95432eb21a3ce0b9acfbe4e21(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    values: typing.Union[LaceworkAgentValues, typing.Dict[builtins.str, typing.Any]],
    helm_executable: typing.Optional[builtins.str] = None,
    helm_flags: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespace: typing.Optional[builtins.str] = None,
    release_name: typing.Optional[builtins.str] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__a00c30cb766c4ce3670ed7fa040a7194f0cc005e50f492fee71a1d7221fdbc73(
    *,
    gke: typing.Optional[typing.Union[LaceworkAgentCloudserviceGke, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__a4d2ea86626ffffc816a5d7ea7ea672b7cbcee10de8e26d93325b202baa6294c(
    *,
    autopilot: typing.Optional[builtins.bool] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__427477360d777d212ced442a6c1a4283eae0d78b2a8c760ed72582ef9fe4964a(
    *,
    enable: builtins.bool,
    image: typing.Union[LaceworkAgentClusterAgentImage, typing.Dict[builtins.str, typing.Any]],
    additional_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    cluster_region: typing.Optional[builtins.str] = None,
    cluster_type: typing.Optional[LaceworkAgentClusterAgentClusterType] = None,
    scrape_initial_delay_mins: typing.Optional[jsii.Number] = None,
    scrape_interval_mins: typing.Optional[jsii.Number] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__1b0c01541508b3b32c7ca4979253b8778a14c281b271f717c8b3cfd5cc199c6e(
    *,
    pull_policy: LaceworkAgentClusterAgentImagePullPolicy,
    registry: builtins.str,
    repository: builtins.str,
    tag: builtins.str,
    additional_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    image_pull_secrets: typing.Optional[typing.Sequence[typing.Union[IoK8SApiCoreV1LocalObjectReference, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__8865f58784f4c0cc708c5b4fff21b85d0aa02c8830ebe0c003e678386afd20c6(
    *,
    affinity: typing.Union[IoK8SApiCoreV1Affinity, typing.Dict[builtins.str, typing.Any]],
    update_strategy: typing.Union[IoK8SApiCoreV1DaemonSetUpdateStrategy, typing.Dict[builtins.str, typing.Any]],
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__f6147c05aec3384656fc31bffde0dfd4f7b09aec7c5989879df33bfa5a918a27(
    *,
    additional_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    enable: typing.Optional[builtins.bool] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__787d1f6f42b54e0d6cad91b099f0e65026246f3e2b10b3a1f8add1f3ea9b4637(
    *,
    affinity: typing.Union[IoK8SApiCoreV1Affinity, typing.Dict[builtins.str, typing.Any]],
    update_strategy: typing.Union[IoK8SApiCoreV1DaemonSetUpdateStrategy, typing.Dict[builtins.str, typing.Any]],
    priority_class_create: typing.Optional[builtins.bool] = None,
    priority_class_name: typing.Optional[builtins.str] = None,
    priority_class_preemption_policy: typing.Optional[builtins.str] = None,
    priority_class_value: typing.Optional[jsii.Number] = None,
    resources: typing.Optional[typing.Union[IoK8SApiCoreV1ResourceRequirements, typing.Dict[builtins.str, typing.Any]]] = None,
    tolerations: typing.Optional[typing.Sequence[typing.Union[IoK8SApiCoreV1Toleration, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__4c0a83a494e348ea80a80280a82eb843acacd28d70ef2adf7d118c45b12ca124(
    *,
    pull_policy: LaceworkAgentImagePullPolicy,
    registry: builtins.str,
    repository: builtins.str,
    tag: builtins.str,
    additional_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    image_pull_secrets: typing.Optional[typing.Sequence[typing.Union[IoK8SApiCoreV1LocalObjectReference, typing.Dict[builtins.str, typing.Any]]]] = None,
    override_value: typing.Optional[builtins.str] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__137ccaec2780b925802b147c3602013773aba0adcc89e414986c5d5a31ac1a52(
    *,
    access_token: typing.Any,
    additional_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    annotations: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    anonymize_incoming: typing.Optional[typing.Union[LaceworkAgentLaceworkConfigAnonymizeIncoming, typing.Dict[builtins.str, typing.Any]]] = None,
    auto_upgrade: typing.Optional[LaceworkAgentLaceworkConfigAutoUpgrade] = None,
    cmdlinefilter: typing.Optional[typing.Union[LaceworkAgentLaceworkConfigCmdlinefilter, typing.Dict[builtins.str, typing.Any]]] = None,
    codeaware: typing.Optional[typing.Union[LaceworkAgentLaceworkConfigCodeaware, typing.Dict[builtins.str, typing.Any]]] = None,
    container_engine_endpoint: typing.Optional[builtins.str] = None,
    container_runtime: typing.Optional[LaceworkAgentLaceworkConfigContainerRuntime] = None,
    datacollector: typing.Optional[LaceworkAgentLaceworkConfigDatacollector] = None,
    env: typing.Optional[builtins.str] = None,
    fim: typing.Optional[typing.Union[LaceworkAgentLaceworkConfigFim, typing.Dict[builtins.str, typing.Any]]] = None,
    k8_s_node_scrape_interval_mins: typing.Optional[jsii.Number] = None,
    kubernetes_cluster: typing.Optional[builtins.str] = None,
    labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    metadata_request_interval: typing.Optional[builtins.str] = None,
    packagescan: typing.Optional[typing.Union[LaceworkAgentLaceworkConfigPackagescan, typing.Dict[builtins.str, typing.Any]]] = None,
    perfmode: typing.Optional[LaceworkAgentLaceworkConfigPerfmode] = None,
    procscan: typing.Optional[typing.Union[LaceworkAgentLaceworkConfigProcscan, typing.Dict[builtins.str, typing.Any]]] = None,
    proxy_url: typing.Optional[builtins.str] = None,
    server_url: typing.Optional[builtins.str] = None,
    service_account_name: typing.Optional[builtins.str] = None,
    stdout_logging: typing.Optional[builtins.bool] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__cae19ba49ffeb3756e422ae55a616d552a7b1a48e805ed6342cdcedeb898252d(
    *,
    additional_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    netmask: typing.Optional[builtins.str] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__d49626aa144236418ebd376e1f10ea94398ba5fc8167c20717e1b2e7d5629eb9(
    *,
    allow: typing.Optional[builtins.str] = None,
    disallow: typing.Optional[builtins.str] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__5882a8edec8095b7334e91a883a0e95f3d4d4a8f83a44c6e4483316a2267bf63(
    *,
    enable: typing.Optional[builtins.bool] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__3a82613c3b10f84fd3c85552b1bf3d3eb0de5e479e129b12fa8986455f413ed2(
    *,
    enable: builtins.bool,
    file_ignore: typing.Sequence[builtins.str],
    file_path: typing.Sequence[builtins.str],
    additional_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    cooling_period: typing.Optional[jsii.Number] = None,
    crawl_interval: typing.Optional[jsii.Number] = None,
    no_atime: typing.Optional[builtins.bool] = None,
    run_at: typing.Any = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__7a28ae402580638d4ca326df3f41bd0b2997d028ee2ad046ae4834bceb9580ee(
    *,
    enable: typing.Optional[builtins.bool] = None,
    interval: typing.Optional[jsii.Number] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__574fdc26e474c6dcbd22d3b5de880518aa899c6e4ac43317fce728e591c17e31(
    *,
    enable: typing.Optional[builtins.bool] = None,
    interval: typing.Optional[jsii.Number] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__ea49c8097c79e425efc522f130af588a0f59b5954b4b8e97db8870d745183bad(
    *,
    values: typing.Union[LaceworkAgentValues, typing.Dict[builtins.str, typing.Any]],
    helm_executable: typing.Optional[builtins.str] = None,
    helm_flags: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespace: typing.Optional[builtins.str] = None,
    release_name: typing.Optional[builtins.str] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__8e0e9f6d5d81f49593ed890c033cf700aa6b75418e1ea88ea8696f534add6024(
    *,
    lacework_config: typing.Union[LaceworkAgentLaceworkConfig, typing.Dict[builtins.str, typing.Any]],
    additional_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    cloudservice: typing.Optional[typing.Union[LaceworkAgentCloudservice, typing.Dict[builtins.str, typing.Any]]] = None,
    cluster_agent: typing.Optional[typing.Union[LaceworkAgentClusterAgent, typing.Dict[builtins.str, typing.Any]]] = None,
    daemonset: typing.Optional[typing.Union[LaceworkAgentDaemonset, typing.Dict[builtins.str, typing.Any]]] = None,
    datacollector: typing.Optional[typing.Union[LaceworkAgentDatacollector, typing.Dict[builtins.str, typing.Any]]] = None,
    deployment: typing.Optional[typing.Union[LaceworkAgentDeployment, typing.Dict[builtins.str, typing.Any]]] = None,
    global_: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    image: typing.Optional[typing.Union[LaceworkAgentImage, typing.Dict[builtins.str, typing.Any]]] = None,
    priority_class_create: typing.Optional[builtins.bool] = None,
    priority_class_name: typing.Optional[builtins.str] = None,
    priority_class_preemption_policy: typing.Optional[builtins.str] = None,
    priority_class_value: typing.Optional[jsii.Number] = None,
    resources: typing.Optional[typing.Union[IoK8SApiCoreV1ResourceRequirements, typing.Dict[builtins.str, typing.Any]]] = None,
    tolerations: typing.Optional[typing.Sequence[typing.Union[IoK8SApiCoreV1Toleration, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass
",
  "lacework_agent/_jsii/__init__.py": "from pkgutil import extend_path
__path__ = extend_path(__path__, __name__)

import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

import typeguard
from importlib.metadata import version as _metadata_package_version
TYPEGUARD_MAJOR_VERSION = int(_metadata_package_version('typeguard').split('.')[0])

def check_type(argname: str, value: object, expected_type: typing.Any) -> typing.Any:
    if TYPEGUARD_MAJOR_VERSION <= 2:
        return typeguard.check_type(argname=argname, value=value, expected_type=expected_type) # type:ignore
    else:
        if isinstance(value, jsii._reference_map.InterfaceDynamicProxy): # pyright: ignore [reportAttributeAccessIssue]
           pass
        else:
            if TYPEGUARD_MAJOR_VERSION == 3:
                typeguard.config.collection_check_strategy = typeguard.CollectionCheckStrategy.ALL_ITEMS # type:ignore
                typeguard.check_type(value=value, expected_type=expected_type) # type:ignore
            else:
                typeguard.check_type(value=value, expected_type=expected_type, collection_check_strategy=typeguard.CollectionCheckStrategy.ALL_ITEMS) # type:ignore

import cdk8s._jsii
import constructs._jsii

__jsii_assembly__ = jsii.JSIIAssembly.load(
    \\"lacework-agent\\", \\"0.0.0\\", __name__[0:-6], \\"lacework-agent@0.0.0.jsii.tgz\\"
)

__all__ = [
    \\"__jsii_assembly__\\",
]

publication.publish()
",
  "lacework_agent/py.typed": "
",
}
`;

exports[`importing helm chart helm:https://lacework.github.io/helm-charts/lacework-agent@6.9.0 with typescript lanugage 1`] = `
Object {
  "author": Object {
    "name": "generated@generated.com",
    "roles": Array [
      "author",
    ],
  },
  "dependencies": "__omitted__",
  "dependencyClosure": Object {
    "cdk8s": Object {
      "targets": Object {
        "dotnet": Object {
          "namespace": "Org.Cdk8s",
          "packageId": "Org.Cdk8s",
        },
        "go": Object {
          "moduleName": "github.com/cdk8s-team/cdk8s-core-go",
        },
        "java": Object {
          "maven": Object {
            "artifactId": "cdk8s",
            "groupId": "org.cdk8s",
          },
          "package": "org.cdk8s",
        },
        "js": Object {
          "npm": "cdk8s",
        },
        "python": Object {
          "distName": "cdk8s",
          "module": "cdk8s",
        },
      },
    },
    "constructs": Object {
      "targets": Object {
        "dotnet": Object {
          "namespace": "Constructs",
          "packageId": "Constructs",
        },
        "go": Object {
          "moduleName": "github.com/aws/constructs-go",
        },
        "java": Object {
          "maven": Object {
            "artifactId": "constructs",
            "groupId": "software.constructs",
          },
          "package": "software.constructs",
        },
        "js": Object {
          "npm": "constructs",
        },
        "python": Object {
          "distName": "constructs",
          "module": "constructs",
        },
      },
    },
  },
  "description": "lacework-agent",
  "fingerprint": "<fingerprint>",
  "homepage": "http://generated",
  "jsiiVersion": "__omitted__",
  "license": "UNLICENSED",
  "metadata": Object {
    "jsii": Object {
      "pacmak": Object {
        "hasDefaultInterfaces": true,
      },
    },
  },
  "name": "lacework-agent",
  "repository": Object {
    "type": "git",
    "url": "http://generated",
  },
  "schema": "jsii/0.10.0",
  "targets": Object {
    "js": Object {
      "npm": "lacework-agent",
    },
  },
  "types": Object {
    "lacework-agent.IoK8SApiCoreV1Affinity": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "io.k8s.api.core.v1.Affinity",
        },
        "summary": "Affinity is a group of affinity scheduling rules.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1Affinity",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 591,
      },
      "name": "IoK8SApiCoreV1Affinity",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "io.k8s.api.core.v1.Affinity#nodeAffinity",
            },
            "summary": "Node affinity is a group of node affinity scheduling rules.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 597,
          },
          "name": "nodeAffinity",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.IoK8SApiCoreV1AffinityNodeAffinity",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "io.k8s.api.core.v1.Affinity#podAffinity",
            },
            "summary": "Pod affinity is a group of inter pod affinity scheduling rules.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 604,
          },
          "name": "podAffinity",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAffinity",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "io.k8s.api.core.v1.Affinity#podAntiAffinity",
            },
            "summary": "Pod anti affinity is a group of inter pod anti affinity scheduling rules.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 611,
          },
          "name": "podAntiAffinity",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinity",
          },
        },
      ],
      "symbolId": "lacework-agent:IoK8SApiCoreV1Affinity",
    },
    "lacework-agent.IoK8SApiCoreV1AffinityNodeAffinity": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1AffinityNodeAffinity",
        },
        "summary": "Node affinity is a group of node affinity scheduling rules.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1AffinityNodeAffinity",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 960,
      },
      "name": "IoK8SApiCoreV1AffinityNodeAffinity",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution",
            },
            "remarks": "The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding \\"weight\\" to the sum if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the most preferred.",
            "summary": "The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 966,
          },
          "name": "preferredDuringSchedulingIgnoredDuringExecution",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "fqn": "lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution",
              },
              "kind": "array",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution",
            },
            "remarks": "that is, it represents the OR of the selectors represented by the node selector terms.",
            "summary": "A node selector represents the union of the results of one or more label queries over a set of nodes;",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 973,
          },
          "name": "requiredDuringSchedulingIgnoredDuringExecution",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution",
          },
        },
      ],
      "symbolId": "lacework-agent:IoK8SApiCoreV1AffinityNodeAffinity",
    },
    "lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution",
        },
        "summary": "An empty preferred scheduling term matches all objects with implicit weight 0 (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 1081,
      },
      "name": "IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference",
            },
            "remarks": "The requirements of them are ANDed. The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.",
            "summary": "A null or empty node selector term matches no objects.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1087,
          },
          "name": "preference",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight",
            },
            "summary": "Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1094,
          },
          "name": "weight",
          "optional": true,
          "type": Object {
            "primitive": "number",
          },
        },
      ],
      "symbolId": "lacework-agent:IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    },
    "lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference",
        },
        "remarks": "The requirements of them are ANDed. The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.",
        "summary": "A null or empty node selector term matches no objects.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 1234,
      },
      "name": "IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions",
            },
            "summary": "A list of node selector requirements by node's labels.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1240,
          },
          "name": "matchExpressions",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "fqn": "lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions",
              },
              "kind": "array",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields",
            },
            "summary": "A list of node selector requirements by node's fields.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1247,
          },
          "name": "matchFields",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "fqn": "lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields",
              },
              "kind": "array",
            },
          },
        },
      ],
      "symbolId": "lacework-agent:IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference",
    },
    "lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions",
        },
        "summary": "A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 1438,
      },
      "name": "IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key",
            },
            "summary": "The label key that the selector applies to.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1444,
          },
          "name": "key",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator",
            },
            "remarks": "Possible enum values:
- \`\\"DoesNotExist\\"\`
- \`\\"Exists\\"\`
- \`\\"Gt\\"\`
- \`\\"In\\"\`
- \`\\"Lt\\"\`
- \`\\"NotIn\\"\`",
            "summary": "Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1459,
          },
          "name": "operator",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOperator",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values",
            },
            "remarks": "If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.",
            "summary": "An array of string values.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1466,
          },
          "name": "values",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "string",
              },
              "kind": "array",
            },
          },
        },
      ],
      "symbolId": "lacework-agent:IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions",
    },
    "lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOperator": Object {
      "assembly": "lacework-agent",
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOperator",
        },
        "remarks": "Possible enum values:
- \`\\"DoesNotExist\\"\`
- \`\\"Exists\\"\`
- \`\\"Gt\\"\`
- \`\\"In\\"\`
- \`\\"Lt\\"\`
- \`\\"NotIn\\"\`",
        "summary": "Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOperator",
      "kind": "enum",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 1798,
      },
      "members": Array [
        Object {
          "docs": Object {
            "summary": "DoesNotExist.",
          },
          "name": "DOES_NOT_EXIST",
        },
        Object {
          "docs": Object {
            "summary": "Exists.",
          },
          "name": "EXISTS",
        },
        Object {
          "docs": Object {
            "summary": "Gt.",
          },
          "name": "GT",
        },
        Object {
          "docs": Object {
            "summary": "In.",
          },
          "name": "IN",
        },
        Object {
          "docs": Object {
            "summary": "Lt.",
          },
          "name": "LT",
        },
        Object {
          "docs": Object {
            "summary": "NotIn.",
          },
          "name": "NOT_IN",
        },
      ],
      "name": "IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOperator",
      "symbolId": "lacework-agent:IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOperator",
    },
    "lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields",
        },
        "summary": "A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 1475,
      },
      "name": "IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key",
            },
            "summary": "The label key that the selector applies to.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1481,
          },
          "name": "key",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator",
            },
            "remarks": "Possible enum values:
- \`\\"DoesNotExist\\"\`
- \`\\"Exists\\"\`
- \`\\"Gt\\"\`
- \`\\"In\\"\`
- \`\\"Lt\\"\`
- \`\\"NotIn\\"\`",
            "summary": "Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1496,
          },
          "name": "operator",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOperator",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values",
            },
            "remarks": "If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.",
            "summary": "An array of string values.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1503,
          },
          "name": "values",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "string",
              },
              "kind": "array",
            },
          },
        },
      ],
      "symbolId": "lacework-agent:IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields",
    },
    "lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOperator": Object {
      "assembly": "lacework-agent",
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOperator",
        },
        "remarks": "Possible enum values:
- \`\\"DoesNotExist\\"\`
- \`\\"Exists\\"\`
- \`\\"Gt\\"\`
- \`\\"In\\"\`
- \`\\"Lt\\"\`
- \`\\"NotIn\\"\`",
        "summary": "Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOperator",
      "kind": "enum",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 1826,
      },
      "members": Array [
        Object {
          "docs": Object {
            "summary": "DoesNotExist.",
          },
          "name": "DOES_NOT_EXIST",
        },
        Object {
          "docs": Object {
            "summary": "Exists.",
          },
          "name": "EXISTS",
        },
        Object {
          "docs": Object {
            "summary": "Gt.",
          },
          "name": "GT",
        },
        Object {
          "docs": Object {
            "summary": "In.",
          },
          "name": "IN",
        },
        Object {
          "docs": Object {
            "summary": "Lt.",
          },
          "name": "LT",
        },
        Object {
          "docs": Object {
            "summary": "NotIn.",
          },
          "name": "NOT_IN",
        },
      ],
      "name": "IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOperator",
      "symbolId": "lacework-agent:IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOperator",
    },
    "lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution",
        },
        "remarks": "that is, it represents the OR of the selectors represented by the node selector terms.",
        "summary": "A node selector represents the union of the results of one or more label queries over a set of nodes;",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 1103,
      },
      "name": "IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms",
            },
            "remarks": "A list of node selector terms. The terms are ORed.",
            "summary": "Required.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1109,
          },
          "name": "nodeSelectorTerms",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "fqn": "lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms",
              },
              "kind": "array",
            },
          },
        },
      ],
      "symbolId": "lacework-agent:IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    },
    "lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms",
        },
        "remarks": "The requirements of them are ANDed. The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.",
        "summary": "A null or empty node selector term matches no objects.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 1256,
      },
      "name": "IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions",
            },
            "summary": "A list of node selector requirements by node's labels.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1262,
          },
          "name": "matchExpressions",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "fqn": "lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions",
              },
              "kind": "array",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields",
            },
            "summary": "A list of node selector requirements by node's fields.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1269,
          },
          "name": "matchFields",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "fqn": "lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields",
              },
              "kind": "array",
            },
          },
        },
      ],
      "symbolId": "lacework-agent:IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms",
    },
    "lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions",
        },
        "summary": "A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 1512,
      },
      "name": "IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key",
            },
            "summary": "The label key that the selector applies to.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1518,
          },
          "name": "key",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator",
            },
            "remarks": "Possible enum values:
- \`\\"DoesNotExist\\"\`
- \`\\"Exists\\"\`
- \`\\"Gt\\"\`
- \`\\"In\\"\`
- \`\\"Lt\\"\`
- \`\\"NotIn\\"\`",
            "summary": "Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1533,
          },
          "name": "operator",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOperator",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values",
            },
            "remarks": "If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.",
            "summary": "An array of string values.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1540,
          },
          "name": "values",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "string",
              },
              "kind": "array",
            },
          },
        },
      ],
      "symbolId": "lacework-agent:IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions",
    },
    "lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOperator": Object {
      "assembly": "lacework-agent",
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOperator",
        },
        "remarks": "Possible enum values:
- \`\\"DoesNotExist\\"\`
- \`\\"Exists\\"\`
- \`\\"Gt\\"\`
- \`\\"In\\"\`
- \`\\"Lt\\"\`
- \`\\"NotIn\\"\`",
        "summary": "Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOperator",
      "kind": "enum",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 1854,
      },
      "members": Array [
        Object {
          "docs": Object {
            "summary": "DoesNotExist.",
          },
          "name": "DOES_NOT_EXIST",
        },
        Object {
          "docs": Object {
            "summary": "Exists.",
          },
          "name": "EXISTS",
        },
        Object {
          "docs": Object {
            "summary": "Gt.",
          },
          "name": "GT",
        },
        Object {
          "docs": Object {
            "summary": "In.",
          },
          "name": "IN",
        },
        Object {
          "docs": Object {
            "summary": "Lt.",
          },
          "name": "LT",
        },
        Object {
          "docs": Object {
            "summary": "NotIn.",
          },
          "name": "NOT_IN",
        },
      ],
      "name": "IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOperator",
      "symbolId": "lacework-agent:IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOperator",
    },
    "lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields",
        },
        "summary": "A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 1549,
      },
      "name": "IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key",
            },
            "summary": "The label key that the selector applies to.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1555,
          },
          "name": "key",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator",
            },
            "remarks": "Possible enum values:
- \`\\"DoesNotExist\\"\`
- \`\\"Exists\\"\`
- \`\\"Gt\\"\`
- \`\\"In\\"\`
- \`\\"Lt\\"\`
- \`\\"NotIn\\"\`",
            "summary": "Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1570,
          },
          "name": "operator",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOperator",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values",
            },
            "remarks": "If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.",
            "summary": "An array of string values.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1577,
          },
          "name": "values",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "string",
              },
              "kind": "array",
            },
          },
        },
      ],
      "symbolId": "lacework-agent:IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields",
    },
    "lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOperator": Object {
      "assembly": "lacework-agent",
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOperator",
        },
        "remarks": "Possible enum values:
- \`\\"DoesNotExist\\"\`
- \`\\"Exists\\"\`
- \`\\"Gt\\"\`
- \`\\"In\\"\`
- \`\\"Lt\\"\`
- \`\\"NotIn\\"\`",
        "summary": "Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOperator",
      "kind": "enum",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 1882,
      },
      "members": Array [
        Object {
          "docs": Object {
            "summary": "DoesNotExist.",
          },
          "name": "DOES_NOT_EXIST",
        },
        Object {
          "docs": Object {
            "summary": "Exists.",
          },
          "name": "EXISTS",
        },
        Object {
          "docs": Object {
            "summary": "Gt.",
          },
          "name": "GT",
        },
        Object {
          "docs": Object {
            "summary": "In.",
          },
          "name": "IN",
        },
        Object {
          "docs": Object {
            "summary": "Lt.",
          },
          "name": "LT",
        },
        Object {
          "docs": Object {
            "summary": "NotIn.",
          },
          "name": "NOT_IN",
        },
      ],
      "name": "IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOperator",
      "symbolId": "lacework-agent:IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOperator",
    },
    "lacework-agent.IoK8SApiCoreV1AffinityPodAffinity": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1AffinityPodAffinity",
        },
        "summary": "Pod affinity is a group of inter pod affinity scheduling rules.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAffinity",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 982,
      },
      "name": "IoK8SApiCoreV1AffinityPodAffinity",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution",
            },
            "remarks": "The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding \\"weight\\" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.",
            "summary": "The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 988,
          },
          "name": "preferredDuringSchedulingIgnoredDuringExecution",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution",
              },
              "kind": "array",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution",
            },
            "remarks": "If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.",
            "summary": "If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 995,
          },
          "name": "requiredDuringSchedulingIgnoredDuringExecution",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution",
              },
              "kind": "array",
            },
          },
        },
      ],
      "symbolId": "lacework-agent:IoK8SApiCoreV1AffinityPodAffinity",
    },
    "lacework-agent.IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution",
        },
        "summary": "The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s).",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 1118,
      },
      "name": "IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm",
            },
            "summary": "Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1124,
          },
          "name": "podAffinityTerm",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight",
            },
            "summary": "weight associated with matching the corresponding podAffinityTerm, in the range 1-100.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1131,
          },
          "name": "weight",
          "optional": true,
          "type": Object {
            "primitive": "number",
          },
        },
      ],
      "symbolId": "lacework-agent:IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    },
    "lacework-agent.IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
        },
        "summary": "Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 1278,
      },
      "name": "IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey",
            },
            "remarks": "Empty topologyKey is not allowed.",
            "summary": "This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1305,
          },
          "name": "topologyKey",
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector",
            },
            "remarks": "The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.",
            "summary": "A label selector is a label query over a set of resources.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1284,
          },
          "name": "labelSelector",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces",
            },
            "remarks": "The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means \\"this pod's namespace\\".",
            "summary": "namespaces specifies a static list of namespace names that the term applies to.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1298,
          },
          "name": "namespaces",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "string",
              },
              "kind": "array",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector",
            },
            "remarks": "The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.",
            "summary": "A label selector is a label query over a set of resources.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1291,
          },
          "name": "namespaceSelector",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector",
          },
        },
      ],
      "symbolId": "lacework-agent:IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
    },
    "lacework-agent.IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
        },
        "remarks": "The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.",
        "summary": "A label selector is a label query over a set of resources.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 1586,
      },
      "name": "IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions",
            },
            "remarks": "The requirements are ANDed.",
            "summary": "matchExpressions is a list of label selector requirements.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1592,
          },
          "name": "matchExpressions",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
              },
              "kind": "array",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels",
            },
            "remarks": "A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \\"key\\", the operator is \\"In\\", and the values array contains only \\"value\\". The requirements are ANDed.",
            "summary": "matchLabels is a map of {key,value} pairs.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1599,
          },
          "name": "matchLabels",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "string",
              },
              "kind": "map",
            },
          },
        },
      ],
      "symbolId": "lacework-agent:IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
    },
    "lacework-agent.IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
        },
        "summary": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 1902,
      },
      "name": "IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key",
            },
            "summary": "key is the label key that the selector applies to.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1908,
          },
          "name": "key",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator",
            },
            "remarks": "Valid operators are In, NotIn, Exists and DoesNotExist.",
            "summary": "operator represents a key's relationship to a set of values.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1915,
          },
          "name": "operator",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values",
            },
            "remarks": "If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
            "summary": "values is an array of string values.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1922,
          },
          "name": "values",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "string",
              },
              "kind": "array",
            },
          },
        },
      ],
      "symbolId": "lacework-agent:IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
    },
    "lacework-agent.IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector",
        },
        "remarks": "The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.",
        "summary": "A label selector is a label query over a set of resources.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 1608,
      },
      "name": "IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions",
            },
            "remarks": "The requirements are ANDed.",
            "summary": "matchExpressions is a list of label selector requirements.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1614,
          },
          "name": "matchExpressions",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions",
              },
              "kind": "array",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels",
            },
            "remarks": "A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \\"key\\", the operator is \\"In\\", and the values array contains only \\"value\\". The requirements are ANDed.",
            "summary": "matchLabels is a map of {key,value} pairs.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1621,
          },
          "name": "matchLabels",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "string",
              },
              "kind": "map",
            },
          },
        },
      ],
      "symbolId": "lacework-agent:IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector",
    },
    "lacework-agent.IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions",
        },
        "summary": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 1931,
      },
      "name": "IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key",
            },
            "summary": "key is the label key that the selector applies to.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1937,
          },
          "name": "key",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator",
            },
            "remarks": "Valid operators are In, NotIn, Exists and DoesNotExist.",
            "summary": "operator represents a key's relationship to a set of values.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1944,
          },
          "name": "operator",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values",
            },
            "remarks": "If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
            "summary": "values is an array of string values.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1951,
          },
          "name": "values",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "string",
              },
              "kind": "array",
            },
          },
        },
      ],
      "symbolId": "lacework-agent:IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions",
    },
    "lacework-agent.IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution",
        },
        "summary": "Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 1140,
      },
      "name": "IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector",
            },
            "remarks": "The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.",
            "summary": "A label selector is a label query over a set of resources.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1146,
          },
          "name": "labelSelector",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces",
            },
            "remarks": "The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means \\"this pod's namespace\\".",
            "summary": "namespaces specifies a static list of namespace names that the term applies to.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1160,
          },
          "name": "namespaces",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "string",
              },
              "kind": "array",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector",
            },
            "remarks": "The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.",
            "summary": "A label selector is a label query over a set of resources.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1153,
          },
          "name": "namespaceSelector",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey",
            },
            "remarks": "Empty topologyKey is not allowed.",
            "summary": "This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1167,
          },
          "name": "topologyKey",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
      ],
      "symbolId": "lacework-agent:IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    },
    "lacework-agent.IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
        },
        "remarks": "The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.",
        "summary": "A label selector is a label query over a set of resources.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 1314,
      },
      "name": "IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions",
            },
            "remarks": "The requirements are ANDed.",
            "summary": "matchExpressions is a list of label selector requirements.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1320,
          },
          "name": "matchExpressions",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
              },
              "kind": "array",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels",
            },
            "remarks": "A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \\"key\\", the operator is \\"In\\", and the values array contains only \\"value\\". The requirements are ANDed.",
            "summary": "matchLabels is a map of {key,value} pairs.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1327,
          },
          "name": "matchLabels",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "string",
              },
              "kind": "map",
            },
          },
        },
      ],
      "symbolId": "lacework-agent:IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
    },
    "lacework-agent.IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
        },
        "summary": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 1630,
      },
      "name": "IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key",
            },
            "summary": "key is the label key that the selector applies to.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1636,
          },
          "name": "key",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator",
            },
            "remarks": "Valid operators are In, NotIn, Exists and DoesNotExist.",
            "summary": "operator represents a key's relationship to a set of values.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1643,
          },
          "name": "operator",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values",
            },
            "remarks": "If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
            "summary": "values is an array of string values.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1650,
          },
          "name": "values",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "string",
              },
              "kind": "array",
            },
          },
        },
      ],
      "symbolId": "lacework-agent:IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
    },
    "lacework-agent.IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector",
        },
        "remarks": "The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.",
        "summary": "A label selector is a label query over a set of resources.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 1336,
      },
      "name": "IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions",
            },
            "remarks": "The requirements are ANDed.",
            "summary": "matchExpressions is a list of label selector requirements.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1342,
          },
          "name": "matchExpressions",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions",
              },
              "kind": "array",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels",
            },
            "remarks": "A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \\"key\\", the operator is \\"In\\", and the values array contains only \\"value\\". The requirements are ANDed.",
            "summary": "matchLabels is a map of {key,value} pairs.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1349,
          },
          "name": "matchLabels",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "string",
              },
              "kind": "map",
            },
          },
        },
      ],
      "symbolId": "lacework-agent:IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector",
    },
    "lacework-agent.IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions",
        },
        "summary": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 1659,
      },
      "name": "IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key",
            },
            "summary": "key is the label key that the selector applies to.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1665,
          },
          "name": "key",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator",
            },
            "remarks": "Valid operators are In, NotIn, Exists and DoesNotExist.",
            "summary": "operator represents a key's relationship to a set of values.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1672,
          },
          "name": "operator",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values",
            },
            "remarks": "If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
            "summary": "values is an array of string values.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1679,
          },
          "name": "values",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "string",
              },
              "kind": "array",
            },
          },
        },
      ],
      "symbolId": "lacework-agent:IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions",
    },
    "lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinity": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1AffinityPodAntiAffinity",
        },
        "summary": "Pod anti affinity is a group of inter pod anti affinity scheduling rules.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinity",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 1004,
      },
      "name": "IoK8SApiCoreV1AffinityPodAntiAffinity",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution",
            },
            "remarks": "The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding \\"weight\\" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.",
            "summary": "The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1010,
          },
          "name": "preferredDuringSchedulingIgnoredDuringExecution",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution",
              },
              "kind": "array",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution",
            },
            "remarks": "If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.",
            "summary": "If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1017,
          },
          "name": "requiredDuringSchedulingIgnoredDuringExecution",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution",
              },
              "kind": "array",
            },
          },
        },
      ],
      "symbolId": "lacework-agent:IoK8SApiCoreV1AffinityPodAntiAffinity",
    },
    "lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution",
        },
        "summary": "The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s).",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 1176,
      },
      "name": "IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm",
            },
            "summary": "Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1182,
          },
          "name": "podAffinityTerm",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight",
            },
            "summary": "weight associated with matching the corresponding podAffinityTerm, in the range 1-100.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1189,
          },
          "name": "weight",
          "optional": true,
          "type": Object {
            "primitive": "number",
          },
        },
      ],
      "symbolId": "lacework-agent:IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    },
    "lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
        },
        "summary": "Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 1358,
      },
      "name": "IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey",
            },
            "remarks": "Empty topologyKey is not allowed.",
            "summary": "This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1385,
          },
          "name": "topologyKey",
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector",
            },
            "remarks": "The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.",
            "summary": "A label selector is a label query over a set of resources.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1364,
          },
          "name": "labelSelector",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces",
            },
            "remarks": "The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means \\"this pod's namespace\\".",
            "summary": "namespaces specifies a static list of namespace names that the term applies to.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1378,
          },
          "name": "namespaces",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "string",
              },
              "kind": "array",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector",
            },
            "remarks": "The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.",
            "summary": "A label selector is a label query over a set of resources.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1371,
          },
          "name": "namespaceSelector",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector",
          },
        },
      ],
      "symbolId": "lacework-agent:IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
    },
    "lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
        },
        "remarks": "The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.",
        "summary": "A label selector is a label query over a set of resources.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 1688,
      },
      "name": "IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions",
            },
            "remarks": "The requirements are ANDed.",
            "summary": "matchExpressions is a list of label selector requirements.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1694,
          },
          "name": "matchExpressions",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
              },
              "kind": "array",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels",
            },
            "remarks": "A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \\"key\\", the operator is \\"In\\", and the values array contains only \\"value\\". The requirements are ANDed.",
            "summary": "matchLabels is a map of {key,value} pairs.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1701,
          },
          "name": "matchLabels",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "string",
              },
              "kind": "map",
            },
          },
        },
      ],
      "symbolId": "lacework-agent:IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
    },
    "lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
        },
        "summary": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 1960,
      },
      "name": "IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key",
            },
            "summary": "key is the label key that the selector applies to.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1966,
          },
          "name": "key",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator",
            },
            "remarks": "Valid operators are In, NotIn, Exists and DoesNotExist.",
            "summary": "operator represents a key's relationship to a set of values.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1973,
          },
          "name": "operator",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values",
            },
            "remarks": "If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
            "summary": "values is an array of string values.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1980,
          },
          "name": "values",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "string",
              },
              "kind": "array",
            },
          },
        },
      ],
      "symbolId": "lacework-agent:IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
    },
    "lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector",
        },
        "remarks": "The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.",
        "summary": "A label selector is a label query over a set of resources.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 1710,
      },
      "name": "IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions",
            },
            "remarks": "The requirements are ANDed.",
            "summary": "matchExpressions is a list of label selector requirements.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1716,
          },
          "name": "matchExpressions",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions",
              },
              "kind": "array",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels",
            },
            "remarks": "A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \\"key\\", the operator is \\"In\\", and the values array contains only \\"value\\". The requirements are ANDed.",
            "summary": "matchLabels is a map of {key,value} pairs.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1723,
          },
          "name": "matchLabels",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "string",
              },
              "kind": "map",
            },
          },
        },
      ],
      "symbolId": "lacework-agent:IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector",
    },
    "lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions",
        },
        "summary": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 1989,
      },
      "name": "IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key",
            },
            "summary": "key is the label key that the selector applies to.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1995,
          },
          "name": "key",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator",
            },
            "remarks": "Valid operators are In, NotIn, Exists and DoesNotExist.",
            "summary": "operator represents a key's relationship to a set of values.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 2002,
          },
          "name": "operator",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values",
            },
            "remarks": "If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
            "summary": "values is an array of string values.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 2009,
          },
          "name": "values",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "string",
              },
              "kind": "array",
            },
          },
        },
      ],
      "symbolId": "lacework-agent:IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions",
    },
    "lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution",
        },
        "summary": "Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 1198,
      },
      "name": "IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector",
            },
            "remarks": "The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.",
            "summary": "A label selector is a label query over a set of resources.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1204,
          },
          "name": "labelSelector",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces",
            },
            "remarks": "The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means \\"this pod's namespace\\".",
            "summary": "namespaces specifies a static list of namespace names that the term applies to.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1218,
          },
          "name": "namespaces",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "string",
              },
              "kind": "array",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector",
            },
            "remarks": "The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.",
            "summary": "A label selector is a label query over a set of resources.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1211,
          },
          "name": "namespaceSelector",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey",
            },
            "remarks": "Empty topologyKey is not allowed.",
            "summary": "This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1225,
          },
          "name": "topologyKey",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
      ],
      "symbolId": "lacework-agent:IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    },
    "lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
        },
        "remarks": "The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.",
        "summary": "A label selector is a label query over a set of resources.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 1394,
      },
      "name": "IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions",
            },
            "remarks": "The requirements are ANDed.",
            "summary": "matchExpressions is a list of label selector requirements.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1400,
          },
          "name": "matchExpressions",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
              },
              "kind": "array",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels",
            },
            "remarks": "A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \\"key\\", the operator is \\"In\\", and the values array contains only \\"value\\". The requirements are ANDed.",
            "summary": "matchLabels is a map of {key,value} pairs.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1407,
          },
          "name": "matchLabels",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "string",
              },
              "kind": "map",
            },
          },
        },
      ],
      "symbolId": "lacework-agent:IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
    },
    "lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
        },
        "summary": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 1732,
      },
      "name": "IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key",
            },
            "summary": "key is the label key that the selector applies to.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1738,
          },
          "name": "key",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator",
            },
            "remarks": "Valid operators are In, NotIn, Exists and DoesNotExist.",
            "summary": "operator represents a key's relationship to a set of values.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1745,
          },
          "name": "operator",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values",
            },
            "remarks": "If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
            "summary": "values is an array of string values.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1752,
          },
          "name": "values",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "string",
              },
              "kind": "array",
            },
          },
        },
      ],
      "symbolId": "lacework-agent:IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
    },
    "lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector",
        },
        "remarks": "The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.",
        "summary": "A label selector is a label query over a set of resources.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 1416,
      },
      "name": "IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions",
            },
            "remarks": "The requirements are ANDed.",
            "summary": "matchExpressions is a list of label selector requirements.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1422,
          },
          "name": "matchExpressions",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions",
              },
              "kind": "array",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels",
            },
            "remarks": "A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \\"key\\", the operator is \\"In\\", and the values array contains only \\"value\\". The requirements are ANDed.",
            "summary": "matchLabels is a map of {key,value} pairs.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1429,
          },
          "name": "matchLabels",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "string",
              },
              "kind": "map",
            },
          },
        },
      ],
      "symbolId": "lacework-agent:IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector",
    },
    "lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions",
        },
        "summary": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 1761,
      },
      "name": "IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key",
            },
            "summary": "key is the label key that the selector applies to.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1767,
          },
          "name": "key",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator",
            },
            "remarks": "Valid operators are In, NotIn, Exists and DoesNotExist.",
            "summary": "operator represents a key's relationship to a set of values.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1774,
          },
          "name": "operator",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values",
            },
            "remarks": "If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
            "summary": "values is an array of string values.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1781,
          },
          "name": "values",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "string",
              },
              "kind": "array",
            },
          },
        },
      ],
      "symbolId": "lacework-agent:IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions",
    },
    "lacework-agent.IoK8SApiCoreV1DaemonSetUpdateStrategy": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "io.k8s.api.core.v1.DaemonSetUpdateStrategy",
        },
        "summary": "DaemonSetUpdateStrategy is a struct used to control the update strategy for a DaemonSet.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1DaemonSetUpdateStrategy",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 620,
      },
      "name": "IoK8SApiCoreV1DaemonSetUpdateStrategy",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "io.k8s.api.core.v1.DaemonSetUpdateStrategy#rollingUpdate",
            },
            "summary": "Spec to control the desired behavior of daemon set rolling update.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 626,
          },
          "name": "rollingUpdate",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.IoK8SApiCoreV1DaemonSetUpdateStrategyRollingUpdate",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "io.k8s.api.core.v1.DaemonSetUpdateStrategy#type",
            },
            "default": "RollingUpdate.",
            "remarks": "Possible enum values:
- \`\\"OnDelete\\"\` Replace the old daemons only when it's killed
- \`\\"RollingUpdate\\"\` Replace the old daemons by new ones using rolling update i.e replace them on each node one after the other.",
            "summary": "Type of daemon set update. Can be \\"RollingUpdate\\" or \\"OnDelete\\". Default is RollingUpdate.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 638,
          },
          "name": "type",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.IoK8SApiCoreV1DaemonSetUpdateStrategyType",
          },
        },
      ],
      "symbolId": "lacework-agent:IoK8SApiCoreV1DaemonSetUpdateStrategy",
    },
    "lacework-agent.IoK8SApiCoreV1DaemonSetUpdateStrategyRollingUpdate": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1DaemonSetUpdateStrategyRollingUpdate",
        },
        "summary": "Spec to control the desired behavior of daemon set rolling update.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1DaemonSetUpdateStrategyRollingUpdate",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 1026,
      },
      "name": "IoK8SApiCoreV1DaemonSetUpdateStrategyRollingUpdate",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1DaemonSetUpdateStrategyRollingUpdate#maxSurge",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1030,
          },
          "name": "maxSurge",
          "optional": true,
          "type": Object {
            "primitive": "any",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "IoK8SApiCoreV1DaemonSetUpdateStrategyRollingUpdate#maxUnavailable",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 1035,
          },
          "name": "maxUnavailable",
          "optional": true,
          "type": Object {
            "primitive": "any",
          },
        },
      ],
      "symbolId": "lacework-agent:IoK8SApiCoreV1DaemonSetUpdateStrategyRollingUpdate",
    },
    "lacework-agent.IoK8SApiCoreV1DaemonSetUpdateStrategyType": Object {
      "assembly": "lacework-agent",
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1DaemonSetUpdateStrategyType",
        },
        "default": "RollingUpdate.",
        "remarks": "Possible enum values:
- \`\\"OnDelete\\"\` Replace the old daemons only when it's killed
- \`\\"RollingUpdate\\"\` Replace the old daemons by new ones using rolling update i.e replace them on each node one after the other.",
        "summary": "Type of daemon set update. Can be \\"RollingUpdate\\" or \\"OnDelete\\". Default is RollingUpdate.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1DaemonSetUpdateStrategyType",
      "kind": "enum",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 1049,
      },
      "members": Array [
        Object {
          "docs": Object {
            "summary": "OnDelete.",
          },
          "name": "ON_DELETE",
        },
        Object {
          "docs": Object {
            "summary": "RollingUpdate.",
          },
          "name": "ROLLING_UPDATE",
        },
      ],
      "name": "IoK8SApiCoreV1DaemonSetUpdateStrategyType",
      "symbolId": "lacework-agent:IoK8SApiCoreV1DaemonSetUpdateStrategyType",
    },
    "lacework-agent.IoK8SApiCoreV1LocalObjectReference": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "io.k8s.api.core.v1.LocalObjectReference",
        },
        "summary": "LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1LocalObjectReference",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 658,
      },
      "name": "IoK8SApiCoreV1LocalObjectReference",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "io.k8s.api.core.v1.LocalObjectReference#name",
            },
            "remarks": "More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
            "summary": "Name of the referent.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 664,
          },
          "name": "name",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
      ],
      "symbolId": "lacework-agent:IoK8SApiCoreV1LocalObjectReference",
    },
    "lacework-agent.IoK8SApiCoreV1ResourceRequirements": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "io.k8s.api.core.v1.ResourceRequirements",
        },
        "summary": "ResourceRequirements describes the compute resource requirements.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1ResourceRequirements",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 516,
      },
      "name": "IoK8SApiCoreV1ResourceRequirements",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "io.k8s.api.core.v1.ResourceRequirements#limits",
            },
            "remarks": "More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/",
            "summary": "Limits describes the maximum amount of compute resources allowed.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 522,
          },
          "name": "limits",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "any",
              },
              "kind": "map",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "io.k8s.api.core.v1.ResourceRequirements#requests",
            },
            "remarks": "If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/",
            "summary": "Requests describes the minimum amount of compute resources required.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 529,
          },
          "name": "requests",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "any",
              },
              "kind": "map",
            },
          },
        },
      ],
      "symbolId": "lacework-agent:IoK8SApiCoreV1ResourceRequirements",
    },
    "lacework-agent.IoK8SApiCoreV1Toleration": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "io.k8s.api.core.v1.Toleration",
        },
        "summary": "The pod this Toleration is attached to tolerates any taint that matches the triple <key,value,effect> using the matching operator <operator>.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1Toleration",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 538,
      },
      "name": "IoK8SApiCoreV1Toleration",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "io.k8s.api.core.v1.Toleration#effect",
            },
            "remarks": "Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.

Possible enum values:
- \`\\"NoExecute\\"\` Evict any already-running pods that do not tolerate the taint. Currently enforced by NodeController.
- \`\\"NoSchedule\\"\` Do not allow new pods to schedule onto the node unless they tolerate the taint, but allow all pods submitted to Kubelet without going through the scheduler to start, and allow all already-running pods to continue running. Enforced by the scheduler.
- \`\\"PreferNoSchedule\\"\` Like TaintEffectNoSchedule, but the scheduler tries not to schedule new pods onto the node, rather than prohibiting new pods from scheduling onto the node entirely. Enforced by the scheduler.",
            "summary": "Effect indicates the taint effect to match.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 549,
          },
          "name": "effect",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.IoK8SApiCoreV1TolerationEffect",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "io.k8s.api.core.v1.Toleration#key",
            },
            "remarks": "Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.",
            "summary": "Key is the taint key that the toleration applies to.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 556,
          },
          "name": "key",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "io.k8s.api.core.v1.Toleration#operator",
            },
            "default": "Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.",
            "remarks": "Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.

Possible enum values:
- \`\\"Equal\\"\`
- \`\\"Exists\\"\`",
            "summary": "Operator represents a key's relationship to the value.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 568,
          },
          "name": "operator",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.IoK8SApiCoreV1TolerationOperator",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "io.k8s.api.core.v1.Toleration#tolerationSeconds",
            },
            "remarks": "By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.",
            "summary": "TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 575,
          },
          "name": "tolerationSeconds",
          "optional": true,
          "type": Object {
            "primitive": "number",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "io.k8s.api.core.v1.Toleration#value",
            },
            "remarks": "If the operator is Exists, the value should be empty, otherwise just a regular string.",
            "summary": "Value is the taint value the toleration matches to.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 582,
          },
          "name": "value",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
      ],
      "symbolId": "lacework-agent:IoK8SApiCoreV1Toleration",
    },
    "lacework-agent.IoK8SApiCoreV1TolerationEffect": Object {
      "assembly": "lacework-agent",
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1TolerationEffect",
        },
        "remarks": "Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.

Possible enum values:
- \`\\"NoExecute\\"\` Evict any already-running pods that do not tolerate the taint. Currently enforced by NodeController.
- \`\\"NoSchedule\\"\` Do not allow new pods to schedule onto the node unless they tolerate the taint, but allow all pods submitted to Kubelet without going through the scheduler to start, and allow all already-running pods to continue running. Enforced by the scheduler.
- \`\\"PreferNoSchedule\\"\` Like TaintEffectNoSchedule, but the scheduler tries not to schedule new pods onto the node, rather than prohibiting new pods from scheduling onto the node entirely. Enforced by the scheduler.",
        "summary": "Effect indicates the taint effect to match.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1TolerationEffect",
      "kind": "enum",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 929,
      },
      "members": Array [
        Object {
          "docs": Object {
            "summary": "NoExecute.",
          },
          "name": "NO_EXECUTE",
        },
        Object {
          "docs": Object {
            "summary": "NoSchedule.",
          },
          "name": "NO_SCHEDULE",
        },
        Object {
          "docs": Object {
            "summary": "PreferNoSchedule.",
          },
          "name": "PREFER_NO_SCHEDULE",
        },
      ],
      "name": "IoK8SApiCoreV1TolerationEffect",
      "symbolId": "lacework-agent:IoK8SApiCoreV1TolerationEffect",
    },
    "lacework-agent.IoK8SApiCoreV1TolerationOperator": Object {
      "assembly": "lacework-agent",
      "docs": Object {
        "custom": Object {
          "schema": "IoK8SApiCoreV1TolerationOperator",
        },
        "default": "Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.",
        "remarks": "Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.

Possible enum values:
- \`\\"Equal\\"\`
- \`\\"Exists\\"\`",
        "summary": "Operator represents a key's relationship to the value.",
      },
      "fqn": "lacework-agent.IoK8SApiCoreV1TolerationOperator",
      "kind": "enum",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 948,
      },
      "members": Array [
        Object {
          "docs": Object {
            "summary": "Equal.",
          },
          "name": "EQUAL",
        },
        Object {
          "docs": Object {
            "summary": "Exists.",
          },
          "name": "EXISTS",
        },
      ],
      "name": "IoK8SApiCoreV1TolerationOperator",
      "symbolId": "lacework-agent:IoK8SApiCoreV1TolerationOperator",
    },
    "lacework-agent.LaceworkAgent": Object {
      "assembly": "lacework-agent",
      "base": "constructs.Construct",
      "fqn": "lacework-agent.LaceworkAgent",
      "initializer": Object {
        "locationInModule": Object {
          "filename": "lacework-agent.ts",
          "line": 14,
        },
        "parameters": Array [
          Object {
            "name": "scope",
            "type": Object {
              "fqn": "constructs.Construct",
            },
          },
          Object {
            "name": "id",
            "type": Object {
              "primitive": "string",
            },
          },
          Object {
            "name": "props",
            "type": Object {
              "fqn": "lacework-agent.LaceworkAgentProps",
            },
          },
        ],
      },
      "kind": "class",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 13,
      },
      "name": "LaceworkAgent",
      "symbolId": "lacework-agent:LaceworkAgent",
    },
    "lacework-agent.LaceworkAgentCloudservice": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "LaceworkAgentCloudservice",
        },
      },
      "fqn": "lacework-agent.LaceworkAgentCloudservice",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 243,
      },
      "name": "LaceworkAgentCloudservice",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentCloudservice#gke",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 247,
          },
          "name": "gke",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.LaceworkAgentCloudserviceGke",
          },
        },
      ],
      "symbolId": "lacework-agent:LaceworkAgentCloudservice",
    },
    "lacework-agent.LaceworkAgentCloudserviceGke": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "LaceworkAgentCloudserviceGke",
        },
      },
      "fqn": "lacework-agent.LaceworkAgentCloudserviceGke",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 645,
      },
      "name": "LaceworkAgentCloudserviceGke",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentCloudserviceGke#autopilot",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 649,
          },
          "name": "autopilot",
          "optional": true,
          "type": Object {
            "primitive": "boolean",
          },
        },
      ],
      "symbolId": "lacework-agent:LaceworkAgentCloudserviceGke",
    },
    "lacework-agent.LaceworkAgentClusterAgent": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "LaceworkAgentClusterAgent",
        },
      },
      "fqn": "lacework-agent.LaceworkAgentClusterAgent",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 327,
      },
      "name": "LaceworkAgentClusterAgent",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentClusterAgent#enable",
            },
            "summary": "Enable cluster agent.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 338,
          },
          "name": "enable",
          "type": Object {
            "primitive": "boolean",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentClusterAgent#image",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 331,
          },
          "name": "image",
          "type": Object {
            "fqn": "lacework-agent.LaceworkAgentClusterAgentImage",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentClusterAgent#additionalValues",
            },
            "summary": "Values that are not available in values.schema.json will not be code generated. You can add such values to this property.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 373,
          },
          "name": "additionalValues",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "any",
              },
              "kind": "map",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentClusterAgent#clusterRegion",
            },
            "summary": "Kubernetes cluster cloud region.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 352,
          },
          "name": "clusterRegion",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentClusterAgent#clusterType",
            },
            "summary": "Kubernetes cluster type.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 345,
          },
          "name": "clusterType",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.LaceworkAgentClusterAgentClusterType",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentClusterAgent#scrapeInitialDelayMins",
            },
            "summary": "Cluster mode agent's initial delay of cluster scraping after startup in minutes.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 359,
          },
          "name": "scrapeInitialDelayMins",
          "optional": true,
          "type": Object {
            "primitive": "number",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentClusterAgent#scrapeIntervalMins",
            },
            "summary": "Cluster mode agent's scrape interval in minutes.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 366,
          },
          "name": "scrapeIntervalMins",
          "optional": true,
          "type": Object {
            "primitive": "number",
          },
        },
      ],
      "symbolId": "lacework-agent:LaceworkAgentClusterAgent",
    },
    "lacework-agent.LaceworkAgentClusterAgentClusterType": Object {
      "assembly": "lacework-agent",
      "docs": Object {
        "custom": Object {
          "schema": "LaceworkAgentClusterAgentClusterType",
        },
        "summary": "Kubernetes cluster type.",
      },
      "fqn": "lacework-agent.LaceworkAgentClusterAgentClusterType",
      "kind": "enum",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 741,
      },
      "members": Array [
        Object {
          "docs": Object {
            "summary": "eks.",
          },
          "name": "EKS",
        },
        Object {
          "docs": Object {
            "summary": "gke.",
          },
          "name": "GKE",
        },
        Object {
          "docs": Object {
            "summary": "unknown.",
          },
          "name": "UNKNOWN",
        },
      ],
      "name": "LaceworkAgentClusterAgentClusterType",
      "symbolId": "lacework-agent:LaceworkAgentClusterAgentClusterType",
    },
    "lacework-agent.LaceworkAgentClusterAgentImage": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "LaceworkAgentClusterAgentImage",
        },
      },
      "fqn": "lacework-agent.LaceworkAgentClusterAgentImage",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 691,
      },
      "name": "LaceworkAgentClusterAgentImage",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentClusterAgentImage#pullPolicy",
            },
            "default": "Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images",
            "remarks": "One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images

Possible enum values:
- \`\\"Always\\"\` means that kubelet always attempts to pull the latest image. Container will fail If the pull fails.
- \`\\"IfNotPresent\\"\` means that kubelet pulls if the image isn't present on disk. Container will fail if the image isn't present and the pull fails.
- \`\\"Never\\"\` means that kubelet never pulls an image, but only uses a local image. Container will fail if the image isn't present",
            "summary": "Image pull policy.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 710,
          },
          "name": "pullPolicy",
          "type": Object {
            "fqn": "lacework-agent.LaceworkAgentClusterAgentImagePullPolicy",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentClusterAgentImage#registry",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 715,
          },
          "name": "registry",
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentClusterAgentImage#repository",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 720,
          },
          "name": "repository",
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentClusterAgentImage#tag",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 725,
          },
          "name": "tag",
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentClusterAgentImage#additionalValues",
            },
            "summary": "Values that are not available in values.schema.json will not be code generated. You can add such values to this property.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 732,
          },
          "name": "additionalValues",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "any",
              },
              "kind": "map",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentClusterAgentImage#imagePullSecrets",
            },
            "remarks": "If specified, these secrets will be passed to individual puller implementations for them to use. More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod",
            "summary": "ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 697,
          },
          "name": "imagePullSecrets",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "fqn": "lacework-agent.IoK8SApiCoreV1LocalObjectReference",
              },
              "kind": "array",
            },
          },
        },
      ],
      "symbolId": "lacework-agent:LaceworkAgentClusterAgentImage",
    },
    "lacework-agent.LaceworkAgentClusterAgentImagePullPolicy": Object {
      "assembly": "lacework-agent",
      "docs": Object {
        "custom": Object {
          "schema": "LaceworkAgentClusterAgentImagePullPolicy",
        },
        "default": "Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images",
        "remarks": "One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images

Possible enum values:
- \`\\"Always\\"\` means that kubelet always attempts to pull the latest image. Container will fail If the pull fails.
- \`\\"IfNotPresent\\"\` means that kubelet pulls if the image isn't present on disk. Container will fail if the image isn't present and the pull fails.
- \`\\"Never\\"\` means that kubelet never pulls an image, but only uses a local image. Container will fail if the image isn't present",
        "summary": "Image pull policy.",
      },
      "fqn": "lacework-agent.LaceworkAgentClusterAgentImagePullPolicy",
      "kind": "enum",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 1067,
      },
      "members": Array [
        Object {
          "docs": Object {
            "summary": "Always.",
          },
          "name": "ALWAYS",
        },
        Object {
          "docs": Object {
            "summary": "IfNotPresent.",
          },
          "name": "IF_NOT_PRESENT",
        },
        Object {
          "docs": Object {
            "summary": "Never.",
          },
          "name": "NEVER",
        },
      ],
      "name": "LaceworkAgentClusterAgentImagePullPolicy",
      "symbolId": "lacework-agent:LaceworkAgentClusterAgentImagePullPolicy",
    },
    "lacework-agent.LaceworkAgentDaemonset": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "LaceworkAgentDaemonset",
        },
      },
      "fqn": "lacework-agent.LaceworkAgentDaemonset",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 161,
      },
      "name": "LaceworkAgentDaemonset",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentDaemonset#affinity",
            },
            "summary": "If specified, the pod's scheduling constraints.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 167,
          },
          "name": "affinity",
          "type": Object {
            "fqn": "lacework-agent.IoK8SApiCoreV1Affinity",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentDaemonset#updateStrategy",
            },
            "summary": "An update strategy to replace existing DaemonSet pods with new pods.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 174,
          },
          "name": "updateStrategy",
          "type": Object {
            "fqn": "lacework-agent.IoK8SApiCoreV1DaemonSetUpdateStrategy",
          },
        },
      ],
      "symbolId": "lacework-agent:LaceworkAgentDaemonset",
    },
    "lacework-agent.LaceworkAgentDatacollector": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "LaceworkAgentDatacollector",
        },
      },
      "fqn": "lacework-agent.LaceworkAgentDatacollector",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 254,
      },
      "name": "LaceworkAgentDatacollector",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentDatacollector#additionalValues",
            },
            "summary": "Values that are not available in values.schema.json will not be code generated. You can add such values to this property.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 267,
          },
          "name": "additionalValues",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "any",
              },
              "kind": "map",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentDatacollector#enable",
            },
            "summary": "Enable lacework datacollector.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 260,
          },
          "name": "enable",
          "optional": true,
          "type": Object {
            "primitive": "boolean",
          },
        },
      ],
      "symbolId": "lacework-agent:LaceworkAgentDatacollector",
    },
    "lacework-agent.LaceworkAgentDeployment": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "LaceworkAgentDeployment",
        },
      },
      "fqn": "lacework-agent.LaceworkAgentDeployment",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 181,
      },
      "name": "LaceworkAgentDeployment",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentDeployment#affinity",
            },
            "summary": "If specified, the pod's scheduling constraints.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 187,
          },
          "name": "affinity",
          "type": Object {
            "fqn": "lacework-agent.IoK8SApiCoreV1Affinity",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentDeployment#updateStrategy",
            },
            "summary": "An update strategy to replace existing DaemonSet pods with new pods.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 194,
          },
          "name": "updateStrategy",
          "type": Object {
            "fqn": "lacework-agent.IoK8SApiCoreV1DaemonSetUpdateStrategy",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentDeployment#priorityClassCreate",
            },
            "summary": "If specified, a priority class is created and used to deploy agent.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 215,
          },
          "name": "priorityClassCreate",
          "optional": true,
          "type": Object {
            "primitive": "boolean",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentDeployment#priorityClassName",
            },
            "remarks": "\\"system-node-critical\\" and \\"system-cluster-critical\\" are two special keywords which indicate the highest priorities with the former being the highest priority. Any other name must be defined by creating a PriorityClass object with that name. If not specified, the pod priority will be default or zero if there is no default.",
            "summary": "If specified, indicates the pod's priority.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 208,
          },
          "name": "priorityClassName",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentDeployment#priorityClassPreemptionPolicy",
            },
            "summary": "If specified, it determines if agent pod can preempt a pod with a lower a priority.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 222,
          },
          "name": "priorityClassPreemptionPolicy",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentDeployment#priorityClassValue",
            },
            "summary": "If specified, it represents the priority class value to use.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 229,
          },
          "name": "priorityClassValue",
          "optional": true,
          "type": Object {
            "primitive": "number",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentDeployment#resources",
            },
            "remarks": "Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/",
            "summary": "Compute Resources required by this container.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 201,
          },
          "name": "resources",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.IoK8SApiCoreV1ResourceRequirements",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentDeployment#tolerations",
            },
            "summary": "If specified, the pod's tolerations.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 236,
          },
          "name": "tolerations",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "fqn": "lacework-agent.IoK8SApiCoreV1Toleration",
              },
              "kind": "array",
            },
          },
        },
      ],
      "symbolId": "lacework-agent:LaceworkAgentDeployment",
    },
    "lacework-agent.LaceworkAgentImage": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "LaceworkAgentImage",
        },
      },
      "fqn": "lacework-agent.LaceworkAgentImage",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 274,
      },
      "name": "LaceworkAgentImage",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentImage#pullPolicy",
            },
            "default": "Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images",
            "remarks": "One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images

Possible enum values:
- \`\\"Always\\"\` means that kubelet always attempts to pull the latest image. Container will fail If the pull fails.
- \`\\"IfNotPresent\\"\` means that kubelet pulls if the image isn't present on disk. Container will fail if the image isn't present and the pull fails.
- \`\\"Never\\"\` means that kubelet never pulls an image, but only uses a local image. Container will fail if the image isn't present",
            "summary": "Image pull policy.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 293,
          },
          "name": "pullPolicy",
          "type": Object {
            "fqn": "lacework-agent.LaceworkAgentImagePullPolicy",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentImage#registry",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 298,
          },
          "name": "registry",
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentImage#repository",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 303,
          },
          "name": "repository",
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentImage#tag",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 308,
          },
          "name": "tag",
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentImage#additionalValues",
            },
            "summary": "Values that are not available in values.schema.json will not be code generated. You can add such values to this property.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 320,
          },
          "name": "additionalValues",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "any",
              },
              "kind": "map",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentImage#imagePullSecrets",
            },
            "remarks": "If specified, these secrets will be passed to individual puller implementations for them to use. More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod",
            "summary": "ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 280,
          },
          "name": "imagePullSecrets",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "fqn": "lacework-agent.IoK8SApiCoreV1LocalObjectReference",
              },
              "kind": "array",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentImage#overrideValue",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 313,
          },
          "name": "overrideValue",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
      ],
      "symbolId": "lacework-agent:LaceworkAgentImage",
    },
    "lacework-agent.LaceworkAgentImagePullPolicy": Object {
      "assembly": "lacework-agent",
      "docs": Object {
        "custom": Object {
          "schema": "LaceworkAgentImagePullPolicy",
        },
        "default": "Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images",
        "remarks": "One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images

Possible enum values:
- \`\\"Always\\"\` means that kubelet always attempts to pull the latest image. Container will fail If the pull fails.
- \`\\"IfNotPresent\\"\` means that kubelet pulls if the image isn't present on disk. Container will fail if the image isn't present and the pull fails.
- \`\\"Never\\"\` means that kubelet never pulls an image, but only uses a local image. Container will fail if the image isn't present",
        "summary": "Image pull policy.",
      },
      "fqn": "lacework-agent.LaceworkAgentImagePullPolicy",
      "kind": "enum",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 679,
      },
      "members": Array [
        Object {
          "docs": Object {
            "summary": "Always.",
          },
          "name": "ALWAYS",
        },
        Object {
          "docs": Object {
            "summary": "IfNotPresent.",
          },
          "name": "IF_NOT_PRESENT",
        },
        Object {
          "docs": Object {
            "summary": "Never.",
          },
          "name": "NEVER",
        },
      ],
      "name": "LaceworkAgentImagePullPolicy",
      "symbolId": "lacework-agent:LaceworkAgentImagePullPolicy",
    },
    "lacework-agent.LaceworkAgentLaceworkConfig": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "LaceworkAgentLaceworkConfig",
        },
      },
      "fqn": "lacework-agent.LaceworkAgentLaceworkConfig",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 380,
      },
      "name": "LaceworkAgentLaceworkConfig",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfig#accessToken",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 384,
          },
          "name": "accessToken",
          "type": Object {
            "primitive": "any",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfig#additionalValues",
            },
            "summary": "Values that are not available in values.schema.json will not be code generated. You can add such values to this property.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 507,
          },
          "name": "additionalValues",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "any",
              },
              "kind": "map",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfig#annotations",
            },
            "remarks": "They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations",
            "summary": "Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 396,
          },
          "name": "annotations",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "string",
              },
              "kind": "map",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfig#anonymizeIncoming",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 389,
          },
          "name": "anonymizeIncoming",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.LaceworkAgentLaceworkConfigAnonymizeIncoming",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfig#autoUpgrade",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 401,
          },
          "name": "autoUpgrade",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.LaceworkAgentLaceworkConfigAutoUpgrade",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfig#cmdlinefilter",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 406,
          },
          "name": "cmdlinefilter",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.LaceworkAgentLaceworkConfigCmdlinefilter",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfig#codeaware",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 411,
          },
          "name": "codeaware",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.LaceworkAgentLaceworkConfigCodeaware",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfig#containerEngineEndpoint",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 416,
          },
          "name": "containerEngineEndpoint",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfig#containerRuntime",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 421,
          },
          "name": "containerRuntime",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.LaceworkAgentLaceworkConfigContainerRuntime",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfig#datacollector",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 426,
          },
          "name": "datacollector",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.LaceworkAgentLaceworkConfigDatacollector",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfig#env",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 455,
          },
          "name": "env",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfig#fim",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 460,
          },
          "name": "fim",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.LaceworkAgentLaceworkConfigFim",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfig#k8sNodeScrapeIntervalMins",
            },
            "summary": "Kubernetes node's scrape interval in minutes.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 433,
          },
          "name": "k8SNodeScrapeIntervalMins",
          "optional": true,
          "type": Object {
            "primitive": "number",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfig#kubernetesCluster",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 438,
          },
          "name": "kubernetesCluster",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfig#labels",
            },
            "remarks": "May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels",
            "summary": "Map of string keys and values that can be used to organize and categorize (scope and select) objects.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 445,
          },
          "name": "labels",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "string",
              },
              "kind": "map",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfig#metadataRequestInterval",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 450,
          },
          "name": "metadataRequestInterval",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfig#packagescan",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 465,
          },
          "name": "packagescan",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.LaceworkAgentLaceworkConfigPackagescan",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfig#perfmode",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 500,
          },
          "name": "perfmode",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.LaceworkAgentLaceworkConfigPerfmode",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfig#procscan",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 470,
          },
          "name": "procscan",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.LaceworkAgentLaceworkConfigProcscan",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfig#proxyUrl",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 475,
          },
          "name": "proxyUrl",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfig#serverUrl",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 480,
          },
          "name": "serverUrl",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfig#serviceAccountName",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 485,
          },
          "name": "serviceAccountName",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfig#stdoutLogging",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 490,
          },
          "name": "stdoutLogging",
          "optional": true,
          "type": Object {
            "primitive": "boolean",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfig#tags",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 495,
          },
          "name": "tags",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "string",
              },
              "kind": "map",
            },
          },
        },
      ],
      "symbolId": "lacework-agent:LaceworkAgentLaceworkConfig",
    },
    "lacework-agent.LaceworkAgentLaceworkConfigAnonymizeIncoming": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "LaceworkAgentLaceworkConfigAnonymizeIncoming",
        },
      },
      "fqn": "lacework-agent.LaceworkAgentLaceworkConfigAnonymizeIncoming",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 753,
      },
      "name": "LaceworkAgentLaceworkConfigAnonymizeIncoming",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfigAnonymizeIncoming#additionalValues",
            },
            "summary": "Values that are not available in values.schema.json will not be code generated. You can add such values to this property.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 764,
          },
          "name": "additionalValues",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "any",
              },
              "kind": "map",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfigAnonymizeIncoming#netmask",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 757,
          },
          "name": "netmask",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
      ],
      "symbolId": "lacework-agent:LaceworkAgentLaceworkConfigAnonymizeIncoming",
    },
    "lacework-agent.LaceworkAgentLaceworkConfigAutoUpgrade": Object {
      "assembly": "lacework-agent",
      "docs": Object {
        "custom": Object {
          "schema": "LaceworkAgentLaceworkConfigAutoUpgrade",
        },
      },
      "fqn": "lacework-agent.LaceworkAgentLaceworkConfigAutoUpgrade",
      "kind": "enum",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 771,
      },
      "members": Array [
        Object {
          "docs": Object {
            "summary": "disable.",
          },
          "name": "DISABLE",
        },
        Object {
          "docs": Object {
            "summary": "enable.",
          },
          "name": "ENABLE",
        },
      ],
      "name": "LaceworkAgentLaceworkConfigAutoUpgrade",
      "symbolId": "lacework-agent:LaceworkAgentLaceworkConfigAutoUpgrade",
    },
    "lacework-agent.LaceworkAgentLaceworkConfigCmdlinefilter": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "LaceworkAgentLaceworkConfigCmdlinefilter",
        },
      },
      "fqn": "lacework-agent.LaceworkAgentLaceworkConfigCmdlinefilter",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 781,
      },
      "name": "LaceworkAgentLaceworkConfigCmdlinefilter",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfigCmdlinefilter#allow",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 785,
          },
          "name": "allow",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfigCmdlinefilter#disallow",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 790,
          },
          "name": "disallow",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
      ],
      "symbolId": "lacework-agent:LaceworkAgentLaceworkConfigCmdlinefilter",
    },
    "lacework-agent.LaceworkAgentLaceworkConfigCodeaware": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "LaceworkAgentLaceworkConfigCodeaware",
        },
      },
      "fqn": "lacework-agent.LaceworkAgentLaceworkConfigCodeaware",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 797,
      },
      "name": "LaceworkAgentLaceworkConfigCodeaware",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfigCodeaware#enable",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 801,
          },
          "name": "enable",
          "optional": true,
          "type": Object {
            "primitive": "boolean",
          },
        },
      ],
      "symbolId": "lacework-agent:LaceworkAgentLaceworkConfigCodeaware",
    },
    "lacework-agent.LaceworkAgentLaceworkConfigContainerRuntime": Object {
      "assembly": "lacework-agent",
      "docs": Object {
        "custom": Object {
          "schema": "LaceworkAgentLaceworkConfigContainerRuntime",
        },
      },
      "fqn": "lacework-agent.LaceworkAgentLaceworkConfigContainerRuntime",
      "kind": "enum",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 808,
      },
      "members": Array [
        Object {
          "docs": Object {
            "summary": "containerd.",
          },
          "name": "CONTAINERD",
        },
        Object {
          "docs": Object {
            "summary": "cri-o.",
          },
          "name": "CRI_HYPHEN_O",
        },
        Object {
          "docs": Object {
            "summary": "docker.",
          },
          "name": "DOCKER",
        },
      ],
      "name": "LaceworkAgentLaceworkConfigContainerRuntime",
      "symbolId": "lacework-agent:LaceworkAgentLaceworkConfigContainerRuntime",
    },
    "lacework-agent.LaceworkAgentLaceworkConfigDatacollector": Object {
      "assembly": "lacework-agent",
      "docs": Object {
        "custom": Object {
          "schema": "LaceworkAgentLaceworkConfigDatacollector",
        },
      },
      "fqn": "lacework-agent.LaceworkAgentLaceworkConfigDatacollector",
      "kind": "enum",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 820,
      },
      "members": Array [
        Object {
          "docs": Object {
            "summary": "disable.",
          },
          "name": "DISABLE",
        },
        Object {
          "docs": Object {
            "summary": "enable.",
          },
          "name": "ENABLE",
        },
      ],
      "name": "LaceworkAgentLaceworkConfigDatacollector",
      "symbolId": "lacework-agent:LaceworkAgentLaceworkConfigDatacollector",
    },
    "lacework-agent.LaceworkAgentLaceworkConfigFim": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "LaceworkAgentLaceworkConfigFim",
        },
      },
      "fqn": "lacework-agent.LaceworkAgentLaceworkConfigFim",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 830,
      },
      "name": "LaceworkAgentLaceworkConfigFim",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfigFim#enable",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 844,
          },
          "name": "enable",
          "type": Object {
            "primitive": "boolean",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfigFim#fileIgnore",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 849,
          },
          "name": "fileIgnore",
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "string",
              },
              "kind": "array",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfigFim#filePath",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 854,
          },
          "name": "filePath",
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "string",
              },
              "kind": "array",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfigFim#additionalValues",
            },
            "summary": "Values that are not available in values.schema.json will not be code generated. You can add such values to this property.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 871,
          },
          "name": "additionalValues",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "any",
              },
              "kind": "map",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfigFim#coolingPeriod",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 834,
          },
          "name": "coolingPeriod",
          "optional": true,
          "type": Object {
            "primitive": "number",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfigFim#crawlInterval",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 839,
          },
          "name": "crawlInterval",
          "optional": true,
          "type": Object {
            "primitive": "number",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfigFim#noAtime",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 859,
          },
          "name": "noAtime",
          "optional": true,
          "type": Object {
            "primitive": "boolean",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfigFim#runAt",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 864,
          },
          "name": "runAt",
          "optional": true,
          "type": Object {
            "primitive": "any",
          },
        },
      ],
      "symbolId": "lacework-agent:LaceworkAgentLaceworkConfigFim",
    },
    "lacework-agent.LaceworkAgentLaceworkConfigPackagescan": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "LaceworkAgentLaceworkConfigPackagescan",
        },
      },
      "fqn": "lacework-agent.LaceworkAgentLaceworkConfigPackagescan",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 878,
      },
      "name": "LaceworkAgentLaceworkConfigPackagescan",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfigPackagescan#enable",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 882,
          },
          "name": "enable",
          "optional": true,
          "type": Object {
            "primitive": "boolean",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfigPackagescan#interval",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 887,
          },
          "name": "interval",
          "optional": true,
          "type": Object {
            "primitive": "number",
          },
        },
      ],
      "symbolId": "lacework-agent:LaceworkAgentLaceworkConfigPackagescan",
    },
    "lacework-agent.LaceworkAgentLaceworkConfigPerfmode": Object {
      "assembly": "lacework-agent",
      "docs": Object {
        "custom": Object {
          "schema": "LaceworkAgentLaceworkConfigPerfmode",
        },
      },
      "fqn": "lacework-agent.LaceworkAgentLaceworkConfigPerfmode",
      "kind": "enum",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 910,
      },
      "members": Array [
        Object {
          "docs": Object {
            "summary": "lite.",
          },
          "name": "LITE",
        },
        Object {
          "docs": Object {
            "summary": "scan.",
          },
          "name": "SCAN",
        },
        Object {
          "docs": Object {
            "summary": "ebpflite.",
          },
          "name": "EBPFLITE",
        },
      ],
      "name": "LaceworkAgentLaceworkConfigPerfmode",
      "symbolId": "lacework-agent:LaceworkAgentLaceworkConfigPerfmode",
    },
    "lacework-agent.LaceworkAgentLaceworkConfigProcscan": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "LaceworkAgentLaceworkConfigProcscan",
        },
      },
      "fqn": "lacework-agent.LaceworkAgentLaceworkConfigProcscan",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 894,
      },
      "name": "LaceworkAgentLaceworkConfigProcscan",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfigProcscan#enable",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 898,
          },
          "name": "enable",
          "optional": true,
          "type": Object {
            "primitive": "boolean",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "LaceworkAgentLaceworkConfigProcscan#interval",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 903,
          },
          "name": "interval",
          "optional": true,
          "type": Object {
            "primitive": "number",
          },
        },
      ],
      "symbolId": "lacework-agent:LaceworkAgentLaceworkConfigProcscan",
    },
    "lacework-agent.LaceworkAgentProps": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "fqn": "lacework-agent.LaceworkAgentProps",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 5,
      },
      "name": "LaceworkAgentProps",
      "properties": Array [
        Object {
          "abstract": true,
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 10,
          },
          "name": "values",
          "type": Object {
            "fqn": "lacework-agent.LaceworkAgentValues",
          },
        },
        Object {
          "abstract": true,
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 8,
          },
          "name": "helmExecutable",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 9,
          },
          "name": "helmFlags",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "string",
              },
              "kind": "array",
            },
          },
        },
        Object {
          "abstract": true,
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 6,
          },
          "name": "namespace",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 7,
          },
          "name": "releaseName",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
      ],
      "symbolId": "lacework-agent:LaceworkAgentProps",
    },
    "lacework-agent.LaceworkAgentValues": Object {
      "assembly": "lacework-agent",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "lacework-agent",
        },
      },
      "fqn": "lacework-agent.LaceworkAgentValues",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "lacework-agent.ts",
        "line": 66,
      },
      "name": "LaceworkAgentValues",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "lacework-agent#laceworkConfig",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 105,
          },
          "name": "laceworkConfig",
          "type": Object {
            "fqn": "lacework-agent.LaceworkAgentLaceworkConfig",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "lacework-agent#additionalValues",
            },
            "summary": "Values that are not available in values.schema.json will not be code generated. You can add such values to this property.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 154,
          },
          "name": "additionalValues",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "any",
              },
              "kind": "map",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "lacework-agent#cloudservice",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 85,
          },
          "name": "cloudservice",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.LaceworkAgentCloudservice",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "lacework-agent#clusterAgent",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 100,
          },
          "name": "clusterAgent",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.LaceworkAgentClusterAgent",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "lacework-agent#daemonset",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 75,
          },
          "name": "daemonset",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.LaceworkAgentDaemonset",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "lacework-agent#datacollector",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 90,
          },
          "name": "datacollector",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.LaceworkAgentDatacollector",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "lacework-agent#deployment",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 80,
          },
          "name": "deployment",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.LaceworkAgentDeployment",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "lacework-agent#global",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 70,
          },
          "name": "global",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "any",
              },
              "kind": "map",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "lacework-agent#image",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 95,
          },
          "name": "image",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.LaceworkAgentImage",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "lacework-agent#priorityClassCreate",
            },
            "summary": "If specified, a priority class is created and used to deploy agent.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 126,
          },
          "name": "priorityClassCreate",
          "optional": true,
          "type": Object {
            "primitive": "boolean",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "lacework-agent#priorityClassName",
            },
            "remarks": "\\"system-node-critical\\" and \\"system-cluster-critical\\" are two special keywords which indicate the highest priorities with the former being the highest priority. Any other name must be defined by creating a PriorityClass object with that name. If not specified, the pod priority will be default or zero if there is no default.",
            "summary": "If specified, indicates the pod's priority.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 119,
          },
          "name": "priorityClassName",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "lacework-agent#priorityClassPreemptionPolicy",
            },
            "summary": "If specified, it determines if agent pod can preempt a pod with a lower a priority.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 133,
          },
          "name": "priorityClassPreemptionPolicy",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "lacework-agent#priorityClassValue",
            },
            "summary": "If specified, it represents the priority class value to use.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 140,
          },
          "name": "priorityClassValue",
          "optional": true,
          "type": Object {
            "primitive": "number",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "lacework-agent#resources",
            },
            "remarks": "Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/",
            "summary": "Compute Resources required by this container.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 112,
          },
          "name": "resources",
          "optional": true,
          "type": Object {
            "fqn": "lacework-agent.IoK8SApiCoreV1ResourceRequirements",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "lacework-agent#tolerations",
            },
            "summary": "If specified, the pod's tolerations.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "lacework-agent.ts",
            "line": 147,
          },
          "name": "tolerations",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "fqn": "lacework-agent.IoK8SApiCoreV1Toleration",
              },
              "kind": "array",
            },
          },
        },
      ],
      "symbolId": "lacework-agent:LaceworkAgentValues",
    },
  },
  "version": "0.0.0",
}
`;

exports[`importing helm chart helm:https://lacework.github.io/helm-charts/lacework-agent@6.9.0 with typescript lanugage 2`] = `
Object {
  "lacework-agent.ts": "// generated by cdk8s
import { Helm, HelmProps } from 'cdk8s';
import { Construct } from 'constructs';

export interface LaceworkAgentProps {
  readonly namespace?: string;
  readonly releaseName?: string;
  readonly helmExecutable?: string;
  readonly helmFlags?: string[];
  readonly values: LaceworkAgentValues;
}

export class LaceworkAgent extends Construct {
  public constructor(scope: Construct, id: string, props: LaceworkAgentProps) {
    super(scope, id);
    let updatedProps = {};

    if (props.values) {
      const { additionalValues, ...valuesWithoutAdditionalValues } = props.values;
      updatedProps = {
        ...props,
        values: {
          ...this.flattenAdditionalValues(valuesWithoutAdditionalValues),
          ...additionalValues,
        },
      };
    }

    const finalProps: HelmProps = {
      chart: 'lacework-agent',
      repo: 'https://lacework.github.io/helm-charts',
      version: '6.9.0',
      ...(Object.keys(updatedProps).length !== 0 ? updatedProps : props),
    };

    new Helm(this, 'Helm', finalProps);
  }

  private flattenAdditionalValues(props: { [key: string]: any }): { [key: string]: any } {
    for (let prop in props) {
      if (Array.isArray(props[prop])) {
        props[prop].map((item: any) => {
          if (typeof item === 'object' && prop !== 'additionalValues') {
            return this.flattenAdditionalValues(item);
          }
          return item;
        });
      }
      else if (typeof props[prop] === 'object' && prop !== 'additionalValues') {
        props[prop] = this.flattenAdditionalValues(props[prop]);
      }
    }

    const { additionalValues, ...valuesWithoutAdditionalValues } = props;

    return {
      ...valuesWithoutAdditionalValues,
      ...additionalValues,
    };
  }
}

/**
 * @schema lacework-agent
 */
export interface LaceworkAgentValues {
  /**
   * @schema lacework-agent#global
   */
  readonly global?: { [key: string]: any };

  /**
   * @schema lacework-agent#daemonset
   */
  readonly daemonset?: LaceworkAgentDaemonset;

  /**
   * @schema lacework-agent#deployment
   */
  readonly deployment?: LaceworkAgentDeployment;

  /**
   * @schema lacework-agent#cloudservice
   */
  readonly cloudservice?: LaceworkAgentCloudservice;

  /**
   * @schema lacework-agent#datacollector
   */
  readonly datacollector?: LaceworkAgentDatacollector;

  /**
   * @schema lacework-agent#image
   */
  readonly image?: LaceworkAgentImage;

  /**
   * @schema lacework-agent#clusterAgent
   */
  readonly clusterAgent?: LaceworkAgentClusterAgent;

  /**
   * @schema lacework-agent#laceworkConfig
   */
  readonly laceworkConfig: LaceworkAgentLaceworkConfig;

  /**
   * Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema lacework-agent#resources
   */
  readonly resources?: IoK8SApiCoreV1ResourceRequirements;

  /**
   * If specified, indicates the pod's priority. \\"system-node-critical\\" and \\"system-cluster-critical\\" are two special keywords which indicate the highest priorities with the former being the highest priority. Any other name must be defined by creating a PriorityClass object with that name. If not specified, the pod priority will be default or zero if there is no default.
   *
   * @schema lacework-agent#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * If specified, a priority class is created and used to deploy agent
   *
   * @schema lacework-agent#priorityClassCreate
   */
  readonly priorityClassCreate?: boolean;

  /**
   * If specified, it determines if agent pod can preempt a pod with a lower a priority
   *
   * @schema lacework-agent#priorityClassPreemptionPolicy
   */
  readonly priorityClassPreemptionPolicy?: string;

  /**
   * If specified, it represents the priority class value to use
   *
   * @schema lacework-agent#priorityClassValue
   */
  readonly priorityClassValue?: number;

  /**
   * If specified, the pod's tolerations.
   *
   * @schema lacework-agent#tolerations
   */
  readonly tolerations?: IoK8SApiCoreV1Toleration[];

  /**
   * Values that are not available in values.schema.json will not be code generated. You can add such values to this property.
   *
   * @schema lacework-agent#additionalValues
   */
  readonly additionalValues?: { [key: string]: any };

}

/**
 * @schema LaceworkAgentDaemonset
 */
export interface LaceworkAgentDaemonset {
  /**
   * If specified, the pod's scheduling constraints
   *
   * @schema LaceworkAgentDaemonset#affinity
   */
  readonly affinity: IoK8SApiCoreV1Affinity;

  /**
   * An update strategy to replace existing DaemonSet pods with new pods.
   *
   * @schema LaceworkAgentDaemonset#updateStrategy
   */
  readonly updateStrategy: IoK8SApiCoreV1DaemonSetUpdateStrategy;

}

/**
 * @schema LaceworkAgentDeployment
 */
export interface LaceworkAgentDeployment {
  /**
   * If specified, the pod's scheduling constraints
   *
   * @schema LaceworkAgentDeployment#affinity
   */
  readonly affinity: IoK8SApiCoreV1Affinity;

  /**
   * An update strategy to replace existing DaemonSet pods with new pods.
   *
   * @schema LaceworkAgentDeployment#updateStrategy
   */
  readonly updateStrategy: IoK8SApiCoreV1DaemonSetUpdateStrategy;

  /**
   * Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema LaceworkAgentDeployment#resources
   */
  readonly resources?: IoK8SApiCoreV1ResourceRequirements;

  /**
   * If specified, indicates the pod's priority. \\"system-node-critical\\" and \\"system-cluster-critical\\" are two special keywords which indicate the highest priorities with the former being the highest priority. Any other name must be defined by creating a PriorityClass object with that name. If not specified, the pod priority will be default or zero if there is no default.
   *
   * @schema LaceworkAgentDeployment#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * If specified, a priority class is created and used to deploy agent
   *
   * @schema LaceworkAgentDeployment#priorityClassCreate
   */
  readonly priorityClassCreate?: boolean;

  /**
   * If specified, it determines if agent pod can preempt a pod with a lower a priority
   *
   * @schema LaceworkAgentDeployment#priorityClassPreemptionPolicy
   */
  readonly priorityClassPreemptionPolicy?: string;

  /**
   * If specified, it represents the priority class value to use
   *
   * @schema LaceworkAgentDeployment#priorityClassValue
   */
  readonly priorityClassValue?: number;

  /**
   * If specified, the pod's tolerations.
   *
   * @schema LaceworkAgentDeployment#tolerations
   */
  readonly tolerations?: IoK8SApiCoreV1Toleration[];

}

/**
 * @schema LaceworkAgentCloudservice
 */
export interface LaceworkAgentCloudservice {
  /**
   * @schema LaceworkAgentCloudservice#gke
   */
  readonly gke?: LaceworkAgentCloudserviceGke;

}

/**
 * @schema LaceworkAgentDatacollector
 */
export interface LaceworkAgentDatacollector {
  /**
   * Enable lacework datacollector
   *
   * @schema LaceworkAgentDatacollector#enable
   */
  readonly enable?: boolean;

  /**
   * Values that are not available in values.schema.json will not be code generated. You can add such values to this property.
   *
   * @schema LaceworkAgentDatacollector#additionalValues
   */
  readonly additionalValues?: { [key: string]: any };

}

/**
 * @schema LaceworkAgentImage
 */
export interface LaceworkAgentImage {
  /**
   * ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec. If specified, these secrets will be passed to individual puller implementations for them to use. More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod
   *
   * @schema LaceworkAgentImage#imagePullSecrets
   */
  readonly imagePullSecrets?: IoK8SApiCoreV1LocalObjectReference[];

  /**
   * Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   *
   * Possible enum values:
   * - \`\\"Always\\"\` means that kubelet always attempts to pull the latest image. Container will fail If the pull fails.
   * - \`\\"IfNotPresent\\"\` means that kubelet pulls if the image isn't present on disk. Container will fail if the image isn't present and the pull fails.
   * - \`\\"Never\\"\` means that kubelet never pulls an image, but only uses a local image. Container will fail if the image isn't present
   *
   * @default Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   * @schema LaceworkAgentImage#pullPolicy
   */
  readonly pullPolicy: LaceworkAgentImagePullPolicy;

  /**
   * @schema LaceworkAgentImage#registry
   */
  readonly registry: string;

  /**
   * @schema LaceworkAgentImage#repository
   */
  readonly repository: string;

  /**
   * @schema LaceworkAgentImage#tag
   */
  readonly tag: string;

  /**
   * @schema LaceworkAgentImage#overrideValue
   */
  readonly overrideValue?: string;

  /**
   * Values that are not available in values.schema.json will not be code generated. You can add such values to this property.
   *
   * @schema LaceworkAgentImage#additionalValues
   */
  readonly additionalValues?: { [key: string]: any };

}

/**
 * @schema LaceworkAgentClusterAgent
 */
export interface LaceworkAgentClusterAgent {
  /**
   * @schema LaceworkAgentClusterAgent#image
   */
  readonly image: LaceworkAgentClusterAgentImage;

  /**
   * Enable cluster agent
   *
   * @schema LaceworkAgentClusterAgent#enable
   */
  readonly enable: boolean;

  /**
   * Kubernetes cluster type
   *
   * @schema LaceworkAgentClusterAgent#clusterType
   */
  readonly clusterType?: LaceworkAgentClusterAgentClusterType;

  /**
   * Kubernetes cluster cloud region
   *
   * @schema LaceworkAgentClusterAgent#clusterRegion
   */
  readonly clusterRegion?: string;

  /**
   * Cluster mode agent's initial delay of cluster scraping after startup in minutes
   *
   * @schema LaceworkAgentClusterAgent#scrapeInitialDelayMins
   */
  readonly scrapeInitialDelayMins?: number;

  /**
   * Cluster mode agent's scrape interval in minutes
   *
   * @schema LaceworkAgentClusterAgent#scrapeIntervalMins
   */
  readonly scrapeIntervalMins?: number;

  /**
   * Values that are not available in values.schema.json will not be code generated. You can add such values to this property.
   *
   * @schema LaceworkAgentClusterAgent#additionalValues
   */
  readonly additionalValues?: { [key: string]: any };

}

/**
 * @schema LaceworkAgentLaceworkConfig
 */
export interface LaceworkAgentLaceworkConfig {
  /**
   * @schema LaceworkAgentLaceworkConfig#accessToken
   */
  readonly accessToken: any;

  /**
   * @schema LaceworkAgentLaceworkConfig#anonymizeIncoming
   */
  readonly anonymizeIncoming?: LaceworkAgentLaceworkConfigAnonymizeIncoming;

  /**
   * Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
   *
   * @schema LaceworkAgentLaceworkConfig#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * @schema LaceworkAgentLaceworkConfig#autoUpgrade
   */
  readonly autoUpgrade?: LaceworkAgentLaceworkConfigAutoUpgrade;

  /**
   * @schema LaceworkAgentLaceworkConfig#cmdlinefilter
   */
  readonly cmdlinefilter?: LaceworkAgentLaceworkConfigCmdlinefilter;

  /**
   * @schema LaceworkAgentLaceworkConfig#codeaware
   */
  readonly codeaware?: LaceworkAgentLaceworkConfigCodeaware;

  /**
   * @schema LaceworkAgentLaceworkConfig#containerEngineEndpoint
   */
  readonly containerEngineEndpoint?: string;

  /**
   * @schema LaceworkAgentLaceworkConfig#containerRuntime
   */
  readonly containerRuntime?: LaceworkAgentLaceworkConfigContainerRuntime;

  /**
   * @schema LaceworkAgentLaceworkConfig#datacollector
   */
  readonly datacollector?: LaceworkAgentLaceworkConfigDatacollector;

  /**
   * Kubernetes node's scrape interval in minutes
   *
   * @schema LaceworkAgentLaceworkConfig#k8sNodeScrapeIntervalMins
   */
  readonly k8SNodeScrapeIntervalMins?: number;

  /**
   * @schema LaceworkAgentLaceworkConfig#kubernetesCluster
   */
  readonly kubernetesCluster?: string;

  /**
   * Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
   *
   * @schema LaceworkAgentLaceworkConfig#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * @schema LaceworkAgentLaceworkConfig#metadataRequestInterval
   */
  readonly metadataRequestInterval?: string;

  /**
   * @schema LaceworkAgentLaceworkConfig#env
   */
  readonly env?: string;

  /**
   * @schema LaceworkAgentLaceworkConfig#fim
   */
  readonly fim?: LaceworkAgentLaceworkConfigFim;

  /**
   * @schema LaceworkAgentLaceworkConfig#packagescan
   */
  readonly packagescan?: LaceworkAgentLaceworkConfigPackagescan;

  /**
   * @schema LaceworkAgentLaceworkConfig#procscan
   */
  readonly procscan?: LaceworkAgentLaceworkConfigProcscan;

  /**
   * @schema LaceworkAgentLaceworkConfig#proxyUrl
   */
  readonly proxyUrl?: string;

  /**
   * @schema LaceworkAgentLaceworkConfig#serverUrl
   */
  readonly serverUrl?: string;

  /**
   * @schema LaceworkAgentLaceworkConfig#serviceAccountName
   */
  readonly serviceAccountName?: string;

  /**
   * @schema LaceworkAgentLaceworkConfig#stdoutLogging
   */
  readonly stdoutLogging?: boolean;

  /**
   * @schema LaceworkAgentLaceworkConfig#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * @schema LaceworkAgentLaceworkConfig#perfmode
   */
  readonly perfmode?: LaceworkAgentLaceworkConfigPerfmode;

  /**
   * Values that are not available in values.schema.json will not be code generated. You can add such values to this property.
   *
   * @schema LaceworkAgentLaceworkConfig#additionalValues
   */
  readonly additionalValues?: { [key: string]: any };

}

/**
 * ResourceRequirements describes the compute resource requirements.
 *
 * @schema io.k8s.api.core.v1.ResourceRequirements
 */
export interface IoK8SApiCoreV1ResourceRequirements {
  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema io.k8s.api.core.v1.ResourceRequirements#limits
   */
  readonly limits?: { [key: string]: any };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema io.k8s.api.core.v1.ResourceRequirements#requests
   */
  readonly requests?: { [key: string]: any };

}

/**
 * The pod this Toleration is attached to tolerates any taint that matches the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema io.k8s.api.core.v1.Toleration
 */
export interface IoK8SApiCoreV1Toleration {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * Possible enum values:
   * - \`\\"NoExecute\\"\` Evict any already-running pods that do not tolerate the taint. Currently enforced by NodeController.
   * - \`\\"NoSchedule\\"\` Do not allow new pods to schedule onto the node unless they tolerate the taint, but allow all pods submitted to Kubelet without going through the scheduler to start, and allow all already-running pods to continue running. Enforced by the scheduler.
   * - \`\\"PreferNoSchedule\\"\` Like TaintEffectNoSchedule, but the scheduler tries not to schedule new pods onto the node, rather than prohibiting new pods from scheduling onto the node entirely. Enforced by the scheduler.
   *
   * @schema io.k8s.api.core.v1.Toleration#effect
   */
  readonly effect?: IoK8SApiCoreV1TolerationEffect;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema io.k8s.api.core.v1.Toleration#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
   *
   * Possible enum values:
   * - \`\\"Equal\\"\`
   * - \`\\"Exists\\"\`
   *
   * @default Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
   * @schema io.k8s.api.core.v1.Toleration#operator
   */
  readonly operator?: IoK8SApiCoreV1TolerationOperator;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema io.k8s.api.core.v1.Toleration#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema io.k8s.api.core.v1.Toleration#value
   */
  readonly value?: string;

}

/**
 * Affinity is a group of affinity scheduling rules.
 *
 * @schema io.k8s.api.core.v1.Affinity
 */
export interface IoK8SApiCoreV1Affinity {
  /**
   * Node affinity is a group of node affinity scheduling rules.
   *
   * @schema io.k8s.api.core.v1.Affinity#nodeAffinity
   */
  readonly nodeAffinity?: IoK8SApiCoreV1AffinityNodeAffinity;

  /**
   * Pod affinity is a group of inter pod affinity scheduling rules.
   *
   * @schema io.k8s.api.core.v1.Affinity#podAffinity
   */
  readonly podAffinity?: IoK8SApiCoreV1AffinityPodAffinity;

  /**
   * Pod anti affinity is a group of inter pod anti affinity scheduling rules.
   *
   * @schema io.k8s.api.core.v1.Affinity#podAntiAffinity
   */
  readonly podAntiAffinity?: IoK8SApiCoreV1AffinityPodAntiAffinity;

}

/**
 * DaemonSetUpdateStrategy is a struct used to control the update strategy for a DaemonSet.
 *
 * @schema io.k8s.api.core.v1.DaemonSetUpdateStrategy
 */
export interface IoK8SApiCoreV1DaemonSetUpdateStrategy {
  /**
   * Spec to control the desired behavior of daemon set rolling update.
   *
   * @schema io.k8s.api.core.v1.DaemonSetUpdateStrategy#rollingUpdate
   */
  readonly rollingUpdate?: IoK8SApiCoreV1DaemonSetUpdateStrategyRollingUpdate;

  /**
   * Type of daemon set update. Can be \\"RollingUpdate\\" or \\"OnDelete\\". Default is RollingUpdate.
   *
   * Possible enum values:
   * - \`\\"OnDelete\\"\` Replace the old daemons only when it's killed
   * - \`\\"RollingUpdate\\"\` Replace the old daemons by new ones using rolling update i.e replace them on each node one after the other.
   *
   * @default RollingUpdate.
   * @schema io.k8s.api.core.v1.DaemonSetUpdateStrategy#type
   */
  readonly type?: IoK8SApiCoreV1DaemonSetUpdateStrategyType;

}

/**
 * @schema LaceworkAgentCloudserviceGke
 */
export interface LaceworkAgentCloudserviceGke {
  /**
   * @schema LaceworkAgentCloudserviceGke#autopilot
   */
  readonly autopilot?: boolean;

}

/**
 * LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
 *
 * @schema io.k8s.api.core.v1.LocalObjectReference
 */
export interface IoK8SApiCoreV1LocalObjectReference {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema io.k8s.api.core.v1.LocalObjectReference#name
   */
  readonly name?: string;

}

/**
 * Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
 *
 * Possible enum values:
 * - \`\\"Always\\"\` means that kubelet always attempts to pull the latest image. Container will fail If the pull fails.
 * - \`\\"IfNotPresent\\"\` means that kubelet pulls if the image isn't present on disk. Container will fail if the image isn't present and the pull fails.
 * - \`\\"Never\\"\` means that kubelet never pulls an image, but only uses a local image. Container will fail if the image isn't present
 *
 * @default Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
 * @schema LaceworkAgentImagePullPolicy
 */
export enum LaceworkAgentImagePullPolicy {
  /** Always */
  ALWAYS = \\"Always\\",
  /** IfNotPresent */
  IF_NOT_PRESENT = \\"IfNotPresent\\",
  /** Never */
  NEVER = \\"Never\\",
}

/**
 * @schema LaceworkAgentClusterAgentImage
 */
export interface LaceworkAgentClusterAgentImage {
  /**
   * ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec. If specified, these secrets will be passed to individual puller implementations for them to use. More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod
   *
   * @schema LaceworkAgentClusterAgentImage#imagePullSecrets
   */
  readonly imagePullSecrets?: IoK8SApiCoreV1LocalObjectReference[];

  /**
   * Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   *
   * Possible enum values:
   * - \`\\"Always\\"\` means that kubelet always attempts to pull the latest image. Container will fail If the pull fails.
   * - \`\\"IfNotPresent\\"\` means that kubelet pulls if the image isn't present on disk. Container will fail if the image isn't present and the pull fails.
   * - \`\\"Never\\"\` means that kubelet never pulls an image, but only uses a local image. Container will fail if the image isn't present
   *
   * @default Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   * @schema LaceworkAgentClusterAgentImage#pullPolicy
   */
  readonly pullPolicy: LaceworkAgentClusterAgentImagePullPolicy;

  /**
   * @schema LaceworkAgentClusterAgentImage#registry
   */
  readonly registry: string;

  /**
   * @schema LaceworkAgentClusterAgentImage#repository
   */
  readonly repository: string;

  /**
   * @schema LaceworkAgentClusterAgentImage#tag
   */
  readonly tag: string;

  /**
   * Values that are not available in values.schema.json will not be code generated. You can add such values to this property.
   *
   * @schema LaceworkAgentClusterAgentImage#additionalValues
   */
  readonly additionalValues?: { [key: string]: any };

}

/**
 * Kubernetes cluster type
 *
 * @schema LaceworkAgentClusterAgentClusterType
 */
export enum LaceworkAgentClusterAgentClusterType {
  /** eks */
  EKS = \\"eks\\",
  /** gke */
  GKE = \\"gke\\",
  /** unknown */
  UNKNOWN = \\"unknown\\",
}

/**
 * @schema LaceworkAgentLaceworkConfigAnonymizeIncoming
 */
export interface LaceworkAgentLaceworkConfigAnonymizeIncoming {
  /**
   * @schema LaceworkAgentLaceworkConfigAnonymizeIncoming#netmask
   */
  readonly netmask?: string;

  /**
   * Values that are not available in values.schema.json will not be code generated. You can add such values to this property.
   *
   * @schema LaceworkAgentLaceworkConfigAnonymizeIncoming#additionalValues
   */
  readonly additionalValues?: { [key: string]: any };

}

/**
 * @schema LaceworkAgentLaceworkConfigAutoUpgrade
 */
export enum LaceworkAgentLaceworkConfigAutoUpgrade {
  /** disable */
  DISABLE = \\"disable\\",
  /** enable */
  ENABLE = \\"enable\\",
}

/**
 * @schema LaceworkAgentLaceworkConfigCmdlinefilter
 */
export interface LaceworkAgentLaceworkConfigCmdlinefilter {
  /**
   * @schema LaceworkAgentLaceworkConfigCmdlinefilter#allow
   */
  readonly allow?: string;

  /**
   * @schema LaceworkAgentLaceworkConfigCmdlinefilter#disallow
   */
  readonly disallow?: string;

}

/**
 * @schema LaceworkAgentLaceworkConfigCodeaware
 */
export interface LaceworkAgentLaceworkConfigCodeaware {
  /**
   * @schema LaceworkAgentLaceworkConfigCodeaware#enable
   */
  readonly enable?: boolean;

}

/**
 * @schema LaceworkAgentLaceworkConfigContainerRuntime
 */
export enum LaceworkAgentLaceworkConfigContainerRuntime {
  /** containerd */
  CONTAINERD = \\"containerd\\",
  /** cri-o */
  CRI_HYPHEN_O = \\"cri-o\\",
  /** docker */
  DOCKER = \\"docker\\",
}

/**
 * @schema LaceworkAgentLaceworkConfigDatacollector
 */
export enum LaceworkAgentLaceworkConfigDatacollector {
  /** disable */
  DISABLE = \\"disable\\",
  /** enable */
  ENABLE = \\"enable\\",
}

/**
 * @schema LaceworkAgentLaceworkConfigFim
 */
export interface LaceworkAgentLaceworkConfigFim {
  /**
   * @schema LaceworkAgentLaceworkConfigFim#coolingPeriod
   */
  readonly coolingPeriod?: number;

  /**
   * @schema LaceworkAgentLaceworkConfigFim#crawlInterval
   */
  readonly crawlInterval?: number;

  /**
   * @schema LaceworkAgentLaceworkConfigFim#enable
   */
  readonly enable: boolean;

  /**
   * @schema LaceworkAgentLaceworkConfigFim#fileIgnore
   */
  readonly fileIgnore: string[];

  /**
   * @schema LaceworkAgentLaceworkConfigFim#filePath
   */
  readonly filePath: string[];

  /**
   * @schema LaceworkAgentLaceworkConfigFim#noAtime
   */
  readonly noAtime?: boolean;

  /**
   * @schema LaceworkAgentLaceworkConfigFim#runAt
   */
  readonly runAt?: any;

  /**
   * Values that are not available in values.schema.json will not be code generated. You can add such values to this property.
   *
   * @schema LaceworkAgentLaceworkConfigFim#additionalValues
   */
  readonly additionalValues?: { [key: string]: any };

}

/**
 * @schema LaceworkAgentLaceworkConfigPackagescan
 */
export interface LaceworkAgentLaceworkConfigPackagescan {
  /**
   * @schema LaceworkAgentLaceworkConfigPackagescan#enable
   */
  readonly enable?: boolean;

  /**
   * @schema LaceworkAgentLaceworkConfigPackagescan#interval
   */
  readonly interval?: number;

}

/**
 * @schema LaceworkAgentLaceworkConfigProcscan
 */
export interface LaceworkAgentLaceworkConfigProcscan {
  /**
   * @schema LaceworkAgentLaceworkConfigProcscan#enable
   */
  readonly enable?: boolean;

  /**
   * @schema LaceworkAgentLaceworkConfigProcscan#interval
   */
  readonly interval?: number;

}

/**
 * @schema LaceworkAgentLaceworkConfigPerfmode
 */
export enum LaceworkAgentLaceworkConfigPerfmode {
  /** lite */
  LITE = \\"lite\\",
  /** scan */
  SCAN = \\"scan\\",
  /** ebpflite */
  EBPFLITE = \\"ebpflite\\",
}

/**
 * Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
 *
 * Possible enum values:
 * - \`\\"NoExecute\\"\` Evict any already-running pods that do not tolerate the taint. Currently enforced by NodeController.
 * - \`\\"NoSchedule\\"\` Do not allow new pods to schedule onto the node unless they tolerate the taint, but allow all pods submitted to Kubelet without going through the scheduler to start, and allow all already-running pods to continue running. Enforced by the scheduler.
 * - \`\\"PreferNoSchedule\\"\` Like TaintEffectNoSchedule, but the scheduler tries not to schedule new pods onto the node, rather than prohibiting new pods from scheduling onto the node entirely. Enforced by the scheduler.
 *
 * @schema IoK8SApiCoreV1TolerationEffect
 */
export enum IoK8SApiCoreV1TolerationEffect {
  /** NoExecute */
  NO_EXECUTE = \\"NoExecute\\",
  /** NoSchedule */
  NO_SCHEDULE = \\"NoSchedule\\",
  /** PreferNoSchedule */
  PREFER_NO_SCHEDULE = \\"PreferNoSchedule\\",
}

/**
 * Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
 *
 * Possible enum values:
 * - \`\\"Equal\\"\`
 * - \`\\"Exists\\"\`
 *
 * @default Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
 * @schema IoK8SApiCoreV1TolerationOperator
 */
export enum IoK8SApiCoreV1TolerationOperator {
  /** Equal */
  EQUAL = \\"Equal\\",
  /** Exists */
  EXISTS = \\"Exists\\",
}

/**
 * Node affinity is a group of node affinity scheduling rules.
 *
 * @schema IoK8SApiCoreV1AffinityNodeAffinity
 */
export interface IoK8SApiCoreV1AffinityNodeAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding \\"weight\\" to the sum if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the most preferred.
   *
   * @schema IoK8SApiCoreV1AffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * A node selector represents the union of the results of one or more label queries over a set of nodes; that is, it represents the OR of the selectors represented by the node selector terms.
   *
   * @schema IoK8SApiCoreV1AffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;

}

/**
 * Pod affinity is a group of inter pod affinity scheduling rules.
 *
 * @schema IoK8SApiCoreV1AffinityPodAffinity
 */
export interface IoK8SApiCoreV1AffinityPodAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding \\"weight\\" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
   *
   * @schema IoK8SApiCoreV1AffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema IoK8SApiCoreV1AffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Pod anti affinity is a group of inter pod anti affinity scheduling rules.
 *
 * @schema IoK8SApiCoreV1AffinityPodAntiAffinity
 */
export interface IoK8SApiCoreV1AffinityPodAntiAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding \\"weight\\" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
   *
   * @schema IoK8SApiCoreV1AffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema IoK8SApiCoreV1AffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Spec to control the desired behavior of daemon set rolling update.
 *
 * @schema IoK8SApiCoreV1DaemonSetUpdateStrategyRollingUpdate
 */
export interface IoK8SApiCoreV1DaemonSetUpdateStrategyRollingUpdate {
  /**
   * @schema IoK8SApiCoreV1DaemonSetUpdateStrategyRollingUpdate#maxSurge
   */
  readonly maxSurge?: any;

  /**
   * @schema IoK8SApiCoreV1DaemonSetUpdateStrategyRollingUpdate#maxUnavailable
   */
  readonly maxUnavailable?: any;

}

/**
 * Type of daemon set update. Can be \\"RollingUpdate\\" or \\"OnDelete\\". Default is RollingUpdate.
 *
 * Possible enum values:
 * - \`\\"OnDelete\\"\` Replace the old daemons only when it's killed
 * - \`\\"RollingUpdate\\"\` Replace the old daemons by new ones using rolling update i.e replace them on each node one after the other.
 *
 * @default RollingUpdate.
 * @schema IoK8SApiCoreV1DaemonSetUpdateStrategyType
 */
export enum IoK8SApiCoreV1DaemonSetUpdateStrategyType {
  /** OnDelete */
  ON_DELETE = \\"OnDelete\\",
  /** RollingUpdate */
  ROLLING_UPDATE = \\"RollingUpdate\\",
}

/**
 * Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
 *
 * Possible enum values:
 * - \`\\"Always\\"\` means that kubelet always attempts to pull the latest image. Container will fail If the pull fails.
 * - \`\\"IfNotPresent\\"\` means that kubelet pulls if the image isn't present on disk. Container will fail if the image isn't present and the pull fails.
 * - \`\\"Never\\"\` means that kubelet never pulls an image, but only uses a local image. Container will fail if the image isn't present
 *
 * @default Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
 * @schema LaceworkAgentClusterAgentImagePullPolicy
 */
export enum LaceworkAgentClusterAgentImagePullPolicy {
  /** Always */
  ALWAYS = \\"Always\\",
  /** IfNotPresent */
  IF_NOT_PRESENT = \\"IfNotPresent\\",
  /** Never */
  NEVER = \\"Never\\",
}

/**
 * An empty preferred scheduling term matches all objects with implicit weight 0 (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
 *
 * @schema IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * A null or empty node selector term matches no objects. The requirements of them are ANDed. The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
   *
   * @schema IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference?: IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
   *
   * @schema IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * A node selector represents the union of the results of one or more label queries over a set of nodes; that is, it represents the OR of the selectors represented by the node selector terms.
 *
 * @schema IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A list of node selector terms. The terms are ORed.
   *
   * @schema IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms?: IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];

}

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running
   *
   * @schema IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
   *
   * @schema IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running
 *
 * @schema IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
   *
   * @schema IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
   *
   * @schema IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means \\"this pod's namespace\\".
   *
   * @schema IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
   *
   * @schema IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running
   *
   * @schema IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
   *
   * @schema IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running
 *
 * @schema IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
   *
   * @schema IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
   *
   * @schema IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means \\"this pod's namespace\\".
   *
   * @schema IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
   *
   * @schema IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * A null or empty node selector term matches no objects. The requirements of them are ANDed. The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
 *
 * @schema IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];

}

/**
 * A null or empty node selector term matches no objects. The requirements of them are ANDed. The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
 *
 * @schema IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];

}

/**
 * Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running
 *
 * @schema IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
   *
   * @schema IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
   *
   * @schema IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means \\"this pod's namespace\\".
   *
   * @schema IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
   *
   * @schema IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
 *
 * @schema IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \\"key\\", the operator is \\"In\\", and the values array contains only \\"value\\". The requirements are ANDed.
   *
   * @schema IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
 *
 * @schema IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \\"key\\", the operator is \\"In\\", and the values array contains only \\"value\\". The requirements are ANDed.
   *
   * @schema IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running
 *
 * @schema IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
   *
   * @schema IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
   *
   * @schema IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means \\"this pod's namespace\\".
   *
   * @schema IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
   *
   * @schema IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
 *
 * @schema IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \\"key\\", the operator is \\"In\\", and the values array contains only \\"value\\". The requirements are ANDed.
   *
   * @schema IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
 *
 * @schema IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \\"key\\", the operator is \\"In\\", and the values array contains only \\"value\\". The requirements are ANDed.
   *
   * @schema IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key?: string;

  /**
   * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * Possible enum values:
   * - \`\\"DoesNotExist\\"\`
   * - \`\\"Exists\\"\`
   * - \`\\"Gt\\"\`
   * - \`\\"In\\"\`
   * - \`\\"Lt\\"\`
   * - \`\\"NotIn\\"\`
   *
   * @schema IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator?: IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOperator;

  /**
   * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
   *
   * @schema IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key?: string;

  /**
   * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * Possible enum values:
   * - \`\\"DoesNotExist\\"\`
   * - \`\\"Exists\\"\`
   * - \`\\"Gt\\"\`
   * - \`\\"In\\"\`
   * - \`\\"Lt\\"\`
   * - \`\\"NotIn\\"\`
   *
   * @schema IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator?: IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOperator;

  /**
   * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
   *
   * @schema IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];

}

/**
 * A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key?: string;

  /**
   * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * Possible enum values:
   * - \`\\"DoesNotExist\\"\`
   * - \`\\"Exists\\"\`
   * - \`\\"Gt\\"\`
   * - \`\\"In\\"\`
   * - \`\\"Lt\\"\`
   * - \`\\"NotIn\\"\`
   *
   * @schema IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator?: IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOperator;

  /**
   * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
   *
   * @schema IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key?: string;

  /**
   * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * Possible enum values:
   * - \`\\"DoesNotExist\\"\`
   * - \`\\"Exists\\"\`
   * - \`\\"Gt\\"\`
   * - \`\\"In\\"\`
   * - \`\\"Lt\\"\`
   * - \`\\"NotIn\\"\`
   *
   * @schema IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator?: IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOperator;

  /**
   * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
   *
   * @schema IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];

}

/**
 * A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
 *
 * @schema IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \\"key\\", the operator is \\"In\\", and the values array contains only \\"value\\". The requirements are ANDed.
   *
   * @schema IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
 *
 * @schema IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \\"key\\", the operator is \\"In\\", and the values array contains only \\"value\\". The requirements are ANDed.
   *
   * @schema IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema IoK8SApiCoreV1AffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
 *
 * @schema IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \\"key\\", the operator is \\"In\\", and the values array contains only \\"value\\". The requirements are ANDed.
   *
   * @schema IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
 *
 * @schema IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \\"key\\", the operator is \\"In\\", and the values array contains only \\"value\\". The requirements are ANDed.
   *
   * @schema IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema IoK8SApiCoreV1AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
 *
 * Possible enum values:
 * - \`\\"DoesNotExist\\"\`
 * - \`\\"Exists\\"\`
 * - \`\\"Gt\\"\`
 * - \`\\"In\\"\`
 * - \`\\"Lt\\"\`
 * - \`\\"NotIn\\"\`
 *
 * @schema IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOperator
 */
export enum IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOperator {
  /** DoesNotExist */
  DOES_NOT_EXIST = \\"DoesNotExist\\",
  /** Exists */
  EXISTS = \\"Exists\\",
  /** Gt */
  GT = \\"Gt\\",
  /** In */
  IN = \\"In\\",
  /** Lt */
  LT = \\"Lt\\",
  /** NotIn */
  NOT_IN = \\"NotIn\\",
}

/**
 * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
 *
 * Possible enum values:
 * - \`\\"DoesNotExist\\"\`
 * - \`\\"Exists\\"\`
 * - \`\\"Gt\\"\`
 * - \`\\"In\\"\`
 * - \`\\"Lt\\"\`
 * - \`\\"NotIn\\"\`
 *
 * @schema IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOperator
 */
export enum IoK8SApiCoreV1AffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOperator {
  /** DoesNotExist */
  DOES_NOT_EXIST = \\"DoesNotExist\\",
  /** Exists */
  EXISTS = \\"Exists\\",
  /** Gt */
  GT = \\"Gt\\",
  /** In */
  IN = \\"In\\",
  /** Lt */
  LT = \\"Lt\\",
  /** NotIn */
  NOT_IN = \\"NotIn\\",
}

/**
 * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
 *
 * Possible enum values:
 * - \`\\"DoesNotExist\\"\`
 * - \`\\"Exists\\"\`
 * - \`\\"Gt\\"\`
 * - \`\\"In\\"\`
 * - \`\\"Lt\\"\`
 * - \`\\"NotIn\\"\`
 *
 * @schema IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOperator
 */
export enum IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOperator {
  /** DoesNotExist */
  DOES_NOT_EXIST = \\"DoesNotExist\\",
  /** Exists */
  EXISTS = \\"Exists\\",
  /** Gt */
  GT = \\"Gt\\",
  /** In */
  IN = \\"In\\",
  /** Lt */
  LT = \\"Lt\\",
  /** NotIn */
  NOT_IN = \\"NotIn\\",
}

/**
 * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
 *
 * Possible enum values:
 * - \`\\"DoesNotExist\\"\`
 * - \`\\"Exists\\"\`
 * - \`\\"Gt\\"\`
 * - \`\\"In\\"\`
 * - \`\\"Lt\\"\`
 * - \`\\"NotIn\\"\`
 *
 * @schema IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOperator
 */
export enum IoK8SApiCoreV1AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOperator {
  /** DoesNotExist */
  DOES_NOT_EXIST = \\"DoesNotExist\\",
  /** Exists */
  EXISTS = \\"Exists\\",
  /** Gt */
  GT = \\"Gt\\",
  /** In */
  IN = \\"In\\",
  /** Lt */
  LT = \\"Lt\\",
  /** NotIn */
  NOT_IN = \\"NotIn\\",
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema IoK8SApiCoreV1AffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema IoK8SApiCoreV1AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

",
}
`;

exports[`importing helm chart helm:oci://registry-1.docker.io/bitnamicharts/mysql@9.12.5 with python lanugage 1`] = `
Object {
  "author": Object {
    "name": "generated@generated.com",
    "roles": Array [
      "author",
    ],
  },
  "dependencies": "__omitted__",
  "dependencyClosure": Object {
    "cdk8s": Object {
      "targets": Object {
        "dotnet": Object {
          "namespace": "Org.Cdk8s",
          "packageId": "Org.Cdk8s",
        },
        "go": Object {
          "moduleName": "github.com/cdk8s-team/cdk8s-core-go",
        },
        "java": Object {
          "maven": Object {
            "artifactId": "cdk8s",
            "groupId": "org.cdk8s",
          },
          "package": "org.cdk8s",
        },
        "js": Object {
          "npm": "cdk8s",
        },
        "python": Object {
          "distName": "cdk8s",
          "module": "cdk8s",
        },
      },
    },
    "constructs": Object {
      "targets": Object {
        "dotnet": Object {
          "namespace": "Constructs",
          "packageId": "Constructs",
        },
        "go": Object {
          "moduleName": "github.com/aws/constructs-go",
        },
        "java": Object {
          "maven": Object {
            "artifactId": "constructs",
            "groupId": "software.constructs",
          },
          "package": "software.constructs",
        },
        "js": Object {
          "npm": "constructs",
        },
        "python": Object {
          "distName": "constructs",
          "module": "constructs",
        },
      },
    },
  },
  "description": "mysql",
  "fingerprint": "<fingerprint>",
  "homepage": "http://generated",
  "jsiiVersion": "__omitted__",
  "license": "UNLICENSED",
  "metadata": Object {
    "jsii": Object {
      "pacmak": Object {
        "hasDefaultInterfaces": true,
      },
    },
  },
  "name": "mysql",
  "repository": Object {
    "type": "git",
    "url": "http://generated",
  },
  "schema": "jsii/0.10.0",
  "targets": Object {
    "js": Object {
      "npm": "mysql",
    },
    "python": Object {
      "distName": "generated",
      "module": "mysql",
    },
  },
  "types": Object {
    "mysql.Mysql": Object {
      "assembly": "mysql",
      "base": "constructs.Construct",
      "fqn": "mysql.Mysql",
      "initializer": Object {
        "locationInModule": Object {
          "filename": "mysql.ts",
          "line": 14,
        },
        "parameters": Array [
          Object {
            "name": "scope",
            "type": Object {
              "fqn": "constructs.Construct",
            },
          },
          Object {
            "name": "id",
            "type": Object {
              "primitive": "string",
            },
          },
          Object {
            "name": "props",
            "optional": true,
            "type": Object {
              "fqn": "mysql.MysqlProps",
            },
          },
        ],
      },
      "kind": "class",
      "locationInModule": Object {
        "filename": "mysql.ts",
        "line": 13,
      },
      "name": "Mysql",
      "symbolId": "mysql:Mysql",
    },
    "mysql.MysqlArchitecture": Object {
      "assembly": "mysql",
      "docs": Object {
        "custom": Object {
          "schema": "MysqlArchitecture",
        },
        "summary": "Allowed values: \`standalone\` or \`replication\`.",
      },
      "fqn": "mysql.MysqlArchitecture",
      "kind": "enum",
      "locationInModule": Object {
        "filename": "mysql.ts",
        "line": 112,
      },
      "members": Array [
        Object {
          "docs": Object {
            "summary": "standalone.",
          },
          "name": "STANDALONE",
        },
        Object {
          "docs": Object {
            "summary": "replication.",
          },
          "name": "REPLICATION",
        },
      ],
      "name": "MysqlArchitecture",
      "symbolId": "mysql:MysqlArchitecture",
    },
    "mysql.MysqlAuth": Object {
      "assembly": "mysql",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "MysqlAuth",
        },
      },
      "fqn": "mysql.MysqlAuth",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "mysql.ts",
        "line": 122,
      },
      "name": "MysqlAuth",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlAuth#password",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 144,
          },
          "name": "password",
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlAuth#username",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 139,
          },
          "name": "username",
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlAuth#additionalValues",
            },
            "summary": "Values that are not available in values.schema.json will not be code generated. You can add such values to this property.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 166,
          },
          "name": "additionalValues",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "any",
              },
              "kind": "map",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlAuth#createDatabase",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 159,
          },
          "name": "createDatabase",
          "optional": true,
          "type": Object {
            "primitive": "boolean",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlAuth#database",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 134,
          },
          "name": "database",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlAuth#replicationPassword",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 154,
          },
          "name": "replicationPassword",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlAuth#replicationUser",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 149,
          },
          "name": "replicationUser",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlAuth#rootPassword",
            },
            "default": "a random 10-character alphanumeric string if not set",
            "summary": "Defaults to a random 10-character alphanumeric string if not set.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 129,
          },
          "name": "rootPassword",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
      ],
      "symbolId": "mysql:MysqlAuth",
    },
    "mysql.MysqlPrimary": Object {
      "assembly": "mysql",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "MysqlPrimary",
        },
      },
      "fqn": "mysql.MysqlPrimary",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "mysql.ts",
        "line": 173,
      },
      "name": "MysqlPrimary",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlPrimary#additionalValues",
            },
            "summary": "Values that are not available in values.schema.json will not be code generated. You can add such values to this property.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 194,
          },
          "name": "additionalValues",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "any",
              },
              "kind": "map",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlPrimary#containerSecurityContext",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 182,
          },
          "name": "containerSecurityContext",
          "optional": true,
          "type": Object {
            "fqn": "mysql.MysqlPrimaryContainerSecurityContext",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlPrimary#persistence",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 187,
          },
          "name": "persistence",
          "optional": true,
          "type": Object {
            "fqn": "mysql.MysqlPrimaryPersistence",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlPrimary#podSecurityContext",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 177,
          },
          "name": "podSecurityContext",
          "optional": true,
          "type": Object {
            "fqn": "mysql.MysqlPrimaryPodSecurityContext",
          },
        },
      ],
      "symbolId": "mysql:MysqlPrimary",
    },
    "mysql.MysqlPrimaryContainerSecurityContext": Object {
      "assembly": "mysql",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "MysqlPrimaryContainerSecurityContext",
        },
      },
      "fqn": "mysql.MysqlPrimaryContainerSecurityContext",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "mysql.ts",
        "line": 252,
      },
      "name": "MysqlPrimaryContainerSecurityContext",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlPrimaryContainerSecurityContext#additionalValues",
            },
            "summary": "Values that are not available in values.schema.json will not be code generated. You can add such values to this property.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 268,
          },
          "name": "additionalValues",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "any",
              },
              "kind": "map",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlPrimaryContainerSecurityContext#enabled",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 256,
          },
          "name": "enabled",
          "optional": true,
          "type": Object {
            "primitive": "boolean",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlPrimaryContainerSecurityContext#runAsUser",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 261,
          },
          "name": "runAsUser",
          "optional": true,
          "type": Object {
            "primitive": "number",
          },
        },
      ],
      "symbolId": "mysql:MysqlPrimaryContainerSecurityContext",
    },
    "mysql.MysqlPrimaryPersistence": Object {
      "assembly": "mysql",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "MysqlPrimaryPersistence",
        },
      },
      "fqn": "mysql.MysqlPrimaryPersistence",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "mysql.ts",
        "line": 275,
      },
      "name": "MysqlPrimaryPersistence",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlPrimaryPersistence#additionalValues",
            },
            "summary": "Values that are not available in values.schema.json will not be code generated. You can add such values to this property.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 291,
          },
          "name": "additionalValues",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "any",
              },
              "kind": "map",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlPrimaryPersistence#enabled",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 279,
          },
          "name": "enabled",
          "optional": true,
          "type": Object {
            "primitive": "boolean",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlPrimaryPersistence#size",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 284,
          },
          "name": "size",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
      ],
      "symbolId": "mysql:MysqlPrimaryPersistence",
    },
    "mysql.MysqlPrimaryPodSecurityContext": Object {
      "assembly": "mysql",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "MysqlPrimaryPodSecurityContext",
        },
      },
      "fqn": "mysql.MysqlPrimaryPodSecurityContext",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "mysql.ts",
        "line": 229,
      },
      "name": "MysqlPrimaryPodSecurityContext",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlPrimaryPodSecurityContext#additionalValues",
            },
            "summary": "Values that are not available in values.schema.json will not be code generated. You can add such values to this property.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 245,
          },
          "name": "additionalValues",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "any",
              },
              "kind": "map",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlPrimaryPodSecurityContext#enabled",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 233,
          },
          "name": "enabled",
          "optional": true,
          "type": Object {
            "primitive": "boolean",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlPrimaryPodSecurityContext#fsGroup",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 238,
          },
          "name": "fsGroup",
          "optional": true,
          "type": Object {
            "primitive": "number",
          },
        },
      ],
      "symbolId": "mysql:MysqlPrimaryPodSecurityContext",
    },
    "mysql.MysqlProps": Object {
      "assembly": "mysql",
      "datatype": true,
      "fqn": "mysql.MysqlProps",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "mysql.ts",
        "line": 5,
      },
      "name": "MysqlProps",
      "properties": Array [
        Object {
          "abstract": true,
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 8,
          },
          "name": "helmExecutable",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 9,
          },
          "name": "helmFlags",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "string",
              },
              "kind": "array",
            },
          },
        },
        Object {
          "abstract": true,
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 6,
          },
          "name": "namespace",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 7,
          },
          "name": "releaseName",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 10,
          },
          "name": "values",
          "optional": true,
          "type": Object {
            "fqn": "mysql.MysqlValues",
          },
        },
      ],
      "symbolId": "mysql:MysqlProps",
    },
    "mysql.MysqlSecondary": Object {
      "assembly": "mysql",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "MysqlSecondary",
        },
      },
      "fqn": "mysql.MysqlSecondary",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "mysql.ts",
        "line": 201,
      },
      "name": "MysqlSecondary",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlSecondary#additionalValues",
            },
            "summary": "Values that are not available in values.schema.json will not be code generated. You can add such values to this property.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 222,
          },
          "name": "additionalValues",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "any",
              },
              "kind": "map",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlSecondary#containerSecurityContext",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 210,
          },
          "name": "containerSecurityContext",
          "optional": true,
          "type": Object {
            "fqn": "mysql.MysqlSecondaryContainerSecurityContext",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlSecondary#persistence",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 215,
          },
          "name": "persistence",
          "optional": true,
          "type": Object {
            "fqn": "mysql.MysqlSecondaryPersistence",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlSecondary#podSecurityContext",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 205,
          },
          "name": "podSecurityContext",
          "optional": true,
          "type": Object {
            "fqn": "mysql.MysqlSecondaryPodSecurityContext",
          },
        },
      ],
      "symbolId": "mysql:MysqlSecondary",
    },
    "mysql.MysqlSecondaryContainerSecurityContext": Object {
      "assembly": "mysql",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "MysqlSecondaryContainerSecurityContext",
        },
      },
      "fqn": "mysql.MysqlSecondaryContainerSecurityContext",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "mysql.ts",
        "line": 321,
      },
      "name": "MysqlSecondaryContainerSecurityContext",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlSecondaryContainerSecurityContext#additionalValues",
            },
            "summary": "Values that are not available in values.schema.json will not be code generated. You can add such values to this property.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 337,
          },
          "name": "additionalValues",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "any",
              },
              "kind": "map",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlSecondaryContainerSecurityContext#enabled",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 325,
          },
          "name": "enabled",
          "optional": true,
          "type": Object {
            "primitive": "boolean",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlSecondaryContainerSecurityContext#runAsUser",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 330,
          },
          "name": "runAsUser",
          "optional": true,
          "type": Object {
            "primitive": "number",
          },
        },
      ],
      "symbolId": "mysql:MysqlSecondaryContainerSecurityContext",
    },
    "mysql.MysqlSecondaryPersistence": Object {
      "assembly": "mysql",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "MysqlSecondaryPersistence",
        },
      },
      "fqn": "mysql.MysqlSecondaryPersistence",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "mysql.ts",
        "line": 344,
      },
      "name": "MysqlSecondaryPersistence",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlSecondaryPersistence#additionalValues",
            },
            "summary": "Values that are not available in values.schema.json will not be code generated. You can add such values to this property.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 360,
          },
          "name": "additionalValues",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "any",
              },
              "kind": "map",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlSecondaryPersistence#enabled",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 348,
          },
          "name": "enabled",
          "optional": true,
          "type": Object {
            "primitive": "boolean",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlSecondaryPersistence#size",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 353,
          },
          "name": "size",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
      ],
      "symbolId": "mysql:MysqlSecondaryPersistence",
    },
    "mysql.MysqlSecondaryPodSecurityContext": Object {
      "assembly": "mysql",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "MysqlSecondaryPodSecurityContext",
        },
      },
      "fqn": "mysql.MysqlSecondaryPodSecurityContext",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "mysql.ts",
        "line": 298,
      },
      "name": "MysqlSecondaryPodSecurityContext",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlSecondaryPodSecurityContext#additionalValues",
            },
            "summary": "Values that are not available in values.schema.json will not be code generated. You can add such values to this property.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 314,
          },
          "name": "additionalValues",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "any",
              },
              "kind": "map",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlSecondaryPodSecurityContext#enabled",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 302,
          },
          "name": "enabled",
          "optional": true,
          "type": Object {
            "primitive": "boolean",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlSecondaryPodSecurityContext#fsGroup",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 307,
          },
          "name": "fsGroup",
          "optional": true,
          "type": Object {
            "primitive": "number",
          },
        },
      ],
      "symbolId": "mysql:MysqlSecondaryPodSecurityContext",
    },
    "mysql.MysqlValues": Object {
      "assembly": "mysql",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "mysql",
        },
      },
      "fqn": "mysql.MysqlValues",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "mysql.ts",
        "line": 65,
      },
      "name": "MysqlValues",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "mysql#additionalValues",
            },
            "summary": "Values that are not available in values.schema.json will not be code generated. You can add such values to this property.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 103,
          },
          "name": "additionalValues",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "any",
              },
              "kind": "map",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "mysql#architecture",
            },
            "summary": "Allowed values: \`standalone\` or \`replication\`.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 71,
          },
          "name": "architecture",
          "optional": true,
          "type": Object {
            "fqn": "mysql.MysqlArchitecture",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "mysql#auth",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 76,
          },
          "name": "auth",
          "optional": true,
          "type": Object {
            "fqn": "mysql.MysqlAuth",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "mysql#common",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 91,
          },
          "name": "common",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "any",
              },
              "kind": "map",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "mysql#global",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 96,
          },
          "name": "global",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "any",
              },
              "kind": "map",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "mysql#primary",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 81,
          },
          "name": "primary",
          "optional": true,
          "type": Object {
            "fqn": "mysql.MysqlPrimary",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "mysql#secondary",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 86,
          },
          "name": "secondary",
          "optional": true,
          "type": Object {
            "fqn": "mysql.MysqlSecondary",
          },
        },
      ],
      "symbolId": "mysql:MysqlValues",
    },
  },
  "version": "0.0.0",
}
`;

exports[`importing helm chart helm:oci://registry-1.docker.io/bitnamicharts/mysql@9.12.5 with python lanugage 2`] = `
Object {
  "mysql/__init__.py": "from pkgutil import extend_path
__path__ = extend_path(__path__, __name__)

import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

import typeguard
from importlib.metadata import version as _metadata_package_version
TYPEGUARD_MAJOR_VERSION = int(_metadata_package_version('typeguard').split('.')[0])

def check_type(argname: str, value: object, expected_type: typing.Any) -> typing.Any:
    if TYPEGUARD_MAJOR_VERSION <= 2:
        return typeguard.check_type(argname=argname, value=value, expected_type=expected_type) # type:ignore
    else:
        if isinstance(value, jsii._reference_map.InterfaceDynamicProxy): # pyright: ignore [reportAttributeAccessIssue]
           pass
        else:
            if TYPEGUARD_MAJOR_VERSION == 3:
                typeguard.config.collection_check_strategy = typeguard.CollectionCheckStrategy.ALL_ITEMS # type:ignore
                typeguard.check_type(value=value, expected_type=expected_type) # type:ignore
            else:
                typeguard.check_type(value=value, expected_type=expected_type, collection_check_strategy=typeguard.CollectionCheckStrategy.ALL_ITEMS) # type:ignore

from ._jsii import *

import constructs as _constructs_77d1e7e8


class Mysql(
    _constructs_77d1e7e8.Construct,
    metaclass=jsii.JSIIMeta,
    jsii_type=\\"mysql.Mysql\\",
):
    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        helm_executable: typing.Optional[builtins.str] = None,
        helm_flags: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace: typing.Optional[builtins.str] = None,
        release_name: typing.Optional[builtins.str] = None,
        values: typing.Optional[typing.Union[\\"MysqlValues\\", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param helm_executable: -
        :param helm_flags: -
        :param namespace: -
        :param release_name: -
        :param values: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__95a811b01af67eee2d8e2ae24fcefa9fa2ac995a1f9685f3e921af5330ef82ff)
            check_type(argname=\\"argument scope\\", value=scope, expected_type=type_hints[\\"scope\\"])
            check_type(argname=\\"argument id\\", value=id, expected_type=type_hints[\\"id\\"])
        props = MysqlProps(
            helm_executable=helm_executable,
            helm_flags=helm_flags,
            namespace=namespace,
            release_name=release_name,
            values=values,
        )

        jsii.create(self.__class__, self, [scope, id, props])


@jsii.enum(jsii_type=\\"mysql.MysqlArchitecture\\")
class MysqlArchitecture(enum.Enum):
    '''Allowed values: \`\`standalone\`\` or \`\`replication\`\`.

    :schema: MysqlArchitecture
    '''

    STANDALONE = \\"STANDALONE\\"
    '''standalone.'''
    REPLICATION = \\"REPLICATION\\"
    '''replication.'''


@jsii.data_type(
    jsii_type=\\"mysql.MysqlAuth\\",
    jsii_struct_bases=[],
    name_mapping={
        \\"password\\": \\"password\\",
        \\"username\\": \\"username\\",
        \\"additional_values\\": \\"additionalValues\\",
        \\"create_database\\": \\"createDatabase\\",
        \\"database\\": \\"database\\",
        \\"replication_password\\": \\"replicationPassword\\",
        \\"replication_user\\": \\"replicationUser\\",
        \\"root_password\\": \\"rootPassword\\",
    },
)
class MysqlAuth:
    def __init__(
        self,
        *,
        password: builtins.str,
        username: builtins.str,
        additional_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        create_database: typing.Optional[builtins.bool] = None,
        database: typing.Optional[builtins.str] = None,
        replication_password: typing.Optional[builtins.str] = None,
        replication_user: typing.Optional[builtins.str] = None,
        root_password: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param password: 
        :param username: 
        :param additional_values: Values that are not available in values.schema.json will not be code generated. You can add such values to this property.
        :param create_database: 
        :param database: 
        :param replication_password: 
        :param replication_user: 
        :param root_password: Defaults to a random 10-character alphanumeric string if not set. Default: a random 10-character alphanumeric string if not set

        :schema: MysqlAuth
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ee06bc5fa81868398bad26c41946af017c8765bcca5abe66e5d88d360a20e315)
            check_type(argname=\\"argument password\\", value=password, expected_type=type_hints[\\"password\\"])
            check_type(argname=\\"argument username\\", value=username, expected_type=type_hints[\\"username\\"])
            check_type(argname=\\"argument additional_values\\", value=additional_values, expected_type=type_hints[\\"additional_values\\"])
            check_type(argname=\\"argument create_database\\", value=create_database, expected_type=type_hints[\\"create_database\\"])
            check_type(argname=\\"argument database\\", value=database, expected_type=type_hints[\\"database\\"])
            check_type(argname=\\"argument replication_password\\", value=replication_password, expected_type=type_hints[\\"replication_password\\"])
            check_type(argname=\\"argument replication_user\\", value=replication_user, expected_type=type_hints[\\"replication_user\\"])
            check_type(argname=\\"argument root_password\\", value=root_password, expected_type=type_hints[\\"root_password\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            \\"password\\": password,
            \\"username\\": username,
        }
        if additional_values is not None:
            self._values[\\"additional_values\\"] = additional_values
        if create_database is not None:
            self._values[\\"create_database\\"] = create_database
        if database is not None:
            self._values[\\"database\\"] = database
        if replication_password is not None:
            self._values[\\"replication_password\\"] = replication_password
        if replication_user is not None:
            self._values[\\"replication_user\\"] = replication_user
        if root_password is not None:
            self._values[\\"root_password\\"] = root_password

    @builtins.property
    def password(self) -> builtins.str:
        '''
        :schema: MysqlAuth#password
        '''
        result = self._values.get(\\"password\\")
        assert result is not None, \\"Required property 'password' is missing\\"
        return typing.cast(builtins.str, result)

    @builtins.property
    def username(self) -> builtins.str:
        '''
        :schema: MysqlAuth#username
        '''
        result = self._values.get(\\"username\\")
        assert result is not None, \\"Required property 'username' is missing\\"
        return typing.cast(builtins.str, result)

    @builtins.property
    def additional_values(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''Values that are not available in values.schema.json will not be code generated. You can add such values to this property.

        :schema: MysqlAuth#additionalValues
        '''
        result = self._values.get(\\"additional_values\\")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def create_database(self) -> typing.Optional[builtins.bool]:
        '''
        :schema: MysqlAuth#createDatabase
        '''
        result = self._values.get(\\"create_database\\")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def database(self) -> typing.Optional[builtins.str]:
        '''
        :schema: MysqlAuth#database
        '''
        result = self._values.get(\\"database\\")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def replication_password(self) -> typing.Optional[builtins.str]:
        '''
        :schema: MysqlAuth#replicationPassword
        '''
        result = self._values.get(\\"replication_password\\")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def replication_user(self) -> typing.Optional[builtins.str]:
        '''
        :schema: MysqlAuth#replicationUser
        '''
        result = self._values.get(\\"replication_user\\")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def root_password(self) -> typing.Optional[builtins.str]:
        '''Defaults to a random 10-character alphanumeric string if not set.

        :default: a random 10-character alphanumeric string if not set

        :schema: MysqlAuth#rootPassword
        '''
        result = self._values.get(\\"root_password\\")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"MysqlAuth(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type=\\"mysql.MysqlPrimary\\",
    jsii_struct_bases=[],
    name_mapping={
        \\"additional_values\\": \\"additionalValues\\",
        \\"container_security_context\\": \\"containerSecurityContext\\",
        \\"persistence\\": \\"persistence\\",
        \\"pod_security_context\\": \\"podSecurityContext\\",
    },
)
class MysqlPrimary:
    def __init__(
        self,
        *,
        additional_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        container_security_context: typing.Optional[typing.Union[\\"MysqlPrimaryContainerSecurityContext\\", typing.Dict[builtins.str, typing.Any]]] = None,
        persistence: typing.Optional[typing.Union[\\"MysqlPrimaryPersistence\\", typing.Dict[builtins.str, typing.Any]]] = None,
        pod_security_context: typing.Optional[typing.Union[\\"MysqlPrimaryPodSecurityContext\\", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param additional_values: Values that are not available in values.schema.json will not be code generated. You can add such values to this property.
        :param container_security_context: 
        :param persistence: 
        :param pod_security_context: 

        :schema: MysqlPrimary
        '''
        if isinstance(container_security_context, dict):
            container_security_context = MysqlPrimaryContainerSecurityContext(**container_security_context)
        if isinstance(persistence, dict):
            persistence = MysqlPrimaryPersistence(**persistence)
        if isinstance(pod_security_context, dict):
            pod_security_context = MysqlPrimaryPodSecurityContext(**pod_security_context)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5f80f16db85307f6e2dc2fd18749079a45e96857945ee617d44938b1e1fa49dd)
            check_type(argname=\\"argument additional_values\\", value=additional_values, expected_type=type_hints[\\"additional_values\\"])
            check_type(argname=\\"argument container_security_context\\", value=container_security_context, expected_type=type_hints[\\"container_security_context\\"])
            check_type(argname=\\"argument persistence\\", value=persistence, expected_type=type_hints[\\"persistence\\"])
            check_type(argname=\\"argument pod_security_context\\", value=pod_security_context, expected_type=type_hints[\\"pod_security_context\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if additional_values is not None:
            self._values[\\"additional_values\\"] = additional_values
        if container_security_context is not None:
            self._values[\\"container_security_context\\"] = container_security_context
        if persistence is not None:
            self._values[\\"persistence\\"] = persistence
        if pod_security_context is not None:
            self._values[\\"pod_security_context\\"] = pod_security_context

    @builtins.property
    def additional_values(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''Values that are not available in values.schema.json will not be code generated. You can add such values to this property.

        :schema: MysqlPrimary#additionalValues
        '''
        result = self._values.get(\\"additional_values\\")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def container_security_context(
        self,
    ) -> typing.Optional[\\"MysqlPrimaryContainerSecurityContext\\"]:
        '''
        :schema: MysqlPrimary#containerSecurityContext
        '''
        result = self._values.get(\\"container_security_context\\")
        return typing.cast(typing.Optional[\\"MysqlPrimaryContainerSecurityContext\\"], result)

    @builtins.property
    def persistence(self) -> typing.Optional[\\"MysqlPrimaryPersistence\\"]:
        '''
        :schema: MysqlPrimary#persistence
        '''
        result = self._values.get(\\"persistence\\")
        return typing.cast(typing.Optional[\\"MysqlPrimaryPersistence\\"], result)

    @builtins.property
    def pod_security_context(self) -> typing.Optional[\\"MysqlPrimaryPodSecurityContext\\"]:
        '''
        :schema: MysqlPrimary#podSecurityContext
        '''
        result = self._values.get(\\"pod_security_context\\")
        return typing.cast(typing.Optional[\\"MysqlPrimaryPodSecurityContext\\"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"MysqlPrimary(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type=\\"mysql.MysqlPrimaryContainerSecurityContext\\",
    jsii_struct_bases=[],
    name_mapping={
        \\"additional_values\\": \\"additionalValues\\",
        \\"enabled\\": \\"enabled\\",
        \\"run_as_user\\": \\"runAsUser\\",
    },
)
class MysqlPrimaryContainerSecurityContext:
    def __init__(
        self,
        *,
        additional_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        enabled: typing.Optional[builtins.bool] = None,
        run_as_user: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param additional_values: Values that are not available in values.schema.json will not be code generated. You can add such values to this property.
        :param enabled: 
        :param run_as_user: 

        :schema: MysqlPrimaryContainerSecurityContext
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b6c44d7f91b4cf3cb542cb1506165f060a9a15243f09931b735b74af15eaf7ae)
            check_type(argname=\\"argument additional_values\\", value=additional_values, expected_type=type_hints[\\"additional_values\\"])
            check_type(argname=\\"argument enabled\\", value=enabled, expected_type=type_hints[\\"enabled\\"])
            check_type(argname=\\"argument run_as_user\\", value=run_as_user, expected_type=type_hints[\\"run_as_user\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if additional_values is not None:
            self._values[\\"additional_values\\"] = additional_values
        if enabled is not None:
            self._values[\\"enabled\\"] = enabled
        if run_as_user is not None:
            self._values[\\"run_as_user\\"] = run_as_user

    @builtins.property
    def additional_values(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''Values that are not available in values.schema.json will not be code generated. You can add such values to this property.

        :schema: MysqlPrimaryContainerSecurityContext#additionalValues
        '''
        result = self._values.get(\\"additional_values\\")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def enabled(self) -> typing.Optional[builtins.bool]:
        '''
        :schema: MysqlPrimaryContainerSecurityContext#enabled
        '''
        result = self._values.get(\\"enabled\\")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def run_as_user(self) -> typing.Optional[jsii.Number]:
        '''
        :schema: MysqlPrimaryContainerSecurityContext#runAsUser
        '''
        result = self._values.get(\\"run_as_user\\")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"MysqlPrimaryContainerSecurityContext(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type=\\"mysql.MysqlPrimaryPersistence\\",
    jsii_struct_bases=[],
    name_mapping={
        \\"additional_values\\": \\"additionalValues\\",
        \\"enabled\\": \\"enabled\\",
        \\"size\\": \\"size\\",
    },
)
class MysqlPrimaryPersistence:
    def __init__(
        self,
        *,
        additional_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        enabled: typing.Optional[builtins.bool] = None,
        size: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param additional_values: Values that are not available in values.schema.json will not be code generated. You can add such values to this property.
        :param enabled: 
        :param size: 

        :schema: MysqlPrimaryPersistence
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__da573ccf5d6dca82a8d1cb770a6c85bd0dd98f4b5fe00a7260e815a7140dc9ba)
            check_type(argname=\\"argument additional_values\\", value=additional_values, expected_type=type_hints[\\"additional_values\\"])
            check_type(argname=\\"argument enabled\\", value=enabled, expected_type=type_hints[\\"enabled\\"])
            check_type(argname=\\"argument size\\", value=size, expected_type=type_hints[\\"size\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if additional_values is not None:
            self._values[\\"additional_values\\"] = additional_values
        if enabled is not None:
            self._values[\\"enabled\\"] = enabled
        if size is not None:
            self._values[\\"size\\"] = size

    @builtins.property
    def additional_values(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''Values that are not available in values.schema.json will not be code generated. You can add such values to this property.

        :schema: MysqlPrimaryPersistence#additionalValues
        '''
        result = self._values.get(\\"additional_values\\")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def enabled(self) -> typing.Optional[builtins.bool]:
        '''
        :schema: MysqlPrimaryPersistence#enabled
        '''
        result = self._values.get(\\"enabled\\")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def size(self) -> typing.Optional[builtins.str]:
        '''
        :schema: MysqlPrimaryPersistence#size
        '''
        result = self._values.get(\\"size\\")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"MysqlPrimaryPersistence(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type=\\"mysql.MysqlPrimaryPodSecurityContext\\",
    jsii_struct_bases=[],
    name_mapping={
        \\"additional_values\\": \\"additionalValues\\",
        \\"enabled\\": \\"enabled\\",
        \\"fs_group\\": \\"fsGroup\\",
    },
)
class MysqlPrimaryPodSecurityContext:
    def __init__(
        self,
        *,
        additional_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        enabled: typing.Optional[builtins.bool] = None,
        fs_group: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param additional_values: Values that are not available in values.schema.json will not be code generated. You can add such values to this property.
        :param enabled: 
        :param fs_group: 

        :schema: MysqlPrimaryPodSecurityContext
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f093d2c1e555d5d67dfb226a625b4abd2741a6b3333a3f12627a45d66a375c7c)
            check_type(argname=\\"argument additional_values\\", value=additional_values, expected_type=type_hints[\\"additional_values\\"])
            check_type(argname=\\"argument enabled\\", value=enabled, expected_type=type_hints[\\"enabled\\"])
            check_type(argname=\\"argument fs_group\\", value=fs_group, expected_type=type_hints[\\"fs_group\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if additional_values is not None:
            self._values[\\"additional_values\\"] = additional_values
        if enabled is not None:
            self._values[\\"enabled\\"] = enabled
        if fs_group is not None:
            self._values[\\"fs_group\\"] = fs_group

    @builtins.property
    def additional_values(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''Values that are not available in values.schema.json will not be code generated. You can add such values to this property.

        :schema: MysqlPrimaryPodSecurityContext#additionalValues
        '''
        result = self._values.get(\\"additional_values\\")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def enabled(self) -> typing.Optional[builtins.bool]:
        '''
        :schema: MysqlPrimaryPodSecurityContext#enabled
        '''
        result = self._values.get(\\"enabled\\")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def fs_group(self) -> typing.Optional[jsii.Number]:
        '''
        :schema: MysqlPrimaryPodSecurityContext#fsGroup
        '''
        result = self._values.get(\\"fs_group\\")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"MysqlPrimaryPodSecurityContext(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type=\\"mysql.MysqlProps\\",
    jsii_struct_bases=[],
    name_mapping={
        \\"helm_executable\\": \\"helmExecutable\\",
        \\"helm_flags\\": \\"helmFlags\\",
        \\"namespace\\": \\"namespace\\",
        \\"release_name\\": \\"releaseName\\",
        \\"values\\": \\"values\\",
    },
)
class MysqlProps:
    def __init__(
        self,
        *,
        helm_executable: typing.Optional[builtins.str] = None,
        helm_flags: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace: typing.Optional[builtins.str] = None,
        release_name: typing.Optional[builtins.str] = None,
        values: typing.Optional[typing.Union[\\"MysqlValues\\", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param helm_executable: -
        :param helm_flags: -
        :param namespace: -
        :param release_name: -
        :param values: -
        '''
        if isinstance(values, dict):
            values = MysqlValues(**values)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e0f01c3bcbff3f33dcd5e42ea1dca1754a4ffa560d4ed4393b91bf8167da3e71)
            check_type(argname=\\"argument helm_executable\\", value=helm_executable, expected_type=type_hints[\\"helm_executable\\"])
            check_type(argname=\\"argument helm_flags\\", value=helm_flags, expected_type=type_hints[\\"helm_flags\\"])
            check_type(argname=\\"argument namespace\\", value=namespace, expected_type=type_hints[\\"namespace\\"])
            check_type(argname=\\"argument release_name\\", value=release_name, expected_type=type_hints[\\"release_name\\"])
            check_type(argname=\\"argument values\\", value=values, expected_type=type_hints[\\"values\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if helm_executable is not None:
            self._values[\\"helm_executable\\"] = helm_executable
        if helm_flags is not None:
            self._values[\\"helm_flags\\"] = helm_flags
        if namespace is not None:
            self._values[\\"namespace\\"] = namespace
        if release_name is not None:
            self._values[\\"release_name\\"] = release_name
        if values is not None:
            self._values[\\"values\\"] = values

    @builtins.property
    def helm_executable(self) -> typing.Optional[builtins.str]:
        result = self._values.get(\\"helm_executable\\")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def helm_flags(self) -> typing.Optional[typing.List[builtins.str]]:
        result = self._values.get(\\"helm_flags\\")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        result = self._values.get(\\"namespace\\")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def release_name(self) -> typing.Optional[builtins.str]:
        result = self._values.get(\\"release_name\\")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def values(self) -> typing.Optional[\\"MysqlValues\\"]:
        result = self._values.get(\\"values\\")
        return typing.cast(typing.Optional[\\"MysqlValues\\"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"MysqlProps(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type=\\"mysql.MysqlSecondary\\",
    jsii_struct_bases=[],
    name_mapping={
        \\"additional_values\\": \\"additionalValues\\",
        \\"container_security_context\\": \\"containerSecurityContext\\",
        \\"persistence\\": \\"persistence\\",
        \\"pod_security_context\\": \\"podSecurityContext\\",
    },
)
class MysqlSecondary:
    def __init__(
        self,
        *,
        additional_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        container_security_context: typing.Optional[typing.Union[\\"MysqlSecondaryContainerSecurityContext\\", typing.Dict[builtins.str, typing.Any]]] = None,
        persistence: typing.Optional[typing.Union[\\"MysqlSecondaryPersistence\\", typing.Dict[builtins.str, typing.Any]]] = None,
        pod_security_context: typing.Optional[typing.Union[\\"MysqlSecondaryPodSecurityContext\\", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param additional_values: Values that are not available in values.schema.json will not be code generated. You can add such values to this property.
        :param container_security_context: 
        :param persistence: 
        :param pod_security_context: 

        :schema: MysqlSecondary
        '''
        if isinstance(container_security_context, dict):
            container_security_context = MysqlSecondaryContainerSecurityContext(**container_security_context)
        if isinstance(persistence, dict):
            persistence = MysqlSecondaryPersistence(**persistence)
        if isinstance(pod_security_context, dict):
            pod_security_context = MysqlSecondaryPodSecurityContext(**pod_security_context)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9f5e9436f8b23b1168f49948e6f47f206871fa357437067fe13eb80a1e4844f2)
            check_type(argname=\\"argument additional_values\\", value=additional_values, expected_type=type_hints[\\"additional_values\\"])
            check_type(argname=\\"argument container_security_context\\", value=container_security_context, expected_type=type_hints[\\"container_security_context\\"])
            check_type(argname=\\"argument persistence\\", value=persistence, expected_type=type_hints[\\"persistence\\"])
            check_type(argname=\\"argument pod_security_context\\", value=pod_security_context, expected_type=type_hints[\\"pod_security_context\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if additional_values is not None:
            self._values[\\"additional_values\\"] = additional_values
        if container_security_context is not None:
            self._values[\\"container_security_context\\"] = container_security_context
        if persistence is not None:
            self._values[\\"persistence\\"] = persistence
        if pod_security_context is not None:
            self._values[\\"pod_security_context\\"] = pod_security_context

    @builtins.property
    def additional_values(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''Values that are not available in values.schema.json will not be code generated. You can add such values to this property.

        :schema: MysqlSecondary#additionalValues
        '''
        result = self._values.get(\\"additional_values\\")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def container_security_context(
        self,
    ) -> typing.Optional[\\"MysqlSecondaryContainerSecurityContext\\"]:
        '''
        :schema: MysqlSecondary#containerSecurityContext
        '''
        result = self._values.get(\\"container_security_context\\")
        return typing.cast(typing.Optional[\\"MysqlSecondaryContainerSecurityContext\\"], result)

    @builtins.property
    def persistence(self) -> typing.Optional[\\"MysqlSecondaryPersistence\\"]:
        '''
        :schema: MysqlSecondary#persistence
        '''
        result = self._values.get(\\"persistence\\")
        return typing.cast(typing.Optional[\\"MysqlSecondaryPersistence\\"], result)

    @builtins.property
    def pod_security_context(
        self,
    ) -> typing.Optional[\\"MysqlSecondaryPodSecurityContext\\"]:
        '''
        :schema: MysqlSecondary#podSecurityContext
        '''
        result = self._values.get(\\"pod_security_context\\")
        return typing.cast(typing.Optional[\\"MysqlSecondaryPodSecurityContext\\"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"MysqlSecondary(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type=\\"mysql.MysqlSecondaryContainerSecurityContext\\",
    jsii_struct_bases=[],
    name_mapping={
        \\"additional_values\\": \\"additionalValues\\",
        \\"enabled\\": \\"enabled\\",
        \\"run_as_user\\": \\"runAsUser\\",
    },
)
class MysqlSecondaryContainerSecurityContext:
    def __init__(
        self,
        *,
        additional_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        enabled: typing.Optional[builtins.bool] = None,
        run_as_user: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param additional_values: Values that are not available in values.schema.json will not be code generated. You can add such values to this property.
        :param enabled: 
        :param run_as_user: 

        :schema: MysqlSecondaryContainerSecurityContext
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1ae0b9a8b2ed30dd59da81691df3e07509c48d79c4bae3cf246ab40221c987b1)
            check_type(argname=\\"argument additional_values\\", value=additional_values, expected_type=type_hints[\\"additional_values\\"])
            check_type(argname=\\"argument enabled\\", value=enabled, expected_type=type_hints[\\"enabled\\"])
            check_type(argname=\\"argument run_as_user\\", value=run_as_user, expected_type=type_hints[\\"run_as_user\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if additional_values is not None:
            self._values[\\"additional_values\\"] = additional_values
        if enabled is not None:
            self._values[\\"enabled\\"] = enabled
        if run_as_user is not None:
            self._values[\\"run_as_user\\"] = run_as_user

    @builtins.property
    def additional_values(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''Values that are not available in values.schema.json will not be code generated. You can add such values to this property.

        :schema: MysqlSecondaryContainerSecurityContext#additionalValues
        '''
        result = self._values.get(\\"additional_values\\")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def enabled(self) -> typing.Optional[builtins.bool]:
        '''
        :schema: MysqlSecondaryContainerSecurityContext#enabled
        '''
        result = self._values.get(\\"enabled\\")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def run_as_user(self) -> typing.Optional[jsii.Number]:
        '''
        :schema: MysqlSecondaryContainerSecurityContext#runAsUser
        '''
        result = self._values.get(\\"run_as_user\\")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"MysqlSecondaryContainerSecurityContext(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type=\\"mysql.MysqlSecondaryPersistence\\",
    jsii_struct_bases=[],
    name_mapping={
        \\"additional_values\\": \\"additionalValues\\",
        \\"enabled\\": \\"enabled\\",
        \\"size\\": \\"size\\",
    },
)
class MysqlSecondaryPersistence:
    def __init__(
        self,
        *,
        additional_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        enabled: typing.Optional[builtins.bool] = None,
        size: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param additional_values: Values that are not available in values.schema.json will not be code generated. You can add such values to this property.
        :param enabled: 
        :param size: 

        :schema: MysqlSecondaryPersistence
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__948c5c8f94b41fa54e53ae6a34ae87281865e016dcca8ad5308b1666738cbd56)
            check_type(argname=\\"argument additional_values\\", value=additional_values, expected_type=type_hints[\\"additional_values\\"])
            check_type(argname=\\"argument enabled\\", value=enabled, expected_type=type_hints[\\"enabled\\"])
            check_type(argname=\\"argument size\\", value=size, expected_type=type_hints[\\"size\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if additional_values is not None:
            self._values[\\"additional_values\\"] = additional_values
        if enabled is not None:
            self._values[\\"enabled\\"] = enabled
        if size is not None:
            self._values[\\"size\\"] = size

    @builtins.property
    def additional_values(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''Values that are not available in values.schema.json will not be code generated. You can add such values to this property.

        :schema: MysqlSecondaryPersistence#additionalValues
        '''
        result = self._values.get(\\"additional_values\\")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def enabled(self) -> typing.Optional[builtins.bool]:
        '''
        :schema: MysqlSecondaryPersistence#enabled
        '''
        result = self._values.get(\\"enabled\\")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def size(self) -> typing.Optional[builtins.str]:
        '''
        :schema: MysqlSecondaryPersistence#size
        '''
        result = self._values.get(\\"size\\")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"MysqlSecondaryPersistence(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type=\\"mysql.MysqlSecondaryPodSecurityContext\\",
    jsii_struct_bases=[],
    name_mapping={
        \\"additional_values\\": \\"additionalValues\\",
        \\"enabled\\": \\"enabled\\",
        \\"fs_group\\": \\"fsGroup\\",
    },
)
class MysqlSecondaryPodSecurityContext:
    def __init__(
        self,
        *,
        additional_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        enabled: typing.Optional[builtins.bool] = None,
        fs_group: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param additional_values: Values that are not available in values.schema.json will not be code generated. You can add such values to this property.
        :param enabled: 
        :param fs_group: 

        :schema: MysqlSecondaryPodSecurityContext
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c3d21a01f61c5c4594bfd80de49afce454aa452afa8cc380cf0792cf29872ce7)
            check_type(argname=\\"argument additional_values\\", value=additional_values, expected_type=type_hints[\\"additional_values\\"])
            check_type(argname=\\"argument enabled\\", value=enabled, expected_type=type_hints[\\"enabled\\"])
            check_type(argname=\\"argument fs_group\\", value=fs_group, expected_type=type_hints[\\"fs_group\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if additional_values is not None:
            self._values[\\"additional_values\\"] = additional_values
        if enabled is not None:
            self._values[\\"enabled\\"] = enabled
        if fs_group is not None:
            self._values[\\"fs_group\\"] = fs_group

    @builtins.property
    def additional_values(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''Values that are not available in values.schema.json will not be code generated. You can add such values to this property.

        :schema: MysqlSecondaryPodSecurityContext#additionalValues
        '''
        result = self._values.get(\\"additional_values\\")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def enabled(self) -> typing.Optional[builtins.bool]:
        '''
        :schema: MysqlSecondaryPodSecurityContext#enabled
        '''
        result = self._values.get(\\"enabled\\")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def fs_group(self) -> typing.Optional[jsii.Number]:
        '''
        :schema: MysqlSecondaryPodSecurityContext#fsGroup
        '''
        result = self._values.get(\\"fs_group\\")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"MysqlSecondaryPodSecurityContext(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type=\\"mysql.MysqlValues\\",
    jsii_struct_bases=[],
    name_mapping={
        \\"additional_values\\": \\"additionalValues\\",
        \\"architecture\\": \\"architecture\\",
        \\"auth\\": \\"auth\\",
        \\"common\\": \\"common\\",
        \\"global_\\": \\"global\\",
        \\"primary\\": \\"primary\\",
        \\"secondary\\": \\"secondary\\",
    },
)
class MysqlValues:
    def __init__(
        self,
        *,
        additional_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        architecture: typing.Optional[MysqlArchitecture] = None,
        auth: typing.Optional[typing.Union[MysqlAuth, typing.Dict[builtins.str, typing.Any]]] = None,
        common: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        global_: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        primary: typing.Optional[typing.Union[MysqlPrimary, typing.Dict[builtins.str, typing.Any]]] = None,
        secondary: typing.Optional[typing.Union[MysqlSecondary, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param additional_values: Values that are not available in values.schema.json will not be code generated. You can add such values to this property.
        :param architecture: Allowed values: \`\`standalone\`\` or \`\`replication\`\`.
        :param auth: 
        :param common: 
        :param global_: 
        :param primary: 
        :param secondary: 

        :schema: mysql
        '''
        if isinstance(auth, dict):
            auth = MysqlAuth(**auth)
        if isinstance(primary, dict):
            primary = MysqlPrimary(**primary)
        if isinstance(secondary, dict):
            secondary = MysqlSecondary(**secondary)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ba4b7249d1a1862400c9b19cff8ae48324c2ce9cf5eddeb6ee91753a02247696)
            check_type(argname=\\"argument additional_values\\", value=additional_values, expected_type=type_hints[\\"additional_values\\"])
            check_type(argname=\\"argument architecture\\", value=architecture, expected_type=type_hints[\\"architecture\\"])
            check_type(argname=\\"argument auth\\", value=auth, expected_type=type_hints[\\"auth\\"])
            check_type(argname=\\"argument common\\", value=common, expected_type=type_hints[\\"common\\"])
            check_type(argname=\\"argument global_\\", value=global_, expected_type=type_hints[\\"global_\\"])
            check_type(argname=\\"argument primary\\", value=primary, expected_type=type_hints[\\"primary\\"])
            check_type(argname=\\"argument secondary\\", value=secondary, expected_type=type_hints[\\"secondary\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if additional_values is not None:
            self._values[\\"additional_values\\"] = additional_values
        if architecture is not None:
            self._values[\\"architecture\\"] = architecture
        if auth is not None:
            self._values[\\"auth\\"] = auth
        if common is not None:
            self._values[\\"common\\"] = common
        if global_ is not None:
            self._values[\\"global_\\"] = global_
        if primary is not None:
            self._values[\\"primary\\"] = primary
        if secondary is not None:
            self._values[\\"secondary\\"] = secondary

    @builtins.property
    def additional_values(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''Values that are not available in values.schema.json will not be code generated. You can add such values to this property.

        :schema: mysql#additionalValues
        '''
        result = self._values.get(\\"additional_values\\")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def architecture(self) -> typing.Optional[MysqlArchitecture]:
        '''Allowed values: \`\`standalone\`\` or \`\`replication\`\`.

        :schema: mysql#architecture
        '''
        result = self._values.get(\\"architecture\\")
        return typing.cast(typing.Optional[MysqlArchitecture], result)

    @builtins.property
    def auth(self) -> typing.Optional[MysqlAuth]:
        '''
        :schema: mysql#auth
        '''
        result = self._values.get(\\"auth\\")
        return typing.cast(typing.Optional[MysqlAuth], result)

    @builtins.property
    def common(self) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''
        :schema: mysql#common
        '''
        result = self._values.get(\\"common\\")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def global_(self) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''
        :schema: mysql#global
        '''
        result = self._values.get(\\"global_\\")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def primary(self) -> typing.Optional[MysqlPrimary]:
        '''
        :schema: mysql#primary
        '''
        result = self._values.get(\\"primary\\")
        return typing.cast(typing.Optional[MysqlPrimary], result)

    @builtins.property
    def secondary(self) -> typing.Optional[MysqlSecondary]:
        '''
        :schema: mysql#secondary
        '''
        result = self._values.get(\\"secondary\\")
        return typing.cast(typing.Optional[MysqlSecondary], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"MysqlValues(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


__all__ = [
    \\"Mysql\\",
    \\"MysqlArchitecture\\",
    \\"MysqlAuth\\",
    \\"MysqlPrimary\\",
    \\"MysqlPrimaryContainerSecurityContext\\",
    \\"MysqlPrimaryPersistence\\",
    \\"MysqlPrimaryPodSecurityContext\\",
    \\"MysqlProps\\",
    \\"MysqlSecondary\\",
    \\"MysqlSecondaryContainerSecurityContext\\",
    \\"MysqlSecondaryPersistence\\",
    \\"MysqlSecondaryPodSecurityContext\\",
    \\"MysqlValues\\",
]

publication.publish()

def _typecheckingstub__95a811b01af67eee2d8e2ae24fcefa9fa2ac995a1f9685f3e921af5330ef82ff(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    helm_executable: typing.Optional[builtins.str] = None,
    helm_flags: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespace: typing.Optional[builtins.str] = None,
    release_name: typing.Optional[builtins.str] = None,
    values: typing.Optional[typing.Union[MysqlValues, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__ee06bc5fa81868398bad26c41946af017c8765bcca5abe66e5d88d360a20e315(
    *,
    password: builtins.str,
    username: builtins.str,
    additional_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    create_database: typing.Optional[builtins.bool] = None,
    database: typing.Optional[builtins.str] = None,
    replication_password: typing.Optional[builtins.str] = None,
    replication_user: typing.Optional[builtins.str] = None,
    root_password: typing.Optional[builtins.str] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__5f80f16db85307f6e2dc2fd18749079a45e96857945ee617d44938b1e1fa49dd(
    *,
    additional_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    container_security_context: typing.Optional[typing.Union[MysqlPrimaryContainerSecurityContext, typing.Dict[builtins.str, typing.Any]]] = None,
    persistence: typing.Optional[typing.Union[MysqlPrimaryPersistence, typing.Dict[builtins.str, typing.Any]]] = None,
    pod_security_context: typing.Optional[typing.Union[MysqlPrimaryPodSecurityContext, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__b6c44d7f91b4cf3cb542cb1506165f060a9a15243f09931b735b74af15eaf7ae(
    *,
    additional_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    enabled: typing.Optional[builtins.bool] = None,
    run_as_user: typing.Optional[jsii.Number] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__da573ccf5d6dca82a8d1cb770a6c85bd0dd98f4b5fe00a7260e815a7140dc9ba(
    *,
    additional_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    enabled: typing.Optional[builtins.bool] = None,
    size: typing.Optional[builtins.str] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__f093d2c1e555d5d67dfb226a625b4abd2741a6b3333a3f12627a45d66a375c7c(
    *,
    additional_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    enabled: typing.Optional[builtins.bool] = None,
    fs_group: typing.Optional[jsii.Number] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__e0f01c3bcbff3f33dcd5e42ea1dca1754a4ffa560d4ed4393b91bf8167da3e71(
    *,
    helm_executable: typing.Optional[builtins.str] = None,
    helm_flags: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespace: typing.Optional[builtins.str] = None,
    release_name: typing.Optional[builtins.str] = None,
    values: typing.Optional[typing.Union[MysqlValues, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__9f5e9436f8b23b1168f49948e6f47f206871fa357437067fe13eb80a1e4844f2(
    *,
    additional_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    container_security_context: typing.Optional[typing.Union[MysqlSecondaryContainerSecurityContext, typing.Dict[builtins.str, typing.Any]]] = None,
    persistence: typing.Optional[typing.Union[MysqlSecondaryPersistence, typing.Dict[builtins.str, typing.Any]]] = None,
    pod_security_context: typing.Optional[typing.Union[MysqlSecondaryPodSecurityContext, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__1ae0b9a8b2ed30dd59da81691df3e07509c48d79c4bae3cf246ab40221c987b1(
    *,
    additional_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    enabled: typing.Optional[builtins.bool] = None,
    run_as_user: typing.Optional[jsii.Number] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__948c5c8f94b41fa54e53ae6a34ae87281865e016dcca8ad5308b1666738cbd56(
    *,
    additional_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    enabled: typing.Optional[builtins.bool] = None,
    size: typing.Optional[builtins.str] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__c3d21a01f61c5c4594bfd80de49afce454aa452afa8cc380cf0792cf29872ce7(
    *,
    additional_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    enabled: typing.Optional[builtins.bool] = None,
    fs_group: typing.Optional[jsii.Number] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__ba4b7249d1a1862400c9b19cff8ae48324c2ce9cf5eddeb6ee91753a02247696(
    *,
    additional_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    architecture: typing.Optional[MysqlArchitecture] = None,
    auth: typing.Optional[typing.Union[MysqlAuth, typing.Dict[builtins.str, typing.Any]]] = None,
    common: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    global_: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    primary: typing.Optional[typing.Union[MysqlPrimary, typing.Dict[builtins.str, typing.Any]]] = None,
    secondary: typing.Optional[typing.Union[MysqlSecondary, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass
",
  "mysql/_jsii/__init__.py": "from pkgutil import extend_path
__path__ = extend_path(__path__, __name__)

import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

import typeguard
from importlib.metadata import version as _metadata_package_version
TYPEGUARD_MAJOR_VERSION = int(_metadata_package_version('typeguard').split('.')[0])

def check_type(argname: str, value: object, expected_type: typing.Any) -> typing.Any:
    if TYPEGUARD_MAJOR_VERSION <= 2:
        return typeguard.check_type(argname=argname, value=value, expected_type=expected_type) # type:ignore
    else:
        if isinstance(value, jsii._reference_map.InterfaceDynamicProxy): # pyright: ignore [reportAttributeAccessIssue]
           pass
        else:
            if TYPEGUARD_MAJOR_VERSION == 3:
                typeguard.config.collection_check_strategy = typeguard.CollectionCheckStrategy.ALL_ITEMS # type:ignore
                typeguard.check_type(value=value, expected_type=expected_type) # type:ignore
            else:
                typeguard.check_type(value=value, expected_type=expected_type, collection_check_strategy=typeguard.CollectionCheckStrategy.ALL_ITEMS) # type:ignore

import cdk8s._jsii
import constructs._jsii

__jsii_assembly__ = jsii.JSIIAssembly.load(
    \\"mysql\\", \\"0.0.0\\", __name__[0:-6], \\"mysql@0.0.0.jsii.tgz\\"
)

__all__ = [
    \\"__jsii_assembly__\\",
]

publication.publish()
",
  "mysql/py.typed": "
",
}
`;

exports[`importing helm chart helm:oci://registry-1.docker.io/bitnamicharts/mysql@9.12.5 with typescript lanugage 1`] = `
Object {
  "author": Object {
    "name": "generated@generated.com",
    "roles": Array [
      "author",
    ],
  },
  "dependencies": "__omitted__",
  "dependencyClosure": Object {
    "cdk8s": Object {
      "targets": Object {
        "dotnet": Object {
          "namespace": "Org.Cdk8s",
          "packageId": "Org.Cdk8s",
        },
        "go": Object {
          "moduleName": "github.com/cdk8s-team/cdk8s-core-go",
        },
        "java": Object {
          "maven": Object {
            "artifactId": "cdk8s",
            "groupId": "org.cdk8s",
          },
          "package": "org.cdk8s",
        },
        "js": Object {
          "npm": "cdk8s",
        },
        "python": Object {
          "distName": "cdk8s",
          "module": "cdk8s",
        },
      },
    },
    "constructs": Object {
      "targets": Object {
        "dotnet": Object {
          "namespace": "Constructs",
          "packageId": "Constructs",
        },
        "go": Object {
          "moduleName": "github.com/aws/constructs-go",
        },
        "java": Object {
          "maven": Object {
            "artifactId": "constructs",
            "groupId": "software.constructs",
          },
          "package": "software.constructs",
        },
        "js": Object {
          "npm": "constructs",
        },
        "python": Object {
          "distName": "constructs",
          "module": "constructs",
        },
      },
    },
  },
  "description": "mysql",
  "fingerprint": "<fingerprint>",
  "homepage": "http://generated",
  "jsiiVersion": "__omitted__",
  "license": "UNLICENSED",
  "metadata": Object {
    "jsii": Object {
      "pacmak": Object {
        "hasDefaultInterfaces": true,
      },
    },
  },
  "name": "mysql",
  "repository": Object {
    "type": "git",
    "url": "http://generated",
  },
  "schema": "jsii/0.10.0",
  "targets": Object {
    "js": Object {
      "npm": "mysql",
    },
  },
  "types": Object {
    "mysql.Mysql": Object {
      "assembly": "mysql",
      "base": "constructs.Construct",
      "fqn": "mysql.Mysql",
      "initializer": Object {
        "locationInModule": Object {
          "filename": "mysql.ts",
          "line": 14,
        },
        "parameters": Array [
          Object {
            "name": "scope",
            "type": Object {
              "fqn": "constructs.Construct",
            },
          },
          Object {
            "name": "id",
            "type": Object {
              "primitive": "string",
            },
          },
          Object {
            "name": "props",
            "optional": true,
            "type": Object {
              "fqn": "mysql.MysqlProps",
            },
          },
        ],
      },
      "kind": "class",
      "locationInModule": Object {
        "filename": "mysql.ts",
        "line": 13,
      },
      "name": "Mysql",
      "symbolId": "mysql:Mysql",
    },
    "mysql.MysqlArchitecture": Object {
      "assembly": "mysql",
      "docs": Object {
        "custom": Object {
          "schema": "MysqlArchitecture",
        },
        "summary": "Allowed values: \`standalone\` or \`replication\`.",
      },
      "fqn": "mysql.MysqlArchitecture",
      "kind": "enum",
      "locationInModule": Object {
        "filename": "mysql.ts",
        "line": 112,
      },
      "members": Array [
        Object {
          "docs": Object {
            "summary": "standalone.",
          },
          "name": "STANDALONE",
        },
        Object {
          "docs": Object {
            "summary": "replication.",
          },
          "name": "REPLICATION",
        },
      ],
      "name": "MysqlArchitecture",
      "symbolId": "mysql:MysqlArchitecture",
    },
    "mysql.MysqlAuth": Object {
      "assembly": "mysql",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "MysqlAuth",
        },
      },
      "fqn": "mysql.MysqlAuth",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "mysql.ts",
        "line": 122,
      },
      "name": "MysqlAuth",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlAuth#password",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 144,
          },
          "name": "password",
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlAuth#username",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 139,
          },
          "name": "username",
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlAuth#additionalValues",
            },
            "summary": "Values that are not available in values.schema.json will not be code generated. You can add such values to this property.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 166,
          },
          "name": "additionalValues",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "any",
              },
              "kind": "map",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlAuth#createDatabase",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 159,
          },
          "name": "createDatabase",
          "optional": true,
          "type": Object {
            "primitive": "boolean",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlAuth#database",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 134,
          },
          "name": "database",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlAuth#replicationPassword",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 154,
          },
          "name": "replicationPassword",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlAuth#replicationUser",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 149,
          },
          "name": "replicationUser",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlAuth#rootPassword",
            },
            "default": "a random 10-character alphanumeric string if not set",
            "summary": "Defaults to a random 10-character alphanumeric string if not set.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 129,
          },
          "name": "rootPassword",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
      ],
      "symbolId": "mysql:MysqlAuth",
    },
    "mysql.MysqlPrimary": Object {
      "assembly": "mysql",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "MysqlPrimary",
        },
      },
      "fqn": "mysql.MysqlPrimary",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "mysql.ts",
        "line": 173,
      },
      "name": "MysqlPrimary",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlPrimary#additionalValues",
            },
            "summary": "Values that are not available in values.schema.json will not be code generated. You can add such values to this property.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 194,
          },
          "name": "additionalValues",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "any",
              },
              "kind": "map",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlPrimary#containerSecurityContext",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 182,
          },
          "name": "containerSecurityContext",
          "optional": true,
          "type": Object {
            "fqn": "mysql.MysqlPrimaryContainerSecurityContext",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlPrimary#persistence",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 187,
          },
          "name": "persistence",
          "optional": true,
          "type": Object {
            "fqn": "mysql.MysqlPrimaryPersistence",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlPrimary#podSecurityContext",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 177,
          },
          "name": "podSecurityContext",
          "optional": true,
          "type": Object {
            "fqn": "mysql.MysqlPrimaryPodSecurityContext",
          },
        },
      ],
      "symbolId": "mysql:MysqlPrimary",
    },
    "mysql.MysqlPrimaryContainerSecurityContext": Object {
      "assembly": "mysql",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "MysqlPrimaryContainerSecurityContext",
        },
      },
      "fqn": "mysql.MysqlPrimaryContainerSecurityContext",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "mysql.ts",
        "line": 252,
      },
      "name": "MysqlPrimaryContainerSecurityContext",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlPrimaryContainerSecurityContext#additionalValues",
            },
            "summary": "Values that are not available in values.schema.json will not be code generated. You can add such values to this property.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 268,
          },
          "name": "additionalValues",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "any",
              },
              "kind": "map",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlPrimaryContainerSecurityContext#enabled",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 256,
          },
          "name": "enabled",
          "optional": true,
          "type": Object {
            "primitive": "boolean",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlPrimaryContainerSecurityContext#runAsUser",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 261,
          },
          "name": "runAsUser",
          "optional": true,
          "type": Object {
            "primitive": "number",
          },
        },
      ],
      "symbolId": "mysql:MysqlPrimaryContainerSecurityContext",
    },
    "mysql.MysqlPrimaryPersistence": Object {
      "assembly": "mysql",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "MysqlPrimaryPersistence",
        },
      },
      "fqn": "mysql.MysqlPrimaryPersistence",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "mysql.ts",
        "line": 275,
      },
      "name": "MysqlPrimaryPersistence",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlPrimaryPersistence#additionalValues",
            },
            "summary": "Values that are not available in values.schema.json will not be code generated. You can add such values to this property.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 291,
          },
          "name": "additionalValues",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "any",
              },
              "kind": "map",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlPrimaryPersistence#enabled",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 279,
          },
          "name": "enabled",
          "optional": true,
          "type": Object {
            "primitive": "boolean",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlPrimaryPersistence#size",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 284,
          },
          "name": "size",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
      ],
      "symbolId": "mysql:MysqlPrimaryPersistence",
    },
    "mysql.MysqlPrimaryPodSecurityContext": Object {
      "assembly": "mysql",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "MysqlPrimaryPodSecurityContext",
        },
      },
      "fqn": "mysql.MysqlPrimaryPodSecurityContext",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "mysql.ts",
        "line": 229,
      },
      "name": "MysqlPrimaryPodSecurityContext",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlPrimaryPodSecurityContext#additionalValues",
            },
            "summary": "Values that are not available in values.schema.json will not be code generated. You can add such values to this property.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 245,
          },
          "name": "additionalValues",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "any",
              },
              "kind": "map",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlPrimaryPodSecurityContext#enabled",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 233,
          },
          "name": "enabled",
          "optional": true,
          "type": Object {
            "primitive": "boolean",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlPrimaryPodSecurityContext#fsGroup",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 238,
          },
          "name": "fsGroup",
          "optional": true,
          "type": Object {
            "primitive": "number",
          },
        },
      ],
      "symbolId": "mysql:MysqlPrimaryPodSecurityContext",
    },
    "mysql.MysqlProps": Object {
      "assembly": "mysql",
      "datatype": true,
      "fqn": "mysql.MysqlProps",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "mysql.ts",
        "line": 5,
      },
      "name": "MysqlProps",
      "properties": Array [
        Object {
          "abstract": true,
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 8,
          },
          "name": "helmExecutable",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 9,
          },
          "name": "helmFlags",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "string",
              },
              "kind": "array",
            },
          },
        },
        Object {
          "abstract": true,
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 6,
          },
          "name": "namespace",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 7,
          },
          "name": "releaseName",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 10,
          },
          "name": "values",
          "optional": true,
          "type": Object {
            "fqn": "mysql.MysqlValues",
          },
        },
      ],
      "symbolId": "mysql:MysqlProps",
    },
    "mysql.MysqlSecondary": Object {
      "assembly": "mysql",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "MysqlSecondary",
        },
      },
      "fqn": "mysql.MysqlSecondary",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "mysql.ts",
        "line": 201,
      },
      "name": "MysqlSecondary",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlSecondary#additionalValues",
            },
            "summary": "Values that are not available in values.schema.json will not be code generated. You can add such values to this property.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 222,
          },
          "name": "additionalValues",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "any",
              },
              "kind": "map",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlSecondary#containerSecurityContext",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 210,
          },
          "name": "containerSecurityContext",
          "optional": true,
          "type": Object {
            "fqn": "mysql.MysqlSecondaryContainerSecurityContext",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlSecondary#persistence",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 215,
          },
          "name": "persistence",
          "optional": true,
          "type": Object {
            "fqn": "mysql.MysqlSecondaryPersistence",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlSecondary#podSecurityContext",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 205,
          },
          "name": "podSecurityContext",
          "optional": true,
          "type": Object {
            "fqn": "mysql.MysqlSecondaryPodSecurityContext",
          },
        },
      ],
      "symbolId": "mysql:MysqlSecondary",
    },
    "mysql.MysqlSecondaryContainerSecurityContext": Object {
      "assembly": "mysql",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "MysqlSecondaryContainerSecurityContext",
        },
      },
      "fqn": "mysql.MysqlSecondaryContainerSecurityContext",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "mysql.ts",
        "line": 321,
      },
      "name": "MysqlSecondaryContainerSecurityContext",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlSecondaryContainerSecurityContext#additionalValues",
            },
            "summary": "Values that are not available in values.schema.json will not be code generated. You can add such values to this property.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 337,
          },
          "name": "additionalValues",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "any",
              },
              "kind": "map",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlSecondaryContainerSecurityContext#enabled",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 325,
          },
          "name": "enabled",
          "optional": true,
          "type": Object {
            "primitive": "boolean",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlSecondaryContainerSecurityContext#runAsUser",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 330,
          },
          "name": "runAsUser",
          "optional": true,
          "type": Object {
            "primitive": "number",
          },
        },
      ],
      "symbolId": "mysql:MysqlSecondaryContainerSecurityContext",
    },
    "mysql.MysqlSecondaryPersistence": Object {
      "assembly": "mysql",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "MysqlSecondaryPersistence",
        },
      },
      "fqn": "mysql.MysqlSecondaryPersistence",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "mysql.ts",
        "line": 344,
      },
      "name": "MysqlSecondaryPersistence",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlSecondaryPersistence#additionalValues",
            },
            "summary": "Values that are not available in values.schema.json will not be code generated. You can add such values to this property.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 360,
          },
          "name": "additionalValues",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "any",
              },
              "kind": "map",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlSecondaryPersistence#enabled",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 348,
          },
          "name": "enabled",
          "optional": true,
          "type": Object {
            "primitive": "boolean",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlSecondaryPersistence#size",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 353,
          },
          "name": "size",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
      ],
      "symbolId": "mysql:MysqlSecondaryPersistence",
    },
    "mysql.MysqlSecondaryPodSecurityContext": Object {
      "assembly": "mysql",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "MysqlSecondaryPodSecurityContext",
        },
      },
      "fqn": "mysql.MysqlSecondaryPodSecurityContext",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "mysql.ts",
        "line": 298,
      },
      "name": "MysqlSecondaryPodSecurityContext",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlSecondaryPodSecurityContext#additionalValues",
            },
            "summary": "Values that are not available in values.schema.json will not be code generated. You can add such values to this property.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 314,
          },
          "name": "additionalValues",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "any",
              },
              "kind": "map",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlSecondaryPodSecurityContext#enabled",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 302,
          },
          "name": "enabled",
          "optional": true,
          "type": Object {
            "primitive": "boolean",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "MysqlSecondaryPodSecurityContext#fsGroup",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 307,
          },
          "name": "fsGroup",
          "optional": true,
          "type": Object {
            "primitive": "number",
          },
        },
      ],
      "symbolId": "mysql:MysqlSecondaryPodSecurityContext",
    },
    "mysql.MysqlValues": Object {
      "assembly": "mysql",
      "datatype": true,
      "docs": Object {
        "custom": Object {
          "schema": "mysql",
        },
      },
      "fqn": "mysql.MysqlValues",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "mysql.ts",
        "line": 65,
      },
      "name": "MysqlValues",
      "properties": Array [
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "mysql#additionalValues",
            },
            "summary": "Values that are not available in values.schema.json will not be code generated. You can add such values to this property.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 103,
          },
          "name": "additionalValues",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "any",
              },
              "kind": "map",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "mysql#architecture",
            },
            "summary": "Allowed values: \`standalone\` or \`replication\`.",
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 71,
          },
          "name": "architecture",
          "optional": true,
          "type": Object {
            "fqn": "mysql.MysqlArchitecture",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "mysql#auth",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 76,
          },
          "name": "auth",
          "optional": true,
          "type": Object {
            "fqn": "mysql.MysqlAuth",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "mysql#common",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 91,
          },
          "name": "common",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "any",
              },
              "kind": "map",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "mysql#global",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 96,
          },
          "name": "global",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "any",
              },
              "kind": "map",
            },
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "mysql#primary",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 81,
          },
          "name": "primary",
          "optional": true,
          "type": Object {
            "fqn": "mysql.MysqlPrimary",
          },
        },
        Object {
          "abstract": true,
          "docs": Object {
            "custom": Object {
              "schema": "mysql#secondary",
            },
          },
          "immutable": true,
          "locationInModule": Object {
            "filename": "mysql.ts",
            "line": 86,
          },
          "name": "secondary",
          "optional": true,
          "type": Object {
            "fqn": "mysql.MysqlSecondary",
          },
        },
      ],
      "symbolId": "mysql:MysqlValues",
    },
  },
  "version": "0.0.0",
}
`;

exports[`importing helm chart helm:oci://registry-1.docker.io/bitnamicharts/mysql@9.12.5 with typescript lanugage 2`] = `
Object {
  "mysql.ts": "// generated by cdk8s
import { Helm, HelmProps } from 'cdk8s';
import { Construct } from 'constructs';

export interface MysqlProps {
  readonly namespace?: string;
  readonly releaseName?: string;
  readonly helmExecutable?: string;
  readonly helmFlags?: string[];
  readonly values?: MysqlValues;
}

export class Mysql extends Construct {
  public constructor(scope: Construct, id: string, props: MysqlProps = {}) {
    super(scope, id);
    let updatedProps = {};

    if (props.values) {
      const { additionalValues, ...valuesWithoutAdditionalValues } = props.values;
      updatedProps = {
        ...props,
        values: {
          ...this.flattenAdditionalValues(valuesWithoutAdditionalValues),
          ...additionalValues,
        },
      };
    }

    const finalProps: HelmProps = {
      chart: 'oci://registry-1.docker.io/bitnamicharts/mysql',
      version: '9.12.5',
      ...(Object.keys(updatedProps).length !== 0 ? updatedProps : props),
    };

    new Helm(this, 'Helm', finalProps);
  }

  private flattenAdditionalValues(props: { [key: string]: any }): { [key: string]: any } {
    for (let prop in props) {
      if (Array.isArray(props[prop])) {
        props[prop].map((item: any) => {
          if (typeof item === 'object' && prop !== 'additionalValues') {
            return this.flattenAdditionalValues(item);
          }
          return item;
        });
      }
      else if (typeof props[prop] === 'object' && prop !== 'additionalValues') {
        props[prop] = this.flattenAdditionalValues(props[prop]);
      }
    }

    const { additionalValues, ...valuesWithoutAdditionalValues } = props;

    return {
      ...valuesWithoutAdditionalValues,
      ...additionalValues,
    };
  }
}

/**
 * @schema mysql
 */
export interface MysqlValues {
  /**
   * Allowed values: \`standalone\` or \`replication\`
   *
   * @schema mysql#architecture
   */
  readonly architecture?: MysqlArchitecture;

  /**
   * @schema mysql#auth
   */
  readonly auth?: MysqlAuth;

  /**
   * @schema mysql#primary
   */
  readonly primary?: MysqlPrimary;

  /**
   * @schema mysql#secondary
   */
  readonly secondary?: MysqlSecondary;

  /**
   * @schema mysql#common
   */
  readonly common?: { [key: string]: any };

  /**
   * @schema mysql#global
   */
  readonly global?: { [key: string]: any };

  /**
   * Values that are not available in values.schema.json will not be code generated. You can add such values to this property.
   *
   * @schema mysql#additionalValues
   */
  readonly additionalValues?: { [key: string]: any };

}

/**
 * Allowed values: \`standalone\` or \`replication\`
 *
 * @schema MysqlArchitecture
 */
export enum MysqlArchitecture {
  /** standalone */
  STANDALONE = \\"standalone\\",
  /** replication */
  REPLICATION = \\"replication\\",
}

/**
 * @schema MysqlAuth
 */
export interface MysqlAuth {
  /**
   * Defaults to a random 10-character alphanumeric string if not set
   *
   * @default a random 10-character alphanumeric string if not set
   * @schema MysqlAuth#rootPassword
   */
  readonly rootPassword?: string;

  /**
   * @schema MysqlAuth#database
   */
  readonly database?: string;

  /**
   * @schema MysqlAuth#username
   */
  readonly username: string;

  /**
   * @schema MysqlAuth#password
   */
  readonly password: string;

  /**
   * @schema MysqlAuth#replicationUser
   */
  readonly replicationUser?: string;

  /**
   * @schema MysqlAuth#replicationPassword
   */
  readonly replicationPassword?: string;

  /**
   * @schema MysqlAuth#createDatabase
   */
  readonly createDatabase?: boolean;

  /**
   * Values that are not available in values.schema.json will not be code generated. You can add such values to this property.
   *
   * @schema MysqlAuth#additionalValues
   */
  readonly additionalValues?: { [key: string]: any };

}

/**
 * @schema MysqlPrimary
 */
export interface MysqlPrimary {
  /**
   * @schema MysqlPrimary#podSecurityContext
   */
  readonly podSecurityContext?: MysqlPrimaryPodSecurityContext;

  /**
   * @schema MysqlPrimary#containerSecurityContext
   */
  readonly containerSecurityContext?: MysqlPrimaryContainerSecurityContext;

  /**
   * @schema MysqlPrimary#persistence
   */
  readonly persistence?: MysqlPrimaryPersistence;

  /**
   * Values that are not available in values.schema.json will not be code generated. You can add such values to this property.
   *
   * @schema MysqlPrimary#additionalValues
   */
  readonly additionalValues?: { [key: string]: any };

}

/**
 * @schema MysqlSecondary
 */
export interface MysqlSecondary {
  /**
   * @schema MysqlSecondary#podSecurityContext
   */
  readonly podSecurityContext?: MysqlSecondaryPodSecurityContext;

  /**
   * @schema MysqlSecondary#containerSecurityContext
   */
  readonly containerSecurityContext?: MysqlSecondaryContainerSecurityContext;

  /**
   * @schema MysqlSecondary#persistence
   */
  readonly persistence?: MysqlSecondaryPersistence;

  /**
   * Values that are not available in values.schema.json will not be code generated. You can add such values to this property.
   *
   * @schema MysqlSecondary#additionalValues
   */
  readonly additionalValues?: { [key: string]: any };

}

/**
 * @schema MysqlPrimaryPodSecurityContext
 */
export interface MysqlPrimaryPodSecurityContext {
  /**
   * @schema MysqlPrimaryPodSecurityContext#enabled
   */
  readonly enabled?: boolean;

  /**
   * @schema MysqlPrimaryPodSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * Values that are not available in values.schema.json will not be code generated. You can add such values to this property.
   *
   * @schema MysqlPrimaryPodSecurityContext#additionalValues
   */
  readonly additionalValues?: { [key: string]: any };

}

/**
 * @schema MysqlPrimaryContainerSecurityContext
 */
export interface MysqlPrimaryContainerSecurityContext {
  /**
   * @schema MysqlPrimaryContainerSecurityContext#enabled
   */
  readonly enabled?: boolean;

  /**
   * @schema MysqlPrimaryContainerSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * Values that are not available in values.schema.json will not be code generated. You can add such values to this property.
   *
   * @schema MysqlPrimaryContainerSecurityContext#additionalValues
   */
  readonly additionalValues?: { [key: string]: any };

}

/**
 * @schema MysqlPrimaryPersistence
 */
export interface MysqlPrimaryPersistence {
  /**
   * @schema MysqlPrimaryPersistence#enabled
   */
  readonly enabled?: boolean;

  /**
   * @schema MysqlPrimaryPersistence#size
   */
  readonly size?: string;

  /**
   * Values that are not available in values.schema.json will not be code generated. You can add such values to this property.
   *
   * @schema MysqlPrimaryPersistence#additionalValues
   */
  readonly additionalValues?: { [key: string]: any };

}

/**
 * @schema MysqlSecondaryPodSecurityContext
 */
export interface MysqlSecondaryPodSecurityContext {
  /**
   * @schema MysqlSecondaryPodSecurityContext#enabled
   */
  readonly enabled?: boolean;

  /**
   * @schema MysqlSecondaryPodSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * Values that are not available in values.schema.json will not be code generated. You can add such values to this property.
   *
   * @schema MysqlSecondaryPodSecurityContext#additionalValues
   */
  readonly additionalValues?: { [key: string]: any };

}

/**
 * @schema MysqlSecondaryContainerSecurityContext
 */
export interface MysqlSecondaryContainerSecurityContext {
  /**
   * @schema MysqlSecondaryContainerSecurityContext#enabled
   */
  readonly enabled?: boolean;

  /**
   * @schema MysqlSecondaryContainerSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * Values that are not available in values.schema.json will not be code generated. You can add such values to this property.
   *
   * @schema MysqlSecondaryContainerSecurityContext#additionalValues
   */
  readonly additionalValues?: { [key: string]: any };

}

/**
 * @schema MysqlSecondaryPersistence
 */
export interface MysqlSecondaryPersistence {
  /**
   * @schema MysqlSecondaryPersistence#enabled
   */
  readonly enabled?: boolean;

  /**
   * @schema MysqlSecondaryPersistence#size
   */
  readonly size?: string;

  /**
   * Values that are not available in values.schema.json will not be code generated. You can add such values to this property.
   *
   * @schema MysqlSecondaryPersistence#additionalValues
   */
  readonly additionalValues?: { [key: string]: any };

}

",
}
`;

exports[`importing helm chart minio:=helm:https://operator.min.io/operator@5.0.9 with python lanugage 1`] = `
Object {
  "author": Object {
    "name": "generated@generated.com",
    "roles": Array [
      "author",
    ],
  },
  "dependencies": "__omitted__",
  "dependencyClosure": Object {
    "cdk8s": Object {
      "targets": Object {
        "dotnet": Object {
          "namespace": "Org.Cdk8s",
          "packageId": "Org.Cdk8s",
        },
        "go": Object {
          "moduleName": "github.com/cdk8s-team/cdk8s-core-go",
        },
        "java": Object {
          "maven": Object {
            "artifactId": "cdk8s",
            "groupId": "org.cdk8s",
          },
          "package": "org.cdk8s",
        },
        "js": Object {
          "npm": "cdk8s",
        },
        "python": Object {
          "distName": "cdk8s",
          "module": "cdk8s",
        },
      },
    },
    "constructs": Object {
      "targets": Object {
        "dotnet": Object {
          "namespace": "Constructs",
          "packageId": "Constructs",
        },
        "go": Object {
          "moduleName": "github.com/aws/constructs-go",
        },
        "java": Object {
          "maven": Object {
            "artifactId": "constructs",
            "groupId": "software.constructs",
          },
          "package": "software.constructs",
        },
        "js": Object {
          "npm": "constructs",
        },
        "python": Object {
          "distName": "constructs",
          "module": "constructs",
        },
      },
    },
  },
  "description": "operator",
  "fingerprint": "<fingerprint>",
  "homepage": "http://generated",
  "jsiiVersion": "__omitted__",
  "license": "UNLICENSED",
  "metadata": Object {
    "jsii": Object {
      "pacmak": Object {
        "hasDefaultInterfaces": true,
      },
    },
  },
  "name": "operator",
  "repository": Object {
    "type": "git",
    "url": "http://generated",
  },
  "schema": "jsii/0.10.0",
  "targets": Object {
    "js": Object {
      "npm": "operator",
    },
    "python": Object {
      "distName": "generated",
      "module": "operator",
    },
  },
  "types": Object {
    "operator.Operator": Object {
      "assembly": "operator",
      "base": "constructs.Construct",
      "fqn": "operator.Operator",
      "initializer": Object {
        "locationInModule": Object {
          "filename": "operator.ts",
          "line": 14,
        },
        "parameters": Array [
          Object {
            "name": "scope",
            "type": Object {
              "fqn": "constructs.Construct",
            },
          },
          Object {
            "name": "id",
            "type": Object {
              "primitive": "string",
            },
          },
          Object {
            "name": "props",
            "optional": true,
            "type": Object {
              "fqn": "operator.OperatorProps",
            },
          },
        ],
      },
      "kind": "class",
      "locationInModule": Object {
        "filename": "operator.ts",
        "line": 13,
      },
      "name": "Operator",
      "symbolId": "operator:Operator",
    },
    "operator.OperatorProps": Object {
      "assembly": "operator",
      "datatype": true,
      "fqn": "operator.OperatorProps",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "operator.ts",
        "line": 5,
      },
      "name": "OperatorProps",
      "properties": Array [
        Object {
          "abstract": true,
          "immutable": true,
          "locationInModule": Object {
            "filename": "operator.ts",
            "line": 8,
          },
          "name": "helmExecutable",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "immutable": true,
          "locationInModule": Object {
            "filename": "operator.ts",
            "line": 9,
          },
          "name": "helmFlags",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "string",
              },
              "kind": "array",
            },
          },
        },
        Object {
          "abstract": true,
          "immutable": true,
          "locationInModule": Object {
            "filename": "operator.ts",
            "line": 6,
          },
          "name": "namespace",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "immutable": true,
          "locationInModule": Object {
            "filename": "operator.ts",
            "line": 7,
          },
          "name": "releaseName",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "immutable": true,
          "locationInModule": Object {
            "filename": "operator.ts",
            "line": 10,
          },
          "name": "values",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "any",
              },
              "kind": "map",
            },
          },
        },
      ],
      "symbolId": "operator:OperatorProps",
    },
  },
  "version": "0.0.0",
}
`;

exports[`importing helm chart minio:=helm:https://operator.min.io/operator@5.0.9 with python lanugage 2`] = `
Object {
  "operator/__init__.py": "from pkgutil import extend_path
__path__ = extend_path(__path__, __name__)

import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

import typeguard
from importlib.metadata import version as _metadata_package_version
TYPEGUARD_MAJOR_VERSION = int(_metadata_package_version('typeguard').split('.')[0])

def check_type(argname: str, value: object, expected_type: typing.Any) -> typing.Any:
    if TYPEGUARD_MAJOR_VERSION <= 2:
        return typeguard.check_type(argname=argname, value=value, expected_type=expected_type) # type:ignore
    else:
        if isinstance(value, jsii._reference_map.InterfaceDynamicProxy): # pyright: ignore [reportAttributeAccessIssue]
           pass
        else:
            if TYPEGUARD_MAJOR_VERSION == 3:
                typeguard.config.collection_check_strategy = typeguard.CollectionCheckStrategy.ALL_ITEMS # type:ignore
                typeguard.check_type(value=value, expected_type=expected_type) # type:ignore
            else:
                typeguard.check_type(value=value, expected_type=expected_type, collection_check_strategy=typeguard.CollectionCheckStrategy.ALL_ITEMS) # type:ignore

from ._jsii import *

import constructs as _constructs_77d1e7e8


class Operator(
    _constructs_77d1e7e8.Construct,
    metaclass=jsii.JSIIMeta,
    jsii_type=\\"operator.Operator\\",
):
    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        helm_executable: typing.Optional[builtins.str] = None,
        helm_flags: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace: typing.Optional[builtins.str] = None,
        release_name: typing.Optional[builtins.str] = None,
        values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param helm_executable: -
        :param helm_flags: -
        :param namespace: -
        :param release_name: -
        :param values: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__11493dc2fc191cbb73ceb199e0facf7edcc58bf9f85942664ecc4614b277a2ba)
            check_type(argname=\\"argument scope\\", value=scope, expected_type=type_hints[\\"scope\\"])
            check_type(argname=\\"argument id\\", value=id, expected_type=type_hints[\\"id\\"])
        props = OperatorProps(
            helm_executable=helm_executable,
            helm_flags=helm_flags,
            namespace=namespace,
            release_name=release_name,
            values=values,
        )

        jsii.create(self.__class__, self, [scope, id, props])


@jsii.data_type(
    jsii_type=\\"operator.OperatorProps\\",
    jsii_struct_bases=[],
    name_mapping={
        \\"helm_executable\\": \\"helmExecutable\\",
        \\"helm_flags\\": \\"helmFlags\\",
        \\"namespace\\": \\"namespace\\",
        \\"release_name\\": \\"releaseName\\",
        \\"values\\": \\"values\\",
    },
)
class OperatorProps:
    def __init__(
        self,
        *,
        helm_executable: typing.Optional[builtins.str] = None,
        helm_flags: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace: typing.Optional[builtins.str] = None,
        release_name: typing.Optional[builtins.str] = None,
        values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    ) -> None:
        '''
        :param helm_executable: -
        :param helm_flags: -
        :param namespace: -
        :param release_name: -
        :param values: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1ba6cfa05344ec1eb73016e5b58b05d2a9a2e22bf82546647dd2d6dac88cf487)
            check_type(argname=\\"argument helm_executable\\", value=helm_executable, expected_type=type_hints[\\"helm_executable\\"])
            check_type(argname=\\"argument helm_flags\\", value=helm_flags, expected_type=type_hints[\\"helm_flags\\"])
            check_type(argname=\\"argument namespace\\", value=namespace, expected_type=type_hints[\\"namespace\\"])
            check_type(argname=\\"argument release_name\\", value=release_name, expected_type=type_hints[\\"release_name\\"])
            check_type(argname=\\"argument values\\", value=values, expected_type=type_hints[\\"values\\"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if helm_executable is not None:
            self._values[\\"helm_executable\\"] = helm_executable
        if helm_flags is not None:
            self._values[\\"helm_flags\\"] = helm_flags
        if namespace is not None:
            self._values[\\"namespace\\"] = namespace
        if release_name is not None:
            self._values[\\"release_name\\"] = release_name
        if values is not None:
            self._values[\\"values\\"] = values

    @builtins.property
    def helm_executable(self) -> typing.Optional[builtins.str]:
        result = self._values.get(\\"helm_executable\\")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def helm_flags(self) -> typing.Optional[typing.List[builtins.str]]:
        result = self._values.get(\\"helm_flags\\")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        result = self._values.get(\\"namespace\\")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def release_name(self) -> typing.Optional[builtins.str]:
        result = self._values.get(\\"release_name\\")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def values(self) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        result = self._values.get(\\"values\\")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return \\"OperatorProps(%s)\\" % \\", \\".join(
            k + \\"=\\" + repr(v) for k, v in self._values.items()
        )


__all__ = [
    \\"Operator\\",
    \\"OperatorProps\\",
]

publication.publish()

def _typecheckingstub__11493dc2fc191cbb73ceb199e0facf7edcc58bf9f85942664ecc4614b277a2ba(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    helm_executable: typing.Optional[builtins.str] = None,
    helm_flags: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespace: typing.Optional[builtins.str] = None,
    release_name: typing.Optional[builtins.str] = None,
    values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass

def _typecheckingstub__1ba6cfa05344ec1eb73016e5b58b05d2a9a2e22bf82546647dd2d6dac88cf487(
    *,
    helm_executable: typing.Optional[builtins.str] = None,
    helm_flags: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespace: typing.Optional[builtins.str] = None,
    release_name: typing.Optional[builtins.str] = None,
    values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
) -> None:
    \\"\\"\\"Type checking stubs\\"\\"\\"
    pass
",
  "operator/_jsii/__init__.py": "from pkgutil import extend_path
__path__ = extend_path(__path__, __name__)

import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

import typeguard
from importlib.metadata import version as _metadata_package_version
TYPEGUARD_MAJOR_VERSION = int(_metadata_package_version('typeguard').split('.')[0])

def check_type(argname: str, value: object, expected_type: typing.Any) -> typing.Any:
    if TYPEGUARD_MAJOR_VERSION <= 2:
        return typeguard.check_type(argname=argname, value=value, expected_type=expected_type) # type:ignore
    else:
        if isinstance(value, jsii._reference_map.InterfaceDynamicProxy): # pyright: ignore [reportAttributeAccessIssue]
           pass
        else:
            if TYPEGUARD_MAJOR_VERSION == 3:
                typeguard.config.collection_check_strategy = typeguard.CollectionCheckStrategy.ALL_ITEMS # type:ignore
                typeguard.check_type(value=value, expected_type=expected_type) # type:ignore
            else:
                typeguard.check_type(value=value, expected_type=expected_type, collection_check_strategy=typeguard.CollectionCheckStrategy.ALL_ITEMS) # type:ignore

import cdk8s._jsii
import constructs._jsii

__jsii_assembly__ = jsii.JSIIAssembly.load(
    \\"operator\\", \\"0.0.0\\", __name__[0:-6], \\"operator@0.0.0.jsii.tgz\\"
)

__all__ = [
    \\"__jsii_assembly__\\",
]

publication.publish()
",
  "operator/py.typed": "
",
}
`;

exports[`importing helm chart minio:=helm:https://operator.min.io/operator@5.0.9 with typescript lanugage 1`] = `
Object {
  "author": Object {
    "name": "generated@generated.com",
    "roles": Array [
      "author",
    ],
  },
  "dependencies": "__omitted__",
  "dependencyClosure": Object {
    "cdk8s": Object {
      "targets": Object {
        "dotnet": Object {
          "namespace": "Org.Cdk8s",
          "packageId": "Org.Cdk8s",
        },
        "go": Object {
          "moduleName": "github.com/cdk8s-team/cdk8s-core-go",
        },
        "java": Object {
          "maven": Object {
            "artifactId": "cdk8s",
            "groupId": "org.cdk8s",
          },
          "package": "org.cdk8s",
        },
        "js": Object {
          "npm": "cdk8s",
        },
        "python": Object {
          "distName": "cdk8s",
          "module": "cdk8s",
        },
      },
    },
    "constructs": Object {
      "targets": Object {
        "dotnet": Object {
          "namespace": "Constructs",
          "packageId": "Constructs",
        },
        "go": Object {
          "moduleName": "github.com/aws/constructs-go",
        },
        "java": Object {
          "maven": Object {
            "artifactId": "constructs",
            "groupId": "software.constructs",
          },
          "package": "software.constructs",
        },
        "js": Object {
          "npm": "constructs",
        },
        "python": Object {
          "distName": "constructs",
          "module": "constructs",
        },
      },
    },
  },
  "description": "operator",
  "fingerprint": "<fingerprint>",
  "homepage": "http://generated",
  "jsiiVersion": "__omitted__",
  "license": "UNLICENSED",
  "metadata": Object {
    "jsii": Object {
      "pacmak": Object {
        "hasDefaultInterfaces": true,
      },
    },
  },
  "name": "operator",
  "repository": Object {
    "type": "git",
    "url": "http://generated",
  },
  "schema": "jsii/0.10.0",
  "targets": Object {
    "js": Object {
      "npm": "operator",
    },
  },
  "types": Object {
    "operator.Operator": Object {
      "assembly": "operator",
      "base": "constructs.Construct",
      "fqn": "operator.Operator",
      "initializer": Object {
        "locationInModule": Object {
          "filename": "operator.ts",
          "line": 14,
        },
        "parameters": Array [
          Object {
            "name": "scope",
            "type": Object {
              "fqn": "constructs.Construct",
            },
          },
          Object {
            "name": "id",
            "type": Object {
              "primitive": "string",
            },
          },
          Object {
            "name": "props",
            "optional": true,
            "type": Object {
              "fqn": "operator.OperatorProps",
            },
          },
        ],
      },
      "kind": "class",
      "locationInModule": Object {
        "filename": "operator.ts",
        "line": 13,
      },
      "name": "Operator",
      "symbolId": "operator:Operator",
    },
    "operator.OperatorProps": Object {
      "assembly": "operator",
      "datatype": true,
      "fqn": "operator.OperatorProps",
      "kind": "interface",
      "locationInModule": Object {
        "filename": "operator.ts",
        "line": 5,
      },
      "name": "OperatorProps",
      "properties": Array [
        Object {
          "abstract": true,
          "immutable": true,
          "locationInModule": Object {
            "filename": "operator.ts",
            "line": 8,
          },
          "name": "helmExecutable",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "immutable": true,
          "locationInModule": Object {
            "filename": "operator.ts",
            "line": 9,
          },
          "name": "helmFlags",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "string",
              },
              "kind": "array",
            },
          },
        },
        Object {
          "abstract": true,
          "immutable": true,
          "locationInModule": Object {
            "filename": "operator.ts",
            "line": 6,
          },
          "name": "namespace",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "immutable": true,
          "locationInModule": Object {
            "filename": "operator.ts",
            "line": 7,
          },
          "name": "releaseName",
          "optional": true,
          "type": Object {
            "primitive": "string",
          },
        },
        Object {
          "abstract": true,
          "immutable": true,
          "locationInModule": Object {
            "filename": "operator.ts",
            "line": 10,
          },
          "name": "values",
          "optional": true,
          "type": Object {
            "collection": Object {
              "elementtype": Object {
                "primitive": "any",
              },
              "kind": "map",
            },
          },
        },
      ],
      "symbolId": "operator:OperatorProps",
    },
  },
  "version": "0.0.0",
}
`;

exports[`importing helm chart minio:=helm:https://operator.min.io/operator@5.0.9 with typescript lanugage 2`] = `
Object {
  "operator.ts": "// generated by cdk8s
import { Helm, HelmProps } from 'cdk8s';
import { Construct } from 'constructs';

export interface OperatorProps {
  readonly namespace?: string;
  readonly releaseName?: string;
  readonly helmExecutable?: string;
  readonly helmFlags?: string[];
  readonly values?: { [key: string]: any };
}

export class Operator extends Construct {
  public constructor(scope: Construct, id: string, props: OperatorProps = {}) {
    super(scope, id);
    let updatedProps = {};

    if (props.values) {
      const { additionalValues, ...valuesWithoutAdditionalValues } = props.values;
      updatedProps = {
        ...props,
        values: {
          ...this.flattenAdditionalValues(valuesWithoutAdditionalValues),
          ...additionalValues,
        },
      };
    }

    const finalProps: HelmProps = {
      chart: 'operator',
      repo: 'https://operator.min.io',
      version: '5.0.9',
      ...(Object.keys(updatedProps).length !== 0 ? updatedProps : props),
    };

    new Helm(this, 'Helm', finalProps);
  }

  private flattenAdditionalValues(props: { [key: string]: any }): { [key: string]: any } {
    for (let prop in props) {
      if (Array.isArray(props[prop])) {
        props[prop].map((item: any) => {
          if (typeof item === 'object' && prop !== 'additionalValues') {
            return this.flattenAdditionalValues(item);
          }
          return item;
        });
      }
      else if (typeof props[prop] === 'object' && prop !== 'additionalValues') {
        props[prop] = this.flattenAdditionalValues(props[prop]);
      }
    }

    const { additionalValues, ...valuesWithoutAdditionalValues } = props;

    return {
      ...valuesWithoutAdditionalValues,
      ...additionalValues,
    };
  }
}

",
}
`;
